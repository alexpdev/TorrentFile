{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TorrentFile \u00a4 \ud83c\udf10 Overview \u00a4 A simple and convenient tool for creating, reviewing, editing, and/or validating bittorrent meta files (aka torrent files). torrentfile supports all versions of Bittorrent files, including hybrid meta files, and has full unicode support. A GUI frontend for this project can be found at https://github.com/alexpdev/TorrentfileQt \ud83d\udd0c Requirements \u00a4 Python 3.6+ Tested on Linux, Windows and Mac \ud83d\udcbb Install \u00a4 via PyPi: pip install torrentfile via Git: git clone https://github.com/alexpdev/torrentfile.git cd torrentfile pip install . Download pre-compiled binaries from the release page . \ud83d\udcda Documentation \u00a4 Documentation can be found here or in the docs directory. torrentfile is under active development, and is subject to significant changes in the codebase between releases. \ud83d\ude80 Usage \u00a4 Usage ===== torrentfile [ -h ] [ -i ] [ -V ] [ -v ] create, edit, magnet, recheck, rebuild ... Command line tools for creating, editing, checking and interacting with Bittorrent metainfo files Options ------- -h, --help show this help message and exit -i, --interactive select program options interactively -q, --quiet activate quiet mode no terminal output -V, --version show program version and exit -v, --verbose output debug information Actions ------- create, edit, magnet, recheck, rebuild create ( c, new ) Generate a new torrent meta file. edit ( e ) Edit existing torrent meta file. magnet ( m ) Generate magnet url from an existing Bittorrent meta file. recheck ( r, check ) Calculate amount of torrent meta files content is found on disk. info ( i ) Show detailed information about a torrent file. rebuild ( build, b ) Re-assemble files obtained from a bittorrent file into the appropriate file structure for re-seeding. Read documentation for more information, or use cases. Usage examples can be found in the project documentation on the examples page. \ud83d\udcdd License \u00a4 Distributed under Apache v2 software license. See LICENSE for more information. \ud83d\udca1 Issues & Requests & PRs \u00a4 If you encounter any bugs or would like to request a new feature please open a new issue. PRs and other contributions are welcome https://github.com/alexpdev/torrentfile/issues Creating Torrents \u00a4 Basic torrent file createion > torrentfile create /path/to/content The -t --tracker -a --announce flags add one or more urls to list of trackers. > torrentfile create /path/to/content --tracker http://tracker1.com > torrentfile create -t http://tracker2 http://tracker3 --private /path/to/content > torrentfile create --tracker http://tracker /path/to/content > torrentfile create -t http://tracker1 http://tracker2 /path/to/content the --private flag indicates use by a private tracker the --source flag can be used to help with cross-seeding > torrentfile create --private --source EXAMPLE --tracker https://url1 https://url2 The options for controlling the progress bar using --prog or --progress : 0 : show no progress bar at all 1 : show progress bar (default) > torrentfile create -t http://tracker.com --progress 2 /path/to/content > torrentfile create --prog 0 /path/to/content to specify the save location use the -o or --out flags if the path points to directory the name of torrent is autofilled. > torrentfile create -o /specific/path/name.torrent ./content to create files using bittorrent v2 use --meta-version 2 likewise --meta-version 3 creates a hybrid torrent file. > torrentfile create --meta-version 2 /path/to/content > torrentfile create --meta-version 3 /path/to/content Check/Recheck Torrent \u00a4 recheck torrent file /path/to/some.torrent with /path/to/content > torrentfile recheck /path/to/some.torrent /path/to/content Edit Torrent \u00a4 edit a torrent file > torrentfile edit [ options ] <path> Create Magnet \u00a4 To create a magnet URI for a pre-existing torrent meta file, use the sub-command magnet or m with the path to the torrent file. > torrentfile magnet /path/to/some.torrent Interactive Mode (expiremental) \u00a4 Alternatively to supplying a bunch of command line arguments, interactive mode allows users to specify program options one at a time from a series of prompts. to activate interactive mode use -i or --interactive flag > torrentfile -i GUI \u00a4 If you prefer a windowed gui please check out the official GUI frontend here","title":"Home"},{"location":"#torrentfile","text":"","title":"TorrentFile"},{"location":"#overview","text":"A simple and convenient tool for creating, reviewing, editing, and/or validating bittorrent meta files (aka torrent files). torrentfile supports all versions of Bittorrent files, including hybrid meta files, and has full unicode support. A GUI frontend for this project can be found at https://github.com/alexpdev/TorrentfileQt","title":"\ud83c\udf10 Overview"},{"location":"#requirements","text":"Python 3.6+ Tested on Linux, Windows and Mac","title":"\ud83d\udd0c Requirements"},{"location":"#install","text":"via PyPi: pip install torrentfile via Git: git clone https://github.com/alexpdev/torrentfile.git cd torrentfile pip install . Download pre-compiled binaries from the release page .","title":"\ud83d\udcbb Install"},{"location":"#documentation","text":"Documentation can be found here or in the docs directory. torrentfile is under active development, and is subject to significant changes in the codebase between releases.","title":"\ud83d\udcda Documentation"},{"location":"#usage","text":"Usage ===== torrentfile [ -h ] [ -i ] [ -V ] [ -v ] create, edit, magnet, recheck, rebuild ... Command line tools for creating, editing, checking and interacting with Bittorrent metainfo files Options ------- -h, --help show this help message and exit -i, --interactive select program options interactively -q, --quiet activate quiet mode no terminal output -V, --version show program version and exit -v, --verbose output debug information Actions ------- create, edit, magnet, recheck, rebuild create ( c, new ) Generate a new torrent meta file. edit ( e ) Edit existing torrent meta file. magnet ( m ) Generate magnet url from an existing Bittorrent meta file. recheck ( r, check ) Calculate amount of torrent meta files content is found on disk. info ( i ) Show detailed information about a torrent file. rebuild ( build, b ) Re-assemble files obtained from a bittorrent file into the appropriate file structure for re-seeding. Read documentation for more information, or use cases. Usage examples can be found in the project documentation on the examples page.","title":"\ud83d\ude80 Usage"},{"location":"#license","text":"Distributed under Apache v2 software license. See LICENSE for more information.","title":"\ud83d\udcdd License"},{"location":"#issues-requests-prs","text":"If you encounter any bugs or would like to request a new feature please open a new issue. PRs and other contributions are welcome https://github.com/alexpdev/torrentfile/issues","title":"\ud83d\udca1 Issues &amp; Requests &amp; PRs"},{"location":"#creating-torrents","text":"Basic torrent file createion > torrentfile create /path/to/content The -t --tracker -a --announce flags add one or more urls to list of trackers. > torrentfile create /path/to/content --tracker http://tracker1.com > torrentfile create -t http://tracker2 http://tracker3 --private /path/to/content > torrentfile create --tracker http://tracker /path/to/content > torrentfile create -t http://tracker1 http://tracker2 /path/to/content the --private flag indicates use by a private tracker the --source flag can be used to help with cross-seeding > torrentfile create --private --source EXAMPLE --tracker https://url1 https://url2 The options for controlling the progress bar using --prog or --progress : 0 : show no progress bar at all 1 : show progress bar (default) > torrentfile create -t http://tracker.com --progress 2 /path/to/content > torrentfile create --prog 0 /path/to/content to specify the save location use the -o or --out flags if the path points to directory the name of torrent is autofilled. > torrentfile create -o /specific/path/name.torrent ./content to create files using bittorrent v2 use --meta-version 2 likewise --meta-version 3 creates a hybrid torrent file. > torrentfile create --meta-version 2 /path/to/content > torrentfile create --meta-version 3 /path/to/content","title":"Creating Torrents"},{"location":"#checkrecheck-torrent","text":"recheck torrent file /path/to/some.torrent with /path/to/content > torrentfile recheck /path/to/some.torrent /path/to/content","title":"Check/Recheck Torrent"},{"location":"#edit-torrent","text":"edit a torrent file > torrentfile edit [ options ] <path>","title":"Edit Torrent"},{"location":"#create-magnet","text":"To create a magnet URI for a pre-existing torrent meta file, use the sub-command magnet or m with the path to the torrent file. > torrentfile magnet /path/to/some.torrent","title":"Create Magnet"},{"location":"#interactive-mode-expiremental","text":"Alternatively to supplying a bunch of command line arguments, interactive mode allows users to specify program options one at a time from a series of prompts. to activate interactive mode use -i or --interactive flag > torrentfile -i","title":"Interactive Mode (expiremental)"},{"location":"#gui","text":"If you prefer a windowed gui please check out the official GUI frontend here","title":"GUI"},{"location":"Apache2/","text":"Apache License \u00a4 Version 2.0, January 2004 < http://www.apache.org/licenses/ > Terms and Conditions for use, reproduction, and distribution \u00a4 1. Definitions \u00a4 \u201cLicense\u201d shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \u201cLicensor\u201d shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \u201cLegal Entity\u201d shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u201ccontrol\u201d means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \u201cYou\u201d (or \u201cYour\u201d) shall mean an individual or Legal Entity exercising permissions granted by this License. \u201cSource\u201d form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \u201cObject\u201d form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \u201cWork\u201d shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \u201cDerivative Works\u201d shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \u201cContribution\u201d shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u201csubmitted\u201d means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u201cNot a Contribution.\u201d \u201cContributor\u201d shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License \u00a4 Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License \u00a4 Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution \u00a4 You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \u201cNOTICE\u201d text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions \u00a4 Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks \u00a4 This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty \u00a4 Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability \u00a4 In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability \u00a4 While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work \u00a4 To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets [] replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \u201cprinted page\u201d as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"Apache2/#apache-license","text":"Version 2.0, January 2004 < http://www.apache.org/licenses/ >","title":"Apache License"},{"location":"Apache2/#terms-and-conditions-for-use-reproduction-and-distribution","text":"","title":"Terms and Conditions for use, reproduction, and distribution"},{"location":"Apache2/#1-definitions","text":"\u201cLicense\u201d shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \u201cLicensor\u201d shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \u201cLegal Entity\u201d shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u201ccontrol\u201d means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \u201cYou\u201d (or \u201cYour\u201d) shall mean an individual or Legal Entity exercising permissions granted by this License. \u201cSource\u201d form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \u201cObject\u201d form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \u201cWork\u201d shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \u201cDerivative Works\u201d shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \u201cContribution\u201d shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u201csubmitted\u201d means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u201cNot a Contribution.\u201d \u201cContributor\u201d shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.","title":"1. Definitions"},{"location":"Apache2/#2-grant-of-copyright-license","text":"Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.","title":"2. Grant of Copyright License"},{"location":"Apache2/#3-grant-of-patent-license","text":"Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.","title":"3. Grant of Patent License"},{"location":"Apache2/#4-redistribution","text":"You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \u201cNOTICE\u201d text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.","title":"4. Redistribution"},{"location":"Apache2/#5-submission-of-contributions","text":"Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.","title":"5. Submission of Contributions"},{"location":"Apache2/#6-trademarks","text":"This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.","title":"6. Trademarks"},{"location":"Apache2/#7-disclaimer-of-warranty","text":"Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.","title":"7. Disclaimer of Warranty"},{"location":"Apache2/#8-limitation-of-liability","text":"In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.","title":"8. Limitation of Liability"},{"location":"Apache2/#9-accepting-warranty-or-additional-liability","text":"While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS","title":"9. Accepting Warranty or Additional Liability"},{"location":"Apache2/#appendix-how-to-apply-the-apache-license-to-your-work","text":"To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets [] replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \u201cprinted page\u201d as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"APPENDIX: How to apply the Apache License to your work"},{"location":"Overview/","text":"torrentfile Manual \u00a4 Synopsis \u00a4 torrentfile [options] <subcommand> [options] <args> Description \u00a4 torrentfile is a command line toolkit for working with Bittorrent files(.torrent). Some of the tools available include creating torrent files, editing portions of a torrent file, checking the integrity or completeness of downloaded torrent contents, displaying details of a torrentfile, generating magnet URLs for torrentfiles, and individual or batch rebuilding of torrent contents into their original directory structure. Options \u00a4 -h displays all relevant command line options and subcommands. -V displays program and version. -v enables debug mode and outputs a large amount of information to the terminal. -i activates interactive mode for selecting subcommands and options. Sub-commands \u00a4 create \u00a4 alias: c , new torrentfile create [options] <path> torrentfile c [options] <path> The create subcommand is used for generating new torrent files. The only required argument is the path( <path> ) to the contents file or directory. -a -t --announce --tracker Adds the list of url's that follow to the list of trackers for the newly created torrent file. Example -t http://url1 https://url2 ... -w --web-seeds Adds the list of urls that follow to the list of web-seed addresses for the newly created torrent file. --comment Includes the comment that follows to the metadata saved in the newly created torrent file. Example: --comment \"Created for MyTrackerExample.com\" --source Creates a source field in the info dictionary with the string that follows as the value. Frequently used for cross-seeding on private trackers. Example: --source MyTrackerExample -p --private Indicates that the torrent will be used on a private tracker. Disables multi-tracker protocols and DHT. --piece-length Uses the number that follows as the piece-length size for the newly created torrent file. If option isn't used the program will pick the ideal size. Acceptable values include 14-29 which is interpreted as the number to raise 2 by (e.g. 14 is interpreted as 16384), or any perfect power of 2 greater than or equal to 16 KiB and less than 1 GiB. Example: --piece-length 14 or --piece-length 16384 . --meta-version Use the following number as the Bittorrent version the torrent will be used on. The default is 1. Options: 1 - Bittorrent v1, 2 - Bittorrent v2, 3 - Bittorrent v1 & v2 Examples: --meta-version 1 , --meta-version 2 , --meta-version 3 -o --out Specify the full path to the newly created torrent file. The default is to save it adjacent to the content. Example: if content is at /home/user/torrents/content the default would create /home/user/torrents/content.torrent --cwd --current Changes the default save location to the current working directory. Example: if content is at /home/user/torrents/content this option would create ./content.torrent --progress --prog Options (0, 1): No status bar will be shown if 0. Otherwise the default and 1 argument means progress bar is shown info \u00a4 alias: i torrentfile info <path> torrentfile i <path> Display detailed information about a torrentfile such as trackers, size of contents, Bittorrent version, any comments left, date the torrent file was created and more. There is only one positional perameter which is the path to the torrent file and there are no optional arguments. /path/to/*.torrent The relative or absolute path to the torrent file. edit \u00a4 Edit some of the different information detailed in a torrent file. The fields that are editable each have option flags detialed below. Each option identifies the field to edit inside the torrent file and what the new value should be. If an option is not used then its field will be ommited in the newly created torrent file. As such if the file is marked as private and it should remain that way, the -p option should be used. alias: e torrentfile edit [options] <path> torrentfile e [options] <path> -a -t --announce --tracker Adds the list of url's that follow to the list of trackers for the newly created torrent file. Example -t http://url1 https://url2 ... -w --web-seeds Adds the list of urls that follow to the list of web-seed addresses for the newly created torrent file. --comment Includes the comment that follows to the metadata saved in the newly created torrent file. Example: --comment \"Created for MyTrackerExample.com\" --source Creates a source field in the info dictionary with the string that follows as the value. Frequently used for cross-seeding on private trackers. Example: --source MyTrackerExample -p --private Indicates that the torrent will be used on a private tracker. Disables multi-tracker protocols and DHT. recheck \u00a4 Recheck requires two paths as arguments. The first is the path to a torrent file, and and the second is a path to the file of directory containing the downloaded data from that torrentfile. torrentfile recursively validates each file with the hashes contained in the torrentfile, and displays the amount missing frome each file, plus a final percentage for the whole torrent at the conclusion. This will display a progress bar for each file including missing files. It is also permitted to use the contents parent directory which can help for batch processing many torrent files. alias: r , check torrentfile recheck <*.torrent> <contents> torrentfile r <*.torrent> <contents> Magnet \u00a4 Generate a magnet URL for a torrent file. alias: m torrentfile magnet <path/to/*.torrent> Rebuild \u00a4 Rebuild individual or batches of torrent contents into the original file structure. The program takes a path to a torrent file or directory containing torrent files, the directory containing the torrent contents, and the destination directory to where the rebuilt torrent content wil be located. The program will recursively traverse the content directory searching for file's that match one of the meta files and creates copies of the matches to the destination directory. The original files are not effected and any existing files in the target directory will not be overwritten. alias: build , b torrentfile rebuild <metafiles> <contents> <destination>","title":"Overview"},{"location":"Overview/#torrentfile-manual","text":"","title":"torrentfile Manual"},{"location":"Overview/#synopsis","text":"torrentfile [options] <subcommand> [options] <args>","title":"Synopsis"},{"location":"Overview/#description","text":"torrentfile is a command line toolkit for working with Bittorrent files(.torrent). Some of the tools available include creating torrent files, editing portions of a torrent file, checking the integrity or completeness of downloaded torrent contents, displaying details of a torrentfile, generating magnet URLs for torrentfiles, and individual or batch rebuilding of torrent contents into their original directory structure.","title":"Description"},{"location":"Overview/#options","text":"-h displays all relevant command line options and subcommands. -V displays program and version. -v enables debug mode and outputs a large amount of information to the terminal. -i activates interactive mode for selecting subcommands and options.","title":"Options"},{"location":"Overview/#sub-commands","text":"","title":"Sub-commands"},{"location":"Overview/#create","text":"alias: c , new torrentfile create [options] <path> torrentfile c [options] <path> The create subcommand is used for generating new torrent files. The only required argument is the path( <path> ) to the contents file or directory. -a -t --announce --tracker Adds the list of url's that follow to the list of trackers for the newly created torrent file. Example -t http://url1 https://url2 ... -w --web-seeds Adds the list of urls that follow to the list of web-seed addresses for the newly created torrent file. --comment Includes the comment that follows to the metadata saved in the newly created torrent file. Example: --comment \"Created for MyTrackerExample.com\" --source Creates a source field in the info dictionary with the string that follows as the value. Frequently used for cross-seeding on private trackers. Example: --source MyTrackerExample -p --private Indicates that the torrent will be used on a private tracker. Disables multi-tracker protocols and DHT. --piece-length Uses the number that follows as the piece-length size for the newly created torrent file. If option isn't used the program will pick the ideal size. Acceptable values include 14-29 which is interpreted as the number to raise 2 by (e.g. 14 is interpreted as 16384), or any perfect power of 2 greater than or equal to 16 KiB and less than 1 GiB. Example: --piece-length 14 or --piece-length 16384 . --meta-version Use the following number as the Bittorrent version the torrent will be used on. The default is 1. Options: 1 - Bittorrent v1, 2 - Bittorrent v2, 3 - Bittorrent v1 & v2 Examples: --meta-version 1 , --meta-version 2 , --meta-version 3 -o --out Specify the full path to the newly created torrent file. The default is to save it adjacent to the content. Example: if content is at /home/user/torrents/content the default would create /home/user/torrents/content.torrent --cwd --current Changes the default save location to the current working directory. Example: if content is at /home/user/torrents/content this option would create ./content.torrent --progress --prog Options (0, 1): No status bar will be shown if 0. Otherwise the default and 1 argument means progress bar is shown","title":"create"},{"location":"Overview/#info","text":"alias: i torrentfile info <path> torrentfile i <path> Display detailed information about a torrentfile such as trackers, size of contents, Bittorrent version, any comments left, date the torrent file was created and more. There is only one positional perameter which is the path to the torrent file and there are no optional arguments. /path/to/*.torrent The relative or absolute path to the torrent file.","title":"info"},{"location":"Overview/#edit","text":"Edit some of the different information detailed in a torrent file. The fields that are editable each have option flags detialed below. Each option identifies the field to edit inside the torrent file and what the new value should be. If an option is not used then its field will be ommited in the newly created torrent file. As such if the file is marked as private and it should remain that way, the -p option should be used. alias: e torrentfile edit [options] <path> torrentfile e [options] <path> -a -t --announce --tracker Adds the list of url's that follow to the list of trackers for the newly created torrent file. Example -t http://url1 https://url2 ... -w --web-seeds Adds the list of urls that follow to the list of web-seed addresses for the newly created torrent file. --comment Includes the comment that follows to the metadata saved in the newly created torrent file. Example: --comment \"Created for MyTrackerExample.com\" --source Creates a source field in the info dictionary with the string that follows as the value. Frequently used for cross-seeding on private trackers. Example: --source MyTrackerExample -p --private Indicates that the torrent will be used on a private tracker. Disables multi-tracker protocols and DHT.","title":"edit"},{"location":"Overview/#recheck","text":"Recheck requires two paths as arguments. The first is the path to a torrent file, and and the second is a path to the file of directory containing the downloaded data from that torrentfile. torrentfile recursively validates each file with the hashes contained in the torrentfile, and displays the amount missing frome each file, plus a final percentage for the whole torrent at the conclusion. This will display a progress bar for each file including missing files. It is also permitted to use the contents parent directory which can help for batch processing many torrent files. alias: r , check torrentfile recheck <*.torrent> <contents> torrentfile r <*.torrent> <contents>","title":"recheck"},{"location":"Overview/#magnet","text":"Generate a magnet URL for a torrent file. alias: m torrentfile magnet <path/to/*.torrent>","title":"Magnet"},{"location":"Overview/#rebuild","text":"Rebuild individual or batches of torrent contents into the original file structure. The program takes a path to a torrent file or directory containing torrent files, the directory containing the torrent contents, and the destination directory to where the rebuilt torrent content wil be located. The program will recursively traverse the content directory searching for file's that match one of the meta files and creates copies of the matches to the destination directory. The original files are not effected and any existing files in the target directory will not be overwritten. alias: build , b torrentfile rebuild <metafiles> <contents> <destination>","title":"Rebuild"},{"location":"Usage/","text":"TorrentFile CLI Menu \u00a4 Help Messages \u00a4 Main \u00a4 Usage ===== torrentfile [-h] [-i] [-V] [-v] <create> <edit> <magnet> <recheck> ... CLI Tool for creating, checking, editing... Bittorrent meta files. TorrentFile supports all versions of torrent files. Options ------- -h, --help show this help message and exit -i, --interactive select program options interactively -V, --version show program version and exit -v, --verbose output debug information Actions ------- <create> <edit> <magnet> <recheck> c (create, new) Create a torrent meta file. e (edit) Edit existing torrent meta file. m (magnet) Create magnet url from an existing Bittorrent meta file. r (recheck, check) Calculate amount of torrent meta file's content is found on disk. i (info) Show detailed information about a torrent file. Create \u00a4 Usage ===== torrentfile c [-h] [-a <url> [<url> ...]] [-p] [-s <source>] [-m] [-c <comment>] [-o <path>] [-t <url> [<url> ...]] [--noprogress] [--meta-version <int>] [--piece-length <int>] [-w <url> [<url> ...]] <content> Positional Arguments -------------------- <content> Path to content file or directory Optional Arguments ------------------ -h, --help show this help message and exit -a <url> [<url> ...], --announce <url> [<url> ...] Alias for -t/--tracker -p, --private Create a private torrent file -s <source>, --source <source> Useful for cross-seeding -m, --magnet Output Magnet Link after creation completes -c <comment>, --comment <comment> Include a comment in file metadata -o <path>, --out <path> Output path for created .torrent file -t <url> [<url> ...], --tracker <url> [<url> ...] One or more Bittorrent tracker announce url(s). --prog, --progress <level> (0) = no progress bar displayed (1) = progress bar is displayed (default) --meta-version <int> Bittorrent metafile version. Options - {1, 2, 3} (1) = Bittorrent v1 (Default) (2) = Bittorrent v2 (3) = Bittorrent v1 & v2 hybrid --piece-length <int> Number of bytes per piece. (Default: None) Acceptable inputs include {14 - 24} as exponent for 2^n, or any acceptable integer value (must be power of 2). Examples:: [--piece-length 14] [--piece-length 16777216] -w <url> [<url> ...], --web-seed <url> [<url> ...] One or more url(s) linking to a http server hosting the torrent contents. This is useful if the torrent tracker is ever unreachable. Example:: -w url1 url2 url3 Edit \u00a4 Usage ===== torrentfile e [-h] [--tracker <url> [<url> ...]] [--web-seed <url> [<url> ...]] [--private] [--comment <comment>] [--source <source>] <*.torrent> Positional Arguments -------------------- <*.torrent> path to *.torrent file Optional Arguments ------------------ -h, --help show this help message and exit --tracker <url> [<url> ...] Replace current list of tracker/announce urls with one or more space seperated Bittorrent tracker announce url(s). --web-seed <url> [<url> ...] Replace current list of web-seed urls with one or more space seperated url(s) --private Make torrent private. --comment <comment> Replaces any existing comment with <comment> --source <source> Replaces current source with <source> Recheck \u00a4 Usage ===== torrentfile r [-h] <*.torrent> <content> Positional Arguments -------------------- <*.torrent> path to .torrent file. <content> path to content file or directory Optional Arguments ------------------ -h, --help show this help message and exit Magnet \u00a4 Usage ===== torrentfile m [-h] <*.torrent> Positional Arguments -------------------- <*.torrent> Path to Bittorrent meta file. Optional Arguments ------------------ -h, --help show this help message and exit","title":"Usage"},{"location":"Usage/#torrentfile-cli-menu","text":"","title":"TorrentFile CLI Menu"},{"location":"Usage/#help-messages","text":"","title":"Help Messages"},{"location":"Usage/#main","text":"Usage ===== torrentfile [-h] [-i] [-V] [-v] <create> <edit> <magnet> <recheck> ... CLI Tool for creating, checking, editing... Bittorrent meta files. TorrentFile supports all versions of torrent files. Options ------- -h, --help show this help message and exit -i, --interactive select program options interactively -V, --version show program version and exit -v, --verbose output debug information Actions ------- <create> <edit> <magnet> <recheck> c (create, new) Create a torrent meta file. e (edit) Edit existing torrent meta file. m (magnet) Create magnet url from an existing Bittorrent meta file. r (recheck, check) Calculate amount of torrent meta file's content is found on disk. i (info) Show detailed information about a torrent file.","title":"Main"},{"location":"Usage/#create","text":"Usage ===== torrentfile c [-h] [-a <url> [<url> ...]] [-p] [-s <source>] [-m] [-c <comment>] [-o <path>] [-t <url> [<url> ...]] [--noprogress] [--meta-version <int>] [--piece-length <int>] [-w <url> [<url> ...]] <content> Positional Arguments -------------------- <content> Path to content file or directory Optional Arguments ------------------ -h, --help show this help message and exit -a <url> [<url> ...], --announce <url> [<url> ...] Alias for -t/--tracker -p, --private Create a private torrent file -s <source>, --source <source> Useful for cross-seeding -m, --magnet Output Magnet Link after creation completes -c <comment>, --comment <comment> Include a comment in file metadata -o <path>, --out <path> Output path for created .torrent file -t <url> [<url> ...], --tracker <url> [<url> ...] One or more Bittorrent tracker announce url(s). --prog, --progress <level> (0) = no progress bar displayed (1) = progress bar is displayed (default) --meta-version <int> Bittorrent metafile version. Options - {1, 2, 3} (1) = Bittorrent v1 (Default) (2) = Bittorrent v2 (3) = Bittorrent v1 & v2 hybrid --piece-length <int> Number of bytes per piece. (Default: None) Acceptable inputs include {14 - 24} as exponent for 2^n, or any acceptable integer value (must be power of 2). Examples:: [--piece-length 14] [--piece-length 16777216] -w <url> [<url> ...], --web-seed <url> [<url> ...] One or more url(s) linking to a http server hosting the torrent contents. This is useful if the torrent tracker is ever unreachable. Example:: -w url1 url2 url3","title":"Create"},{"location":"Usage/#edit","text":"Usage ===== torrentfile e [-h] [--tracker <url> [<url> ...]] [--web-seed <url> [<url> ...]] [--private] [--comment <comment>] [--source <source>] <*.torrent> Positional Arguments -------------------- <*.torrent> path to *.torrent file Optional Arguments ------------------ -h, --help show this help message and exit --tracker <url> [<url> ...] Replace current list of tracker/announce urls with one or more space seperated Bittorrent tracker announce url(s). --web-seed <url> [<url> ...] Replace current list of web-seed urls with one or more space seperated url(s) --private Make torrent private. --comment <comment> Replaces any existing comment with <comment> --source <source> Replaces current source with <source>","title":"Edit"},{"location":"Usage/#recheck","text":"Usage ===== torrentfile r [-h] <*.torrent> <content> Positional Arguments -------------------- <*.torrent> path to .torrent file. <content> path to content file or directory Optional Arguments ------------------ -h, --help show this help message and exit","title":"Recheck"},{"location":"Usage/#magnet","text":"Usage ===== torrentfile m [-h] <*.torrent> Positional Arguments -------------------- <*.torrent> Path to Bittorrent meta file. Optional Arguments ------------------ -h, --help show this help message and exit","title":"Magnet"},{"location":"changelog/","text":"TorrentFile \u00a4 Version 0.8.0 \u00a4 overhaul documentation reconfigured CI files and configuration and packaging files Convert to pyproject.toml setuptools packaging info source Version 0.7.12 \u00a4 Changed default behavior to save torrent files to cwd edited all unittests to reflect default behavior added deprecation messages for the cli arg and class paramteter last update to version 0.7.x Version 0.7.11 \u00a4 Fixed issue with progress bar displaying inaccurate details Other minor bug fixes Updated output for Recheck subcommand for better readability Updated documentation Updated Readme added quiet mode to cli global options -q Added unit test to fix coverage gaps Fixed warnings created by pylint Version 0.7.10 \u00a4 Added rebuild module and subcommand see docs for more info Added documentation entry for rebuild subcommand improved logging messages added unit tests improved and expanded on type hints minor bug fixes Version 0.7.9 \u00a4 complete rewrite of the recheck procedures Recheck now provides more accuracy and more details improvements to the new custom progressbar changed the cli argument for the progress bar the options are now just 0 and 1 included new unit tests for all new features marked unused functions as deprecated added a new hasher object for v2 and hybrid torrents minor bug fixes and styling changes Version 0.7.8 \u00a4 more updates to logging major improvements to progress bar removed tqdm as dependency implemented custom progress bar logic new cli argument controlling the progress bar support for pyben 0.3.1 added threading to recheck module added mixins module unit test updates and improvements Version 0.7.5 \u00a4 updates to logging facility fixed bug in created hybrid torrent files fixed cli when subcomman not chosen doc updates unit test updates and improvements Version 0.7.2 \u00a4 cleaned up readme and help messages removed useless print statements improved CI tooling and checking minor bug fixes Version 0.7.1 \u00a4 split CI integration into separate platform specific files added new cli argument --cwd which changes the default save to location to the current working directory (this will be default in future) added unit tests to cover the new argument Changed license to a the more permissive Apache 2 software license Version 0.7.0 \u00a4 Fixed issues with logging to file. Finished adding tests for Unicode Support Deprecated some unneccessary code Clean up documentation and README removed config files no longer in use. Version 0.6.13 \u00a4 Fixed bug that created a torrent file with no name. Fixed bug that would error if cli path was listed after announce urls Added full unicode support. Added Unittests for new features and bug fixes Version 0.6.11 \u00a4 Fixed bug that occured during recheck when file of 0 length is included. Altered Recheck algorithm to process 0 length files. Only effected meta version 2 and hybrid torrent files. Added unittests to cover the situation. Version 0.6.10 \u00a4 Updates to documentation Integrated Type hints in source code Updated build and CI process Version 0.6.9 \u00a4 The --progress flag is now --noprogress Default behavior is to show progress bar use --noprogress to not show added CLI Help format strings added custom CLI help formatter class Titled Help Message section headers Fixed a bunch of error pages created by mkdocs Version 0.6.8 \u00a4 Documentation for newest features CLI usage examples Improved unittests made progress bar active by default Version 0.6.7 \u00a4 Updates to API Version 0.6.6 \u00a4 bug that created faulty Bittorrent V2 meta files in some instances. back to working as it should. Version 0.6.5 \u00a4 Support for creating Magnet URI's Added optional progress bar for torrent creation Log File handler CLI args page in documentation verbose and logging bugs multi tracker errors bug Version 0.6.4 \u00a4 CLI interface add subcommands added interactive mode Re-wrote the recheck module fixed documentation and docstrings linting and testing errors Version 0.6.3 \u00a4 Fixed Bug that would format list of trackers incorrectly CLI Bug Fixes Version 0.6.2 \u00a4 Bug fixes Documentation error pages Version 0.6.0 \u00a4 cli commands alterations debug logging during creation process Version 0.5.2 \u00a4 Fixed Bug that was adding wrong fields to info dict Version 0.5.0 \u00a4 Slew of new unit tests Stricter linting features Alternative method of -re-check feature Bug Fixes CLI help formatting errors Version 0.4.8 \u00a4 Improved Algorithm performance for ReCheck. Additions to documentation. Version 0.4.7 \u00a4 Fixed A bug that misspelled a field when creating Hybrid torrent files. Re-Check procedure for v2 and hybrid torrent file checking. Version 0.4.6 \u00a4 CLI Help and Usage Messages. Expanded CLI args. Completely new CheckerClass which replaces old Checker Hooks for GUI or other 3rd party apps to hook into Checking Documentation and Unit tests for new CheckerClass Version 0.4.5 \u00a4 Documentation and docstrings improvements Better code formating and more detailed docstrings More unit tests. Version 0.4.2 \u00a4 The ReChecker feature now supports v1, v2, & hybrid .torrent file. Bug in CLI for python < 3.8 Version 0.4.1 \u00a4 Added tests for hybrid class Added logging features new cli flag to activate debug mode Documentation theme. Fixed Bug that allowed improper piece length values. Version 0.4.0 \u00a4 Fixed bugs in creating hybrid files. Bug Fix that broke cli. Version 0.3.0 \u00a4 Added/Improved support for hybrid meta files. Many additions to testing suit including linting and coverage tests. Version 0.2.8 \u00a4 Styling fixes. Bug Fixes. Prelimenary support for bittorrent hybrid meta files. Bug Fixes Version 0.2.7 \u00a4 major imporvements to torrentfile-GUI. minor adjustments to this package for integration. Code consolidation Bug Fixes Documentation additions Implemented CI/CD Integration Version 0.2.3 \u00a4 Bug Fixes Code Style and Formatting Added more unittests Version 0.2.1 \u00a4 Bittorrent Protocol V2 Support v2 metafile options to cli v2 metafile tests Version 0.1.7 \u00a4 Docstrings Improvements. Added documentation rederer. Improved readme file. formatting Version 0.1.2 \u00a4 Added a Command Line Interface Rough Graphical User Interface Minor Bug Fixes Improved unittest coverage Version 0.1.0 \u00a4 added SHA256 support Feeder class for seemless file switching Fixed the primary entrypoint function. Improved docstrings Bug fixes Version 0.0.2 \u00a4 Added Unittests added bencode support added hashing support Version 0.0.1 \u00a4 Initial concept and planning","title":"Changelog"},{"location":"changelog/#torrentfile","text":"","title":"TorrentFile"},{"location":"changelog/#version-080","text":"overhaul documentation reconfigured CI files and configuration and packaging files Convert to pyproject.toml setuptools packaging info source","title":"Version 0.8.0"},{"location":"changelog/#version-0712","text":"Changed default behavior to save torrent files to cwd edited all unittests to reflect default behavior added deprecation messages for the cli arg and class paramteter last update to version 0.7.x","title":"Version 0.7.12"},{"location":"changelog/#version-0711","text":"Fixed issue with progress bar displaying inaccurate details Other minor bug fixes Updated output for Recheck subcommand for better readability Updated documentation Updated Readme added quiet mode to cli global options -q Added unit test to fix coverage gaps Fixed warnings created by pylint","title":"Version 0.7.11"},{"location":"changelog/#version-0710","text":"Added rebuild module and subcommand see docs for more info Added documentation entry for rebuild subcommand improved logging messages added unit tests improved and expanded on type hints minor bug fixes","title":"Version 0.7.10"},{"location":"changelog/#version-079","text":"complete rewrite of the recheck procedures Recheck now provides more accuracy and more details improvements to the new custom progressbar changed the cli argument for the progress bar the options are now just 0 and 1 included new unit tests for all new features marked unused functions as deprecated added a new hasher object for v2 and hybrid torrents minor bug fixes and styling changes","title":"Version 0.7.9"},{"location":"changelog/#version-078","text":"more updates to logging major improvements to progress bar removed tqdm as dependency implemented custom progress bar logic new cli argument controlling the progress bar support for pyben 0.3.1 added threading to recheck module added mixins module unit test updates and improvements","title":"Version 0.7.8"},{"location":"changelog/#version-075","text":"updates to logging facility fixed bug in created hybrid torrent files fixed cli when subcomman not chosen doc updates unit test updates and improvements","title":"Version 0.7.5"},{"location":"changelog/#version-072","text":"cleaned up readme and help messages removed useless print statements improved CI tooling and checking minor bug fixes","title":"Version 0.7.2"},{"location":"changelog/#version-071","text":"split CI integration into separate platform specific files added new cli argument --cwd which changes the default save to location to the current working directory (this will be default in future) added unit tests to cover the new argument Changed license to a the more permissive Apache 2 software license","title":"Version 0.7.1"},{"location":"changelog/#version-070","text":"Fixed issues with logging to file. Finished adding tests for Unicode Support Deprecated some unneccessary code Clean up documentation and README removed config files no longer in use.","title":"Version 0.7.0"},{"location":"changelog/#version-0613","text":"Fixed bug that created a torrent file with no name. Fixed bug that would error if cli path was listed after announce urls Added full unicode support. Added Unittests for new features and bug fixes","title":"Version 0.6.13"},{"location":"changelog/#version-0611","text":"Fixed bug that occured during recheck when file of 0 length is included. Altered Recheck algorithm to process 0 length files. Only effected meta version 2 and hybrid torrent files. Added unittests to cover the situation.","title":"Version 0.6.11"},{"location":"changelog/#version-0610","text":"Updates to documentation Integrated Type hints in source code Updated build and CI process","title":"Version 0.6.10"},{"location":"changelog/#version-069","text":"The --progress flag is now --noprogress Default behavior is to show progress bar use --noprogress to not show added CLI Help format strings added custom CLI help formatter class Titled Help Message section headers Fixed a bunch of error pages created by mkdocs","title":"Version 0.6.9"},{"location":"changelog/#version-068","text":"Documentation for newest features CLI usage examples Improved unittests made progress bar active by default","title":"Version 0.6.8"},{"location":"changelog/#version-067","text":"Updates to API","title":"Version 0.6.7"},{"location":"changelog/#version-066","text":"bug that created faulty Bittorrent V2 meta files in some instances. back to working as it should.","title":"Version 0.6.6"},{"location":"changelog/#version-065","text":"Support for creating Magnet URI's Added optional progress bar for torrent creation Log File handler CLI args page in documentation verbose and logging bugs multi tracker errors bug","title":"Version 0.6.5"},{"location":"changelog/#version-064","text":"CLI interface add subcommands added interactive mode Re-wrote the recheck module fixed documentation and docstrings linting and testing errors","title":"Version 0.6.4"},{"location":"changelog/#version-063","text":"Fixed Bug that would format list of trackers incorrectly CLI Bug Fixes","title":"Version 0.6.3"},{"location":"changelog/#version-062","text":"Bug fixes Documentation error pages","title":"Version 0.6.2"},{"location":"changelog/#version-060","text":"cli commands alterations debug logging during creation process","title":"Version 0.6.0"},{"location":"changelog/#version-052","text":"Fixed Bug that was adding wrong fields to info dict","title":"Version 0.5.2"},{"location":"changelog/#version-050","text":"Slew of new unit tests Stricter linting features Alternative method of -re-check feature Bug Fixes CLI help formatting errors","title":"Version 0.5.0"},{"location":"changelog/#version-048","text":"Improved Algorithm performance for ReCheck. Additions to documentation.","title":"Version 0.4.8"},{"location":"changelog/#version-047","text":"Fixed A bug that misspelled a field when creating Hybrid torrent files. Re-Check procedure for v2 and hybrid torrent file checking.","title":"Version 0.4.7"},{"location":"changelog/#version-046","text":"CLI Help and Usage Messages. Expanded CLI args. Completely new CheckerClass which replaces old Checker Hooks for GUI or other 3rd party apps to hook into Checking Documentation and Unit tests for new CheckerClass","title":"Version 0.4.6"},{"location":"changelog/#version-045","text":"Documentation and docstrings improvements Better code formating and more detailed docstrings More unit tests.","title":"Version 0.4.5"},{"location":"changelog/#version-042","text":"The ReChecker feature now supports v1, v2, & hybrid .torrent file. Bug in CLI for python < 3.8","title":"Version 0.4.2"},{"location":"changelog/#version-041","text":"Added tests for hybrid class Added logging features new cli flag to activate debug mode Documentation theme. Fixed Bug that allowed improper piece length values.","title":"Version 0.4.1"},{"location":"changelog/#version-040","text":"Fixed bugs in creating hybrid files. Bug Fix that broke cli.","title":"Version 0.4.0"},{"location":"changelog/#version-030","text":"Added/Improved support for hybrid meta files. Many additions to testing suit including linting and coverage tests.","title":"Version 0.3.0"},{"location":"changelog/#version-028","text":"Styling fixes. Bug Fixes. Prelimenary support for bittorrent hybrid meta files. Bug Fixes","title":"Version 0.2.8"},{"location":"changelog/#version-027","text":"major imporvements to torrentfile-GUI. minor adjustments to this package for integration. Code consolidation Bug Fixes Documentation additions Implemented CI/CD Integration","title":"Version 0.2.7"},{"location":"changelog/#version-023","text":"Bug Fixes Code Style and Formatting Added more unittests","title":"Version 0.2.3"},{"location":"changelog/#version-021","text":"Bittorrent Protocol V2 Support v2 metafile options to cli v2 metafile tests","title":"Version 0.2.1"},{"location":"changelog/#version-017","text":"Docstrings Improvements. Added documentation rederer. Improved readme file. formatting","title":"Version 0.1.7"},{"location":"changelog/#version-012","text":"Added a Command Line Interface Rough Graphical User Interface Minor Bug Fixes Improved unittest coverage","title":"Version 0.1.2"},{"location":"changelog/#version-010","text":"added SHA256 support Feeder class for seemless file switching Fixed the primary entrypoint function. Improved docstrings Bug fixes","title":"Version 0.1.0"},{"location":"changelog/#version-002","text":"Added Unittests added bencode support added hashing support","title":"Version 0.0.2"},{"location":"changelog/#version-001","text":"Initial concept and planning","title":"Version 0.0.1"},{"location":"cli/","text":"Command Line Interface for TorrentFile project. This module provides the primary command line argument parser for the torrentfile package. The main_script function is automatically invoked when called from command line, and parses accompanying arguments. Functions main_script: process command line arguments and run program. activate_logger: turns on debug mode and logging facility. Config \u00a4 Class the controls the logging configuration and output settings. Controls the logging level, or whether to app should operate in quiet mode. Source code in torrentfile\\cli.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class Config : \"\"\" Class the controls the logging configuration and output settings. Controls the logging level, or whether to app should operate in quiet mode. \"\"\" @staticmethod def activate_quiet (): \"\"\" Activate quiet mode for the duration of the programs life. When quiet mode is enabled, no logging, progress or state information is output to the terminal \"\"\" if sys . stdout or sys . stderr : sys . stdout = io . StringIO () sys . stderr = io . StringIO () @staticmethod def activate_logger (): \"\"\" Activate the builtin logging mechanism when passed debug flag from CLI. \"\"\" logging . basicConfig ( level = logging . INFO ) logger = logging . getLogger () console_handler = logging . StreamHandler ( stream = sys . stderr ) stream_formatter = logging . Formatter ( \" %(asctime)s %(levelno)s %(message)s \" , datefmt = \"%m- %d %H:%M:%S\" , style = \"%\" , ) console_handler . setFormatter ( stream_formatter ) console_handler . setLevel ( logging . DEBUG ) logger . setLevel ( logging . DEBUG ) logger . addHandler ( console_handler ) logger . debug ( \"Debug: ON\" ) activate_logger () staticmethod \u00a4 Activate the builtin logging mechanism when passed debug flag from CLI. Source code in torrentfile\\cli.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 @staticmethod def activate_logger (): \"\"\" Activate the builtin logging mechanism when passed debug flag from CLI. \"\"\" logging . basicConfig ( level = logging . INFO ) logger = logging . getLogger () console_handler = logging . StreamHandler ( stream = sys . stderr ) stream_formatter = logging . Formatter ( \" %(asctime)s %(levelno)s %(message)s \" , datefmt = \"%m- %d %H:%M:%S\" , style = \"%\" , ) console_handler . setFormatter ( stream_formatter ) console_handler . setLevel ( logging . DEBUG ) logger . setLevel ( logging . DEBUG ) logger . addHandler ( console_handler ) logger . debug ( \"Debug: ON\" ) activate_quiet () staticmethod \u00a4 Activate quiet mode for the duration of the programs life. When quiet mode is enabled, no logging, progress or state information is output to the terminal Source code in torrentfile\\cli.py 48 49 50 51 52 53 54 55 56 57 58 @staticmethod def activate_quiet (): \"\"\" Activate quiet mode for the duration of the programs life. When quiet mode is enabled, no logging, progress or state information is output to the terminal \"\"\" if sys . stdout or sys . stderr : sys . stdout = io . StringIO () sys . stderr = io . StringIO () TorrentFileHelpFormatter \u00a4 Bases: HelpFormatter Formatting class for help tips provided by the CLI. Subclasses Argparse.HelpFormatter. Source code in torrentfile\\cli.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 class TorrentFileHelpFormatter ( HelpFormatter ): \"\"\" Formatting class for help tips provided by the CLI. Subclasses Argparse.HelpFormatter. \"\"\" def __init__ ( self , prog , width = 45 , max_help_positions = 45 ): \"\"\" Construct HelpFormat class for usage output. Parameters ---------- prog : str Name of the program. width : int Max width of help message output. max_help_positions : int max length until line wrap. \"\"\" super () . __init__ ( prog , width = width , max_help_position = max_help_positions ) def _split_lines ( self , text , _ ): \"\"\" Split multiline help messages and remove indentation. Parameters ---------- text : str text that needs to be split _ : int max width for line. \"\"\" lines = text . split ( \" \\n \" ) return [ line . strip () for line in lines if line ] def _format_text ( self , text ): \"\"\" Format text for cli usage messages. Parameters ---------- text : str Pre-formatted text. Returns ------- str Formatted text from input. \"\"\" text = text % dict ( prog = self . _prog ) if \"%(prog)\" in text else text text = self . _whitespace_matcher . sub ( \" \" , text ) . strip () return text + \" \\n\\n \" def _join_parts ( self , part_strings ): \"\"\" Combine different sections of the help message. Parameters ---------- part_strings : list List of argument help messages and headers. Returns ------- str Fully formatted help message for CLI. \"\"\" parts = self . format_headers ( part_strings ) return super () . _join_parts ( parts ) @staticmethod def format_headers ( parts ): \"\"\" Format help message section headers. Parameters ---------- parts : list List of individual lines for help message. Returns ------- list Input list with formatted section headers. \"\"\" if parts and parts [ 0 ] . startswith ( \"usage:\" ): parts [ 0 ] = \"Usage \\n ===== \\n \" + parts [ 0 ][ 6 :] headings = [ i for i in range ( len ( parts )) if parts [ i ] . endswith ( \": \\n \" )] for i in headings [:: - 1 ]: parts [ i ] = parts [ i ][: - 2 ] . title () underline = \"\" . join ([ \" \\n \" , \"-\" * len ( parts [ i ]), \" \\n \" ]) parts . insert ( i + 1 , underline ) return parts __init__ ( prog , width = 45 , max_help_positions = 45 ) \u00a4 Construct HelpFormat class for usage output. Parameters \u00a4 str Name of the program. int Max width of help message output. int max length until line wrap. Source code in torrentfile\\cli.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def __init__ ( self , prog , width = 45 , max_help_positions = 45 ): \"\"\" Construct HelpFormat class for usage output. Parameters ---------- prog : str Name of the program. width : int Max width of help message output. max_help_positions : int max length until line wrap. \"\"\" super () . __init__ ( prog , width = width , max_help_position = max_help_positions ) _format_text ( text ) \u00a4 Format text for cli usage messages. Parameters \u00a4 str Pre-formatted text. Returns \u00a4 str Formatted text from input. Source code in torrentfile\\cli.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def _format_text ( self , text ): \"\"\" Format text for cli usage messages. Parameters ---------- text : str Pre-formatted text. Returns ------- str Formatted text from input. \"\"\" text = text % dict ( prog = self . _prog ) if \"%(prog)\" in text else text text = self . _whitespace_matcher . sub ( \" \" , text ) . strip () return text + \" \\n\\n \" _join_parts ( part_strings ) \u00a4 Combine different sections of the help message. Parameters \u00a4 list List of argument help messages and headers. Returns \u00a4 str Fully formatted help message for CLI. Source code in torrentfile\\cli.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def _join_parts ( self , part_strings ): \"\"\" Combine different sections of the help message. Parameters ---------- part_strings : list List of argument help messages and headers. Returns ------- str Fully formatted help message for CLI. \"\"\" parts = self . format_headers ( part_strings ) return super () . _join_parts ( parts ) _split_lines ( text , _ ) \u00a4 Split multiline help messages and remove indentation. Parameters \u00a4 str text that needs to be split int max width for line. Source code in torrentfile\\cli.py 105 106 107 108 109 110 111 112 113 114 115 116 117 def _split_lines ( self , text , _ ): \"\"\" Split multiline help messages and remove indentation. Parameters ---------- text : str text that needs to be split _ : int max width for line. \"\"\" lines = text . split ( \" \\n \" ) return [ line . strip () for line in lines if line ] format_headers ( parts ) staticmethod \u00a4 Format help message section headers. Parameters \u00a4 list List of individual lines for help message. Returns \u00a4 list Input list with formatted section headers. Source code in torrentfile\\cli.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 @staticmethod def format_headers ( parts ): \"\"\" Format help message section headers. Parameters ---------- parts : list List of individual lines for help message. Returns ------- list Input list with formatted section headers. \"\"\" if parts and parts [ 0 ] . startswith ( \"usage:\" ): parts [ 0 ] = \"Usage \\n ===== \\n \" + parts [ 0 ][ 6 :] headings = [ i for i in range ( len ( parts )) if parts [ i ] . endswith ( \": \\n \" )] for i in headings [:: - 1 ]: parts [ i ] = parts [ i ][: - 2 ] . title () underline = \"\" . join ([ \" \\n \" , \"-\" * len ( parts [ i ]), \" \\n \" ]) parts . insert ( i + 1 , underline ) return parts execute ( args = None ) \u00a4 Initialize Command Line Interface for torrentfile. Parameters \u00a4 list Commandline arguments. default=None Returns \u00a4 list Depends on what the command line args were. Source code in torrentfile\\cli.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 def execute ( args = None ) -> list : \"\"\" Initialize Command Line Interface for torrentfile. Parameters ---------- args : list Commandline arguments. default=None Returns ------- list Depends on what the command line args were. \"\"\" if not args : if sys . argv [ 1 :]: args = sys . argv [ 1 :] else : args = [ \"-h\" ] parser = ArgumentParser ( \"torrentfile\" , usage = \"torrentfile [options] command [command options]\" , description = ( \"Command line tools for creating, editing, checking, building \" \"and interacting with Bittorrent metainfo files\" ), prefix_chars = \"-\" , formatter_class = TorrentFileHelpFormatter , conflict_handler = \"resolve\" , ) parser . add_argument ( \"-i\" , \"--interactive\" , action = \"store_true\" , dest = \"interactive\" , help = \"select program options interactively\" , ) parser . add_argument ( \"-q\" , \"--quiet\" , help = \"Turn off all text output.\" , dest = \"quiet\" , action = \"store_true\" , ) parser . add_argument ( \"-V\" , \"--version\" , action = \"version\" , version = f \"torrentfile v { version } \" , help = \"show program version and exit\" , ) parser . add_argument ( \"-v\" , \"--verbose\" , action = \"store_true\" , dest = \"debug\" , help = \"output debug information\" , ) parser . set_defaults ( func = parser . print_help ) subparsers = parser . add_subparsers ( title = \"Commands\" , dest = \"command\" , metavar = \"create, edit, info, magnet, recheck, rebuild \\n \" , ) create_parser = subparsers . add_parser ( \"create\" , help = \"\"\"Generate a new torrent meta file.\"\"\" , prefix_chars = \"-\" , aliases = [ \"c\" , \"new\" ], formatter_class = TorrentFileHelpFormatter , ) create_parser . add_argument ( \"-a\" , \"-t\" , \"--announce\" , \"--tracker\" , action = \"store\" , dest = \"announce\" , metavar = \"<url>\" , nargs = \"+\" , default = [], help = \"One or more space-seperated torrent tracker url(s).\" , ) create_parser . add_argument ( \"-p\" , \"--private\" , action = \"store_true\" , dest = \"private\" , help = \"Creates private torrent with multi-tracker and DHT turned off.\" , ) create_parser . add_argument ( \"-s\" , \"--source\" , action = \"store\" , dest = \"source\" , metavar = \"<source>\" , help = \"Add a source string. Useful for cross-seeding.\" , ) create_parser . add_argument ( \"-m\" , \"--magnet\" , action = \"store_true\" , dest = \"magnet\" , ) create_parser . add_argument ( \"-c\" , \"--comment\" , action = \"store\" , dest = \"comment\" , metavar = \"<comment>\" , help = \"Include a comment in file metadata\" , ) create_parser . add_argument ( \"-o\" , \"--out\" , action = \"store\" , dest = \"outfile\" , metavar = \"<path>\" , help = \"Output save path for created .torrent file\" , ) create_parser . add_argument ( \"--cwd\" , \"--current\" , action = \"store_true\" , dest = \"cwd\" , help = \"*deprecated* Saving to current directory is default behaviour\" , ) create_parser . add_argument ( \"--prog\" , \"--progress\" , default = \"1\" , action = \"store\" , dest = \"progress\" , help = \"\"\" Set the progress bar level. Options = 0, 1 (0) = Do not display progress bar. (1) = Display progress bar.(default) \"\"\" , ) create_parser . add_argument ( \"--meta-version\" , default = \"1\" , choices = [ \"1\" , \"2\" , \"3\" ], action = \"store\" , dest = \"meta_version\" , metavar = \"<int>\" , help = \"\"\" Bittorrent metafile version. Options = 1, 2, 3 (1) = Bittorrent v1 (Default) (2) = Bittorrent v2 (3) = Bittorrent v1 & v2 hybrid \"\"\" , ) create_parser . add_argument ( \"--piece-length\" , action = \"store\" , dest = \"piece_length\" , metavar = \"<int>\" , help = \"\"\" (Default: <blank>) Number of bytes for per chunk of data transmitted by Bittorrent client. Acceptable values include integers 14-26 which will be interpreted as a perfect power of 2. e.g. 14 = 16KiB pieces. Examples:: [--piece-length 14] [--piece-length 20] \"\"\" , ) create_parser . add_argument ( \"-w\" , \"--web-seed\" , action = \"store\" , dest = \"url_list\" , metavar = \"<url>\" , nargs = \"+\" , help = \"list of web addresses where torrent data exists (GetRight).\" , ) create_parser . add_argument ( \"--http-seed\" , action = \"store\" , dest = \"httpseeds\" , metavar = \"<url>\" , nargs = \"+\" , help = \"list of URLs, addresses where content can be found (Hoffman).\" , ) create_parser . add_argument ( \"content\" , action = \"store\" , metavar = \"<content>\" , nargs = \"?\" , help = \"Path to content file or directory\" , ) create_parser . set_defaults ( func = create ) edit_parser = subparsers . add_parser ( \"edit\" , help = \"\"\"Edit existing torrent meta file.\"\"\" , aliases = [ \"e\" ], prefix_chars = \"-\" , formatter_class = TorrentFileHelpFormatter , ) edit_parser . add_argument ( \"metafile\" , action = \"store\" , help = \"path to *.torrent file\" , metavar = \"<*.torrent>\" , ) edit_parser . add_argument ( \"--tracker\" , action = \"store\" , dest = \"announce\" , metavar = \"<url>\" , nargs = \"+\" , help = \"\"\" Replace current list of tracker/announce urls with one or more space seperated Bittorrent tracker announce url(s). \"\"\" , ) edit_parser . add_argument ( \"--web-seed\" , action = \"store\" , dest = \"url_list\" , metavar = \"<url>\" , nargs = \"+\" , help = \"Replace current list of web-seed urls with one or more url(s)\" , ) edit_parser . add_argument ( \"--http-seed\" , action = \"store\" , dest = \"httpseeds\" , metavar = \"<url>\" , nargs = \"+\" , help = \"replace all currently listed addresses with new list (Hoffman).\" , ) edit_parser . add_argument ( \"--private\" , action = \"store_true\" , help = \"Make torrent private.\" , dest = \"private\" , ) edit_parser . add_argument ( \"--comment\" , help = \"Replaces any existing comment with <comment>\" , metavar = \"<comment>\" , dest = \"comment\" , action = \"store\" , ) edit_parser . add_argument ( \"--source\" , action = \"store\" , dest = \"source\" , metavar = \"<source>\" , help = \"Replaces current source with <source>\" , ) edit_parser . set_defaults ( func = edit ) info_parser = subparsers . add_parser ( \"info\" , help = \"Show detailed information about a torrent file.\" , aliases = [ \"i\" ], prefix_chars = \"-\" , formatter_class = TorrentFileHelpFormatter , ) info_parser . add_argument ( \"metafile\" , action = \"store\" , metavar = \"<*.torrent>\" , help = \"path to pre-existing torrent file.\" , ) info_parser . set_defaults ( func = info ) magnet_parser = subparsers . add_parser ( \"magnet\" , help = \"Generate magnet url from an existing Bittorrent meta file.\" , aliases = [ \"m\" ], prefix_chars = \"-\" , formatter_class = TorrentFileHelpFormatter , ) magnet_parser . add_argument ( \"metafile\" , action = \"store\" , help = \"Path to Bittorrent meta file.\" , metavar = \"<*.torrent>\" , ) magnet_parser . set_defaults ( func = magnet ) check_parser = subparsers . add_parser ( \"recheck\" , help = \"Gives a detailed look at how much of the torrent is available.\" , aliases = [ \"check\" ], prefix_chars = \"-\" , formatter_class = TorrentFileHelpFormatter , ) check_parser . add_argument ( \"metafile\" , action = \"store\" , metavar = \"<*.torrent>\" , help = \"path to .torrent file.\" , ) check_parser . add_argument ( \"content\" , action = \"store\" , metavar = \"<content>\" , help = \"path to content file or directory\" , ) check_parser . set_defaults ( func = recheck ) rebuild_parser = subparsers . add_parser ( \"rebuild\" , aliases = [ \"build\" ], help = \"\"\"Re-assemble files obtained from a bittorrent file into the appropriate file structure for re-seeding. Read documentation for more information, or use cases.\"\"\" , formatter_class = TorrentFileHelpFormatter , ) rebuild_parser . add_argument ( \"metafiles\" , action = \"store\" , metavar = \"<*.torrent>\" , help = \"path to .torrent file. or directory containing .torrent files\" , ) rebuild_parser . add_argument ( \"contents\" , action = \"store\" , metavar = \"<contents>\" , help = \"directory that contains some or all of the torrents contents\" , ) rebuild_parser . add_argument ( \"destination\" , action = \"store\" , metavar = \"<destination>\" , help = \"path to where torrents will be re-assembled\" , ) rebuild_parser . set_defaults ( func = rebuild ) args = parser . parse_args ( args ) if args . quiet : Config . activate_quiet () elif args . debug : Config . activate_logger () if args . interactive : return select_action () if hasattr ( args , \"func\" ): return args . func ( args ) return args # pragma: nocover main () \u00a4 Initiate main function for CLI script. Source code in torrentfile\\cli.py 534 535 536 537 538 def main (): \"\"\" Initiate main function for CLI script. \"\"\" execute ()","title":"CLI"},{"location":"cli/#torrentfile.cli.Config","text":"Class the controls the logging configuration and output settings. Controls the logging level, or whether to app should operate in quiet mode. Source code in torrentfile\\cli.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class Config : \"\"\" Class the controls the logging configuration and output settings. Controls the logging level, or whether to app should operate in quiet mode. \"\"\" @staticmethod def activate_quiet (): \"\"\" Activate quiet mode for the duration of the programs life. When quiet mode is enabled, no logging, progress or state information is output to the terminal \"\"\" if sys . stdout or sys . stderr : sys . stdout = io . StringIO () sys . stderr = io . StringIO () @staticmethod def activate_logger (): \"\"\" Activate the builtin logging mechanism when passed debug flag from CLI. \"\"\" logging . basicConfig ( level = logging . INFO ) logger = logging . getLogger () console_handler = logging . StreamHandler ( stream = sys . stderr ) stream_formatter = logging . Formatter ( \" %(asctime)s %(levelno)s %(message)s \" , datefmt = \"%m- %d %H:%M:%S\" , style = \"%\" , ) console_handler . setFormatter ( stream_formatter ) console_handler . setLevel ( logging . DEBUG ) logger . setLevel ( logging . DEBUG ) logger . addHandler ( console_handler ) logger . debug ( \"Debug: ON\" )","title":"Config"},{"location":"cli/#torrentfile.cli.Config.activate_logger","text":"Activate the builtin logging mechanism when passed debug flag from CLI. Source code in torrentfile\\cli.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 @staticmethod def activate_logger (): \"\"\" Activate the builtin logging mechanism when passed debug flag from CLI. \"\"\" logging . basicConfig ( level = logging . INFO ) logger = logging . getLogger () console_handler = logging . StreamHandler ( stream = sys . stderr ) stream_formatter = logging . Formatter ( \" %(asctime)s %(levelno)s %(message)s \" , datefmt = \"%m- %d %H:%M:%S\" , style = \"%\" , ) console_handler . setFormatter ( stream_formatter ) console_handler . setLevel ( logging . DEBUG ) logger . setLevel ( logging . DEBUG ) logger . addHandler ( console_handler ) logger . debug ( \"Debug: ON\" )","title":"activate_logger()"},{"location":"cli/#torrentfile.cli.Config.activate_quiet","text":"Activate quiet mode for the duration of the programs life. When quiet mode is enabled, no logging, progress or state information is output to the terminal Source code in torrentfile\\cli.py 48 49 50 51 52 53 54 55 56 57 58 @staticmethod def activate_quiet (): \"\"\" Activate quiet mode for the duration of the programs life. When quiet mode is enabled, no logging, progress or state information is output to the terminal \"\"\" if sys . stdout or sys . stderr : sys . stdout = io . StringIO () sys . stderr = io . StringIO ()","title":"activate_quiet()"},{"location":"cli/#torrentfile.cli.TorrentFileHelpFormatter","text":"Bases: HelpFormatter Formatting class for help tips provided by the CLI. Subclasses Argparse.HelpFormatter. Source code in torrentfile\\cli.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 class TorrentFileHelpFormatter ( HelpFormatter ): \"\"\" Formatting class for help tips provided by the CLI. Subclasses Argparse.HelpFormatter. \"\"\" def __init__ ( self , prog , width = 45 , max_help_positions = 45 ): \"\"\" Construct HelpFormat class for usage output. Parameters ---------- prog : str Name of the program. width : int Max width of help message output. max_help_positions : int max length until line wrap. \"\"\" super () . __init__ ( prog , width = width , max_help_position = max_help_positions ) def _split_lines ( self , text , _ ): \"\"\" Split multiline help messages and remove indentation. Parameters ---------- text : str text that needs to be split _ : int max width for line. \"\"\" lines = text . split ( \" \\n \" ) return [ line . strip () for line in lines if line ] def _format_text ( self , text ): \"\"\" Format text for cli usage messages. Parameters ---------- text : str Pre-formatted text. Returns ------- str Formatted text from input. \"\"\" text = text % dict ( prog = self . _prog ) if \"%(prog)\" in text else text text = self . _whitespace_matcher . sub ( \" \" , text ) . strip () return text + \" \\n\\n \" def _join_parts ( self , part_strings ): \"\"\" Combine different sections of the help message. Parameters ---------- part_strings : list List of argument help messages and headers. Returns ------- str Fully formatted help message for CLI. \"\"\" parts = self . format_headers ( part_strings ) return super () . _join_parts ( parts ) @staticmethod def format_headers ( parts ): \"\"\" Format help message section headers. Parameters ---------- parts : list List of individual lines for help message. Returns ------- list Input list with formatted section headers. \"\"\" if parts and parts [ 0 ] . startswith ( \"usage:\" ): parts [ 0 ] = \"Usage \\n ===== \\n \" + parts [ 0 ][ 6 :] headings = [ i for i in range ( len ( parts )) if parts [ i ] . endswith ( \": \\n \" )] for i in headings [:: - 1 ]: parts [ i ] = parts [ i ][: - 2 ] . title () underline = \"\" . join ([ \" \\n \" , \"-\" * len ( parts [ i ]), \" \\n \" ]) parts . insert ( i + 1 , underline ) return parts","title":"TorrentFileHelpFormatter"},{"location":"cli/#torrentfile.cli.TorrentFileHelpFormatter.__init__","text":"Construct HelpFormat class for usage output.","title":"__init__()"},{"location":"cli/#torrentfile.cli.TorrentFileHelpFormatter.__init__--parameters","text":"str Name of the program. int Max width of help message output. int max length until line wrap. Source code in torrentfile\\cli.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def __init__ ( self , prog , width = 45 , max_help_positions = 45 ): \"\"\" Construct HelpFormat class for usage output. Parameters ---------- prog : str Name of the program. width : int Max width of help message output. max_help_positions : int max length until line wrap. \"\"\" super () . __init__ ( prog , width = width , max_help_position = max_help_positions )","title":"Parameters"},{"location":"cli/#torrentfile.cli.TorrentFileHelpFormatter._format_text","text":"Format text for cli usage messages.","title":"_format_text()"},{"location":"cli/#torrentfile.cli.TorrentFileHelpFormatter._format_text--parameters","text":"str Pre-formatted text.","title":"Parameters"},{"location":"cli/#torrentfile.cli.TorrentFileHelpFormatter._format_text--returns","text":"str Formatted text from input. Source code in torrentfile\\cli.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def _format_text ( self , text ): \"\"\" Format text for cli usage messages. Parameters ---------- text : str Pre-formatted text. Returns ------- str Formatted text from input. \"\"\" text = text % dict ( prog = self . _prog ) if \"%(prog)\" in text else text text = self . _whitespace_matcher . sub ( \" \" , text ) . strip () return text + \" \\n\\n \"","title":"Returns"},{"location":"cli/#torrentfile.cli.TorrentFileHelpFormatter._join_parts","text":"Combine different sections of the help message.","title":"_join_parts()"},{"location":"cli/#torrentfile.cli.TorrentFileHelpFormatter._join_parts--parameters","text":"list List of argument help messages and headers.","title":"Parameters"},{"location":"cli/#torrentfile.cli.TorrentFileHelpFormatter._join_parts--returns","text":"str Fully formatted help message for CLI. Source code in torrentfile\\cli.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def _join_parts ( self , part_strings ): \"\"\" Combine different sections of the help message. Parameters ---------- part_strings : list List of argument help messages and headers. Returns ------- str Fully formatted help message for CLI. \"\"\" parts = self . format_headers ( part_strings ) return super () . _join_parts ( parts )","title":"Returns"},{"location":"cli/#torrentfile.cli.TorrentFileHelpFormatter._split_lines","text":"Split multiline help messages and remove indentation.","title":"_split_lines()"},{"location":"cli/#torrentfile.cli.TorrentFileHelpFormatter._split_lines--parameters","text":"str text that needs to be split int max width for line. Source code in torrentfile\\cli.py 105 106 107 108 109 110 111 112 113 114 115 116 117 def _split_lines ( self , text , _ ): \"\"\" Split multiline help messages and remove indentation. Parameters ---------- text : str text that needs to be split _ : int max width for line. \"\"\" lines = text . split ( \" \\n \" ) return [ line . strip () for line in lines if line ]","title":"Parameters"},{"location":"cli/#torrentfile.cli.TorrentFileHelpFormatter.format_headers","text":"Format help message section headers.","title":"format_headers()"},{"location":"cli/#torrentfile.cli.TorrentFileHelpFormatter.format_headers--parameters","text":"list List of individual lines for help message.","title":"Parameters"},{"location":"cli/#torrentfile.cli.TorrentFileHelpFormatter.format_headers--returns","text":"list Input list with formatted section headers. Source code in torrentfile\\cli.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 @staticmethod def format_headers ( parts ): \"\"\" Format help message section headers. Parameters ---------- parts : list List of individual lines for help message. Returns ------- list Input list with formatted section headers. \"\"\" if parts and parts [ 0 ] . startswith ( \"usage:\" ): parts [ 0 ] = \"Usage \\n ===== \\n \" + parts [ 0 ][ 6 :] headings = [ i for i in range ( len ( parts )) if parts [ i ] . endswith ( \": \\n \" )] for i in headings [:: - 1 ]: parts [ i ] = parts [ i ][: - 2 ] . title () underline = \"\" . join ([ \" \\n \" , \"-\" * len ( parts [ i ]), \" \\n \" ]) parts . insert ( i + 1 , underline ) return parts","title":"Returns"},{"location":"cli/#torrentfile.cli.execute","text":"Initialize Command Line Interface for torrentfile.","title":"execute()"},{"location":"cli/#torrentfile.cli.execute--parameters","text":"list Commandline arguments. default=None","title":"Parameters"},{"location":"cli/#torrentfile.cli.execute--returns","text":"list Depends on what the command line args were. Source code in torrentfile\\cli.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 def execute ( args = None ) -> list : \"\"\" Initialize Command Line Interface for torrentfile. Parameters ---------- args : list Commandline arguments. default=None Returns ------- list Depends on what the command line args were. \"\"\" if not args : if sys . argv [ 1 :]: args = sys . argv [ 1 :] else : args = [ \"-h\" ] parser = ArgumentParser ( \"torrentfile\" , usage = \"torrentfile [options] command [command options]\" , description = ( \"Command line tools for creating, editing, checking, building \" \"and interacting with Bittorrent metainfo files\" ), prefix_chars = \"-\" , formatter_class = TorrentFileHelpFormatter , conflict_handler = \"resolve\" , ) parser . add_argument ( \"-i\" , \"--interactive\" , action = \"store_true\" , dest = \"interactive\" , help = \"select program options interactively\" , ) parser . add_argument ( \"-q\" , \"--quiet\" , help = \"Turn off all text output.\" , dest = \"quiet\" , action = \"store_true\" , ) parser . add_argument ( \"-V\" , \"--version\" , action = \"version\" , version = f \"torrentfile v { version } \" , help = \"show program version and exit\" , ) parser . add_argument ( \"-v\" , \"--verbose\" , action = \"store_true\" , dest = \"debug\" , help = \"output debug information\" , ) parser . set_defaults ( func = parser . print_help ) subparsers = parser . add_subparsers ( title = \"Commands\" , dest = \"command\" , metavar = \"create, edit, info, magnet, recheck, rebuild \\n \" , ) create_parser = subparsers . add_parser ( \"create\" , help = \"\"\"Generate a new torrent meta file.\"\"\" , prefix_chars = \"-\" , aliases = [ \"c\" , \"new\" ], formatter_class = TorrentFileHelpFormatter , ) create_parser . add_argument ( \"-a\" , \"-t\" , \"--announce\" , \"--tracker\" , action = \"store\" , dest = \"announce\" , metavar = \"<url>\" , nargs = \"+\" , default = [], help = \"One or more space-seperated torrent tracker url(s).\" , ) create_parser . add_argument ( \"-p\" , \"--private\" , action = \"store_true\" , dest = \"private\" , help = \"Creates private torrent with multi-tracker and DHT turned off.\" , ) create_parser . add_argument ( \"-s\" , \"--source\" , action = \"store\" , dest = \"source\" , metavar = \"<source>\" , help = \"Add a source string. Useful for cross-seeding.\" , ) create_parser . add_argument ( \"-m\" , \"--magnet\" , action = \"store_true\" , dest = \"magnet\" , ) create_parser . add_argument ( \"-c\" , \"--comment\" , action = \"store\" , dest = \"comment\" , metavar = \"<comment>\" , help = \"Include a comment in file metadata\" , ) create_parser . add_argument ( \"-o\" , \"--out\" , action = \"store\" , dest = \"outfile\" , metavar = \"<path>\" , help = \"Output save path for created .torrent file\" , ) create_parser . add_argument ( \"--cwd\" , \"--current\" , action = \"store_true\" , dest = \"cwd\" , help = \"*deprecated* Saving to current directory is default behaviour\" , ) create_parser . add_argument ( \"--prog\" , \"--progress\" , default = \"1\" , action = \"store\" , dest = \"progress\" , help = \"\"\" Set the progress bar level. Options = 0, 1 (0) = Do not display progress bar. (1) = Display progress bar.(default) \"\"\" , ) create_parser . add_argument ( \"--meta-version\" , default = \"1\" , choices = [ \"1\" , \"2\" , \"3\" ], action = \"store\" , dest = \"meta_version\" , metavar = \"<int>\" , help = \"\"\" Bittorrent metafile version. Options = 1, 2, 3 (1) = Bittorrent v1 (Default) (2) = Bittorrent v2 (3) = Bittorrent v1 & v2 hybrid \"\"\" , ) create_parser . add_argument ( \"--piece-length\" , action = \"store\" , dest = \"piece_length\" , metavar = \"<int>\" , help = \"\"\" (Default: <blank>) Number of bytes for per chunk of data transmitted by Bittorrent client. Acceptable values include integers 14-26 which will be interpreted as a perfect power of 2. e.g. 14 = 16KiB pieces. Examples:: [--piece-length 14] [--piece-length 20] \"\"\" , ) create_parser . add_argument ( \"-w\" , \"--web-seed\" , action = \"store\" , dest = \"url_list\" , metavar = \"<url>\" , nargs = \"+\" , help = \"list of web addresses where torrent data exists (GetRight).\" , ) create_parser . add_argument ( \"--http-seed\" , action = \"store\" , dest = \"httpseeds\" , metavar = \"<url>\" , nargs = \"+\" , help = \"list of URLs, addresses where content can be found (Hoffman).\" , ) create_parser . add_argument ( \"content\" , action = \"store\" , metavar = \"<content>\" , nargs = \"?\" , help = \"Path to content file or directory\" , ) create_parser . set_defaults ( func = create ) edit_parser = subparsers . add_parser ( \"edit\" , help = \"\"\"Edit existing torrent meta file.\"\"\" , aliases = [ \"e\" ], prefix_chars = \"-\" , formatter_class = TorrentFileHelpFormatter , ) edit_parser . add_argument ( \"metafile\" , action = \"store\" , help = \"path to *.torrent file\" , metavar = \"<*.torrent>\" , ) edit_parser . add_argument ( \"--tracker\" , action = \"store\" , dest = \"announce\" , metavar = \"<url>\" , nargs = \"+\" , help = \"\"\" Replace current list of tracker/announce urls with one or more space seperated Bittorrent tracker announce url(s). \"\"\" , ) edit_parser . add_argument ( \"--web-seed\" , action = \"store\" , dest = \"url_list\" , metavar = \"<url>\" , nargs = \"+\" , help = \"Replace current list of web-seed urls with one or more url(s)\" , ) edit_parser . add_argument ( \"--http-seed\" , action = \"store\" , dest = \"httpseeds\" , metavar = \"<url>\" , nargs = \"+\" , help = \"replace all currently listed addresses with new list (Hoffman).\" , ) edit_parser . add_argument ( \"--private\" , action = \"store_true\" , help = \"Make torrent private.\" , dest = \"private\" , ) edit_parser . add_argument ( \"--comment\" , help = \"Replaces any existing comment with <comment>\" , metavar = \"<comment>\" , dest = \"comment\" , action = \"store\" , ) edit_parser . add_argument ( \"--source\" , action = \"store\" , dest = \"source\" , metavar = \"<source>\" , help = \"Replaces current source with <source>\" , ) edit_parser . set_defaults ( func = edit ) info_parser = subparsers . add_parser ( \"info\" , help = \"Show detailed information about a torrent file.\" , aliases = [ \"i\" ], prefix_chars = \"-\" , formatter_class = TorrentFileHelpFormatter , ) info_parser . add_argument ( \"metafile\" , action = \"store\" , metavar = \"<*.torrent>\" , help = \"path to pre-existing torrent file.\" , ) info_parser . set_defaults ( func = info ) magnet_parser = subparsers . add_parser ( \"magnet\" , help = \"Generate magnet url from an existing Bittorrent meta file.\" , aliases = [ \"m\" ], prefix_chars = \"-\" , formatter_class = TorrentFileHelpFormatter , ) magnet_parser . add_argument ( \"metafile\" , action = \"store\" , help = \"Path to Bittorrent meta file.\" , metavar = \"<*.torrent>\" , ) magnet_parser . set_defaults ( func = magnet ) check_parser = subparsers . add_parser ( \"recheck\" , help = \"Gives a detailed look at how much of the torrent is available.\" , aliases = [ \"check\" ], prefix_chars = \"-\" , formatter_class = TorrentFileHelpFormatter , ) check_parser . add_argument ( \"metafile\" , action = \"store\" , metavar = \"<*.torrent>\" , help = \"path to .torrent file.\" , ) check_parser . add_argument ( \"content\" , action = \"store\" , metavar = \"<content>\" , help = \"path to content file or directory\" , ) check_parser . set_defaults ( func = recheck ) rebuild_parser = subparsers . add_parser ( \"rebuild\" , aliases = [ \"build\" ], help = \"\"\"Re-assemble files obtained from a bittorrent file into the appropriate file structure for re-seeding. Read documentation for more information, or use cases.\"\"\" , formatter_class = TorrentFileHelpFormatter , ) rebuild_parser . add_argument ( \"metafiles\" , action = \"store\" , metavar = \"<*.torrent>\" , help = \"path to .torrent file. or directory containing .torrent files\" , ) rebuild_parser . add_argument ( \"contents\" , action = \"store\" , metavar = \"<contents>\" , help = \"directory that contains some or all of the torrents contents\" , ) rebuild_parser . add_argument ( \"destination\" , action = \"store\" , metavar = \"<destination>\" , help = \"path to where torrents will be re-assembled\" , ) rebuild_parser . set_defaults ( func = rebuild ) args = parser . parse_args ( args ) if args . quiet : Config . activate_quiet () elif args . debug : Config . activate_logger () if args . interactive : return select_action () if hasattr ( args , \"func\" ): return args . func ( args ) return args # pragma: nocover","title":"Returns"},{"location":"cli/#torrentfile.cli.main","text":"Initiate main function for CLI script. Source code in torrentfile\\cli.py 534 535 536 537 538 def main (): \"\"\" Initiate main function for CLI script. \"\"\" execute ()","title":"main()"},{"location":"commands/","text":"The commands module contains the Action Commands executed by the CLI script. Each function pertains to a command line action/subcommand and drives specific features of the application. Functions \u00a4 create_command info_command edit_command recheck_command magnet_command create ( args ) \u00a4 Execute the create CLI sub-command to create a new torrent metafile. Parameters \u00a4 Namespace positional and optional CLI arguments. Returns \u00a4 torrentfile.MetaFile object containing the path to created metafile and its contents. Source code in torrentfile\\commands.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def create ( args : Namespace ) -> Namespace : \"\"\" Execute the create CLI sub-command to create a new torrent metafile. Parameters ---------- args : Namespace positional and optional CLI arguments. Returns ------- torrentfile.MetaFile object containing the path to created metafile and its contents. \"\"\" kwargs = vars ( args ) logger . debug ( \"Creating torrent from %s \" , args . content ) if args . meta_version == \"1\" : torrent = TorrentFile ( ** kwargs ) else : torrent = TorrentAssembler ( ** kwargs ) outfile , meta = torrent . write () if args . magnet : magnet ( outfile ) args . torrent = torrent args . kwargs = kwargs args . outfile = outfile args . meta = meta print ( \" \\n Torrent Save Path: \" , os . path . abspath ( str ( outfile ))) logger . debug ( \"Output path: %s \" , str ( outfile )) return args edit ( args ) \u00a4 Execute the edit CLI sub-command with provided arguments. Provides functionality that can change the details of a torrentfile that preserves all of the hash piece information so as not to break the torrentfile. Parameters \u00a4 Namespace positional and optional CLI arguments. Returns \u00a4 str path to edited torrent file. Source code in torrentfile\\commands.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def edit ( args : Namespace ) -> str : \"\"\" Execute the edit CLI sub-command with provided arguments. Provides functionality that can change the details of a torrentfile that preserves all of the hash piece information so as not to break the torrentfile. Parameters ---------- args : Namespace positional and optional CLI arguments. Returns ------- str path to edited torrent file. \"\"\" metafile = args . metafile logger . info ( \"Editing %s Meta File\" , str ( args . metafile )) editargs = { \"url-list\" : args . url_list , \"httpseeds\" : args . httpseeds , \"announce\" : args . announce , \"source\" : args . source , \"private\" : args . private , \"comment\" : args . comment , } return edit_torrent ( metafile , editargs ) info ( args ) \u00a4 Show torrent metafile details to user via stdout. Prints full details of torrent file contents to the terminal in a clean and readable format. Parameters \u00a4 dict command line arguements provided by the user. Returns \u00a4 str The output printed to the terminal. Source code in torrentfile\\commands.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def info ( args : Namespace ) -> str : \"\"\" Show torrent metafile details to user via stdout. Prints full details of torrent file contents to the terminal in a clean and readable format. Parameters ---------- args : dict command line arguements provided by the user. Returns ------- str The output printed to the terminal. \"\"\" metafile = args . metafile meta = pyben . load ( metafile ) data = meta [ \"info\" ] del meta [ \"info\" ] meta . update ( data ) if \"private\" in meta and meta [ \"private\" ] == 1 : meta [ \"private\" ] = \"True\" if \"announce-list\" in meta : lst = meta [ \"announce-list\" ] meta [ \"announce-list\" ] = \", \" . join ([ j for i in lst for j in i ]) if \"url-list\" in meta : meta [ \"url-list\" ] = \", \" . join ( meta [ \"url-list\" ]) if \"httpseeds\" in meta : meta [ \"httpseeds\" ] = \", \" . join ( meta [ \"httpseeds\" ]) text = [] longest = max ( len ( i ) for i in meta . keys ()) for key , val in meta . items (): if key not in [ \"pieces\" , \"piece layers\" , \"files\" , \"file tree\" ]: prefix = longest - len ( key ) + 1 string = key + ( \" \" * prefix ) + str ( val ) text . append ( string ) most = max ( len ( i ) for i in text ) text = [ \"-\" * most , \" \\n \" ] + text + [ \" \\n \" , \"-\" * most ] output = \" \\n \" . join ( text ) print ( output ) return output magnet ( metafile ) \u00a4 Create a magnet URI from a Bittorrent meta file. Parameters \u00a4 (Namespace||str) Namespace class for CLI arguments. Returns \u00a4 str created magnet URI. Source code in torrentfile\\commands.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def magnet ( metafile : Namespace ) -> str : \"\"\" Create a magnet URI from a Bittorrent meta file. Parameters ---------- metafile : (Namespace||str) Namespace class for CLI arguments. Returns ------- str created magnet URI. \"\"\" if hasattr ( metafile , \"metafile\" ): metafile = metafile . metafile if not os . path . exists ( metafile ): raise FileNotFoundError meta = pyben . load ( metafile ) data = meta [ \"info\" ] binfo = pyben . dumps ( data ) infohash = sha1 ( binfo ) . hexdigest () . upper () # nosec logger . info ( \"Magnet Info Hash: %s \" , infohash ) scheme = \"magnet:\" hasharg = \"?xt=urn:btih:\" + infohash namearg = \"&dn=\" + quote_plus ( data [ \"name\" ]) if \"announce-list\" in meta : announce_args = [ \"&tr=\" + quote_plus ( url ) for urllist in meta [ \"announce-list\" ] for url in urllist ] else : announce_args = [ \"&tr=\" + quote_plus ( meta [ \"announce\" ])] full_uri = \"\" . join ([ scheme , hasharg , namearg ] + announce_args ) logger . info ( \"Created Magnet URI %s \" , full_uri ) sys . stdout . write ( \" \\n \" + full_uri + \" \\n \" ) return full_uri rebuild ( args ) \u00a4 Attempt to rebuild a torrent based on the a torrent file. Recusively look through a directory for files that belong in a given torrent file, and rebuild as much of the torrent file as possible. Parameters \u00a4 Namespace Command line arguments including the paths neccessary Returns \u00a4 int Total number of content files copied to the rebuild directory. Source code in torrentfile\\commands.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 def rebuild ( args : Namespace ) -> int : \"\"\" Attempt to rebuild a torrent based on the a torrent file. Recusively look through a directory for files that belong in a given torrent file, and rebuild as much of the torrent file as possible. Parameters ---------- args : Namespace Command line arguments including the paths neccessary Returns ------- int Total number of content files copied to the rebuild directory. \"\"\" metafiles = args . metafiles dest = args . destination contents = args . contents for path in [ metafiles , dest , contents ]: if not os . path . exists ( path ): raise FileNotFoundError ( path ) assembler = Assembler ( metafiles , contents , dest ) return assembler . rebuild () recheck ( args ) \u00a4 Execute recheck CLI sub-command. Checks the piece hashes within a pre-existing torrent file and does a piece by piece check with the contents of a file or directory for completeness and validation. Parameters \u00a4 Namespace positional and optional arguments. Returns \u00a4 str The percentage of content currently saved to disk. Source code in torrentfile\\commands.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def recheck ( args : Namespace ) -> str : \"\"\" Execute recheck CLI sub-command. Checks the piece hashes within a pre-existing torrent file and does a piece by piece check with the contents of a file or directory for completeness and validation. Parameters ---------- args : Namespace positional and optional arguments. Returns ------- str The percentage of content currently saved to disk. \"\"\" metafile = args . metafile content = args . content if os . path . isdir ( metafile ): raise ArgumentError ( f \"Error: Unable to parse directory { metafile } . \" \"Check the order of the parameters.\" ) logger . debug ( \"Validating %s <---------------> %s contents\" , metafile , content ) msg = f \"Rechecking { metafile } ... \\n \" halfterm = shutil . get_terminal_size () . columns / 2 padding = int ( halfterm - ( len ( msg ) / 2 )) * \" \" sys . stdout . write ( padding + msg ) checker = Checker ( metafile , content ) logger . debug ( \"Completed initialization of the Checker class\" ) result = checker . results () message = f \" { content } <- { result } % -> { metafile } \" padding = int ( halfterm - ( len ( message ) / 2 )) * \" \" sys . stdout . write ( padding + message + \" \\n \" ) sys . stdout . flush () return result","title":"commands"},{"location":"commands/#torrentfile.commands--functions","text":"create_command info_command edit_command recheck_command magnet_command","title":"Functions"},{"location":"commands/#torrentfile.commands.create","text":"Execute the create CLI sub-command to create a new torrent metafile.","title":"create()"},{"location":"commands/#torrentfile.commands.create--parameters","text":"Namespace positional and optional CLI arguments.","title":"Parameters"},{"location":"commands/#torrentfile.commands.create--returns","text":"torrentfile.MetaFile object containing the path to created metafile and its contents. Source code in torrentfile\\commands.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def create ( args : Namespace ) -> Namespace : \"\"\" Execute the create CLI sub-command to create a new torrent metafile. Parameters ---------- args : Namespace positional and optional CLI arguments. Returns ------- torrentfile.MetaFile object containing the path to created metafile and its contents. \"\"\" kwargs = vars ( args ) logger . debug ( \"Creating torrent from %s \" , args . content ) if args . meta_version == \"1\" : torrent = TorrentFile ( ** kwargs ) else : torrent = TorrentAssembler ( ** kwargs ) outfile , meta = torrent . write () if args . magnet : magnet ( outfile ) args . torrent = torrent args . kwargs = kwargs args . outfile = outfile args . meta = meta print ( \" \\n Torrent Save Path: \" , os . path . abspath ( str ( outfile ))) logger . debug ( \"Output path: %s \" , str ( outfile )) return args","title":"Returns"},{"location":"commands/#torrentfile.commands.edit","text":"Execute the edit CLI sub-command with provided arguments. Provides functionality that can change the details of a torrentfile that preserves all of the hash piece information so as not to break the torrentfile.","title":"edit()"},{"location":"commands/#torrentfile.commands.edit--parameters","text":"Namespace positional and optional CLI arguments.","title":"Parameters"},{"location":"commands/#torrentfile.commands.edit--returns","text":"str path to edited torrent file. Source code in torrentfile\\commands.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def edit ( args : Namespace ) -> str : \"\"\" Execute the edit CLI sub-command with provided arguments. Provides functionality that can change the details of a torrentfile that preserves all of the hash piece information so as not to break the torrentfile. Parameters ---------- args : Namespace positional and optional CLI arguments. Returns ------- str path to edited torrent file. \"\"\" metafile = args . metafile logger . info ( \"Editing %s Meta File\" , str ( args . metafile )) editargs = { \"url-list\" : args . url_list , \"httpseeds\" : args . httpseeds , \"announce\" : args . announce , \"source\" : args . source , \"private\" : args . private , \"comment\" : args . comment , } return edit_torrent ( metafile , editargs )","title":"Returns"},{"location":"commands/#torrentfile.commands.info","text":"Show torrent metafile details to user via stdout. Prints full details of torrent file contents to the terminal in a clean and readable format.","title":"info()"},{"location":"commands/#torrentfile.commands.info--parameters","text":"dict command line arguements provided by the user.","title":"Parameters"},{"location":"commands/#torrentfile.commands.info--returns","text":"str The output printed to the terminal. Source code in torrentfile\\commands.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def info ( args : Namespace ) -> str : \"\"\" Show torrent metafile details to user via stdout. Prints full details of torrent file contents to the terminal in a clean and readable format. Parameters ---------- args : dict command line arguements provided by the user. Returns ------- str The output printed to the terminal. \"\"\" metafile = args . metafile meta = pyben . load ( metafile ) data = meta [ \"info\" ] del meta [ \"info\" ] meta . update ( data ) if \"private\" in meta and meta [ \"private\" ] == 1 : meta [ \"private\" ] = \"True\" if \"announce-list\" in meta : lst = meta [ \"announce-list\" ] meta [ \"announce-list\" ] = \", \" . join ([ j for i in lst for j in i ]) if \"url-list\" in meta : meta [ \"url-list\" ] = \", \" . join ( meta [ \"url-list\" ]) if \"httpseeds\" in meta : meta [ \"httpseeds\" ] = \", \" . join ( meta [ \"httpseeds\" ]) text = [] longest = max ( len ( i ) for i in meta . keys ()) for key , val in meta . items (): if key not in [ \"pieces\" , \"piece layers\" , \"files\" , \"file tree\" ]: prefix = longest - len ( key ) + 1 string = key + ( \" \" * prefix ) + str ( val ) text . append ( string ) most = max ( len ( i ) for i in text ) text = [ \"-\" * most , \" \\n \" ] + text + [ \" \\n \" , \"-\" * most ] output = \" \\n \" . join ( text ) print ( output ) return output","title":"Returns"},{"location":"commands/#torrentfile.commands.magnet","text":"Create a magnet URI from a Bittorrent meta file.","title":"magnet()"},{"location":"commands/#torrentfile.commands.magnet--parameters","text":"(Namespace||str) Namespace class for CLI arguments.","title":"Parameters"},{"location":"commands/#torrentfile.commands.magnet--returns","text":"str created magnet URI. Source code in torrentfile\\commands.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def magnet ( metafile : Namespace ) -> str : \"\"\" Create a magnet URI from a Bittorrent meta file. Parameters ---------- metafile : (Namespace||str) Namespace class for CLI arguments. Returns ------- str created magnet URI. \"\"\" if hasattr ( metafile , \"metafile\" ): metafile = metafile . metafile if not os . path . exists ( metafile ): raise FileNotFoundError meta = pyben . load ( metafile ) data = meta [ \"info\" ] binfo = pyben . dumps ( data ) infohash = sha1 ( binfo ) . hexdigest () . upper () # nosec logger . info ( \"Magnet Info Hash: %s \" , infohash ) scheme = \"magnet:\" hasharg = \"?xt=urn:btih:\" + infohash namearg = \"&dn=\" + quote_plus ( data [ \"name\" ]) if \"announce-list\" in meta : announce_args = [ \"&tr=\" + quote_plus ( url ) for urllist in meta [ \"announce-list\" ] for url in urllist ] else : announce_args = [ \"&tr=\" + quote_plus ( meta [ \"announce\" ])] full_uri = \"\" . join ([ scheme , hasharg , namearg ] + announce_args ) logger . info ( \"Created Magnet URI %s \" , full_uri ) sys . stdout . write ( \" \\n \" + full_uri + \" \\n \" ) return full_uri","title":"Returns"},{"location":"commands/#torrentfile.commands.rebuild","text":"Attempt to rebuild a torrent based on the a torrent file. Recusively look through a directory for files that belong in a given torrent file, and rebuild as much of the torrent file as possible.","title":"rebuild()"},{"location":"commands/#torrentfile.commands.rebuild--parameters","text":"Namespace Command line arguments including the paths neccessary","title":"Parameters"},{"location":"commands/#torrentfile.commands.rebuild--returns","text":"int Total number of content files copied to the rebuild directory. Source code in torrentfile\\commands.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 def rebuild ( args : Namespace ) -> int : \"\"\" Attempt to rebuild a torrent based on the a torrent file. Recusively look through a directory for files that belong in a given torrent file, and rebuild as much of the torrent file as possible. Parameters ---------- args : Namespace Command line arguments including the paths neccessary Returns ------- int Total number of content files copied to the rebuild directory. \"\"\" metafiles = args . metafiles dest = args . destination contents = args . contents for path in [ metafiles , dest , contents ]: if not os . path . exists ( path ): raise FileNotFoundError ( path ) assembler = Assembler ( metafiles , contents , dest ) return assembler . rebuild ()","title":"Returns"},{"location":"commands/#torrentfile.commands.recheck","text":"Execute recheck CLI sub-command. Checks the piece hashes within a pre-existing torrent file and does a piece by piece check with the contents of a file or directory for completeness and validation.","title":"recheck()"},{"location":"commands/#torrentfile.commands.recheck--parameters","text":"Namespace positional and optional arguments.","title":"Parameters"},{"location":"commands/#torrentfile.commands.recheck--returns","text":"str The percentage of content currently saved to disk. Source code in torrentfile\\commands.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def recheck ( args : Namespace ) -> str : \"\"\" Execute recheck CLI sub-command. Checks the piece hashes within a pre-existing torrent file and does a piece by piece check with the contents of a file or directory for completeness and validation. Parameters ---------- args : Namespace positional and optional arguments. Returns ------- str The percentage of content currently saved to disk. \"\"\" metafile = args . metafile content = args . content if os . path . isdir ( metafile ): raise ArgumentError ( f \"Error: Unable to parse directory { metafile } . \" \"Check the order of the parameters.\" ) logger . debug ( \"Validating %s <---------------> %s contents\" , metafile , content ) msg = f \"Rechecking { metafile } ... \\n \" halfterm = shutil . get_terminal_size () . columns / 2 padding = int ( halfterm - ( len ( msg ) / 2 )) * \" \" sys . stdout . write ( padding + msg ) checker = Checker ( metafile , content ) logger . debug ( \"Completed initialization of the Checker class\" ) result = checker . results () message = f \" { content } <- { result } % -> { metafile } \" padding = int ( halfterm - ( len ( message ) / 2 )) * \" \" sys . stdout . write ( padding + message + \" \\n \" ) sys . stdout . flush () return result","title":"Returns"},{"location":"edit/","text":"Edit torrent module. Provides a facility by which certain properties of a torrent meta file can be edited by the user. The various command line arguments indicate which fields should be edited, and what the new value should be. Depending on what fields are chosen to edit, this command can trigger a new info hash which means the torrent will no longer be able to participate in the same swarm as the original unedited torrent. Keywords \u00a4 private comment source trackers web-seeds edit_torrent ( metafile , args ) \u00a4 Edit the properties and values in a torrent meta file. Parameters \u00a4 str path to the torrent meta file. dict key value pairs of the properties to be edited. Returns \u00a4 dict The edited and nested Meta and info dictionaries. Source code in torrentfile\\edit.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def edit_torrent ( metafile : str , args : dict ) -> dict : \"\"\" Edit the properties and values in a torrent meta file. Parameters ---------- metafile : str path to the torrent meta file. args : dict key value pairs of the properties to be edited. Returns ------- dict The edited and nested Meta and info dictionaries. \"\"\" logger . debug ( \"editing torrent file %s \" , metafile ) meta = pyben . load ( metafile ) info = meta [ \"info\" ] filter_empty ( args , meta , info ) if \"comment\" in args : info [ \"comment\" ] = args [ \"comment\" ] if \"source\" in args : info [ \"source\" ] = args [ \"source\" ] if \"private\" in args : info [ \"private\" ] = 1 if \"announce\" in args : val = args . get ( \"announce\" , None ) if isinstance ( val , str ): vallist = val . split () meta [ \"announce\" ] = vallist [ 0 ] meta [ \"announce-list\" ] = [ vallist ] elif isinstance ( val , list ): meta [ \"announce\" ] = val [ 0 ] meta [ \"announce-list\" ] = [ val ] if \"url-list\" in args : val = args . get ( \"url-list\" ) if isinstance ( val , str ): meta [ \"url-list\" ] = val . split () elif isinstance ( val , list ): meta [ \"url-list\" ] = val if \"httpseeds\" in args : val = args . get ( \"httpseeds\" ) if isinstance ( val , str ): meta [ \"httpseeds\" ] = val . split () elif isinstance ( val , list ): meta [ \"httpseeds\" ] = val meta [ \"info\" ] = info os . remove ( metafile ) pyben . dump ( meta , metafile ) return meta filter_empty ( args , meta , info ) \u00a4 Remove dictionary keys with empty values. Parameters \u00a4 dict Editable metafile properties from user. dict Metafile data dictionary. dict Metafile info dictionary. Source code in torrentfile\\edit.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def filter_empty ( args : dict , meta : dict , info : dict ): \"\"\" Remove dictionary keys with empty values. Parameters ---------- args : dict Editable metafile properties from user. meta : dict Metafile data dictionary. info : dict Metafile info dictionary. \"\"\" for key , val in list ( args . items ()): if val is None : del args [ key ] continue if val == \"\" : if key in meta : del meta [ key ] elif key in info : del info [ key ] del args [ key ] logger . debug ( \"removeing empty fields %s \" , val )","title":"edit"},{"location":"edit/#torrentfile.edit--keywords","text":"private comment source trackers web-seeds","title":"Keywords"},{"location":"edit/#torrentfile.edit.edit_torrent","text":"Edit the properties and values in a torrent meta file.","title":"edit_torrent()"},{"location":"edit/#torrentfile.edit.edit_torrent--parameters","text":"str path to the torrent meta file. dict key value pairs of the properties to be edited.","title":"Parameters"},{"location":"edit/#torrentfile.edit.edit_torrent--returns","text":"dict The edited and nested Meta and info dictionaries. Source code in torrentfile\\edit.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def edit_torrent ( metafile : str , args : dict ) -> dict : \"\"\" Edit the properties and values in a torrent meta file. Parameters ---------- metafile : str path to the torrent meta file. args : dict key value pairs of the properties to be edited. Returns ------- dict The edited and nested Meta and info dictionaries. \"\"\" logger . debug ( \"editing torrent file %s \" , metafile ) meta = pyben . load ( metafile ) info = meta [ \"info\" ] filter_empty ( args , meta , info ) if \"comment\" in args : info [ \"comment\" ] = args [ \"comment\" ] if \"source\" in args : info [ \"source\" ] = args [ \"source\" ] if \"private\" in args : info [ \"private\" ] = 1 if \"announce\" in args : val = args . get ( \"announce\" , None ) if isinstance ( val , str ): vallist = val . split () meta [ \"announce\" ] = vallist [ 0 ] meta [ \"announce-list\" ] = [ vallist ] elif isinstance ( val , list ): meta [ \"announce\" ] = val [ 0 ] meta [ \"announce-list\" ] = [ val ] if \"url-list\" in args : val = args . get ( \"url-list\" ) if isinstance ( val , str ): meta [ \"url-list\" ] = val . split () elif isinstance ( val , list ): meta [ \"url-list\" ] = val if \"httpseeds\" in args : val = args . get ( \"httpseeds\" ) if isinstance ( val , str ): meta [ \"httpseeds\" ] = val . split () elif isinstance ( val , list ): meta [ \"httpseeds\" ] = val meta [ \"info\" ] = info os . remove ( metafile ) pyben . dump ( meta , metafile ) return meta","title":"Returns"},{"location":"edit/#torrentfile.edit.filter_empty","text":"Remove dictionary keys with empty values.","title":"filter_empty()"},{"location":"edit/#torrentfile.edit.filter_empty--parameters","text":"dict Editable metafile properties from user. dict Metafile data dictionary. dict Metafile info dictionary. Source code in torrentfile\\edit.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def filter_empty ( args : dict , meta : dict , info : dict ): \"\"\" Remove dictionary keys with empty values. Parameters ---------- args : dict Editable metafile properties from user. meta : dict Metafile data dictionary. info : dict Metafile info dictionary. \"\"\" for key , val in list ( args . items ()): if val is None : del args [ key ] continue if val == \"\" : if key in meta : del meta [ key ] elif key in info : del info [ key ] del args [ key ] logger . debug ( \"removeing empty fields %s \" , val )","title":"Parameters"},{"location":"hasher/","text":"Piece/File Hashers for Bittorrent meta file contents. FileHasher \u00a4 Bases: CbMixin , ProgMixin Calculate root and piece hashes for creating hybrid torrent file. Create merkle tree layers from sha256 hashed 16KiB blocks of contents. With a branching factor of 2, merge layer hashes until blocks equal piece_length bytes for the piece layer, and then the root hash. Parameters \u00a4 str path to target file. int piece length for data chunks. int default = None Source code in torrentfile\\hasher.py 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 class FileHasher ( CbMixin , ProgMixin ): \"\"\" Calculate root and piece hashes for creating hybrid torrent file. Create merkle tree layers from sha256 hashed 16KiB blocks of contents. With a branching factor of 2, merge layer hashes until blocks equal piece_length bytes for the piece layer, and then the root hash. Parameters ---------- path : str path to target file. piece_length : int piece length for data chunks. progress : int default = None \"\"\" def __init__ ( self , path : str , piece_length : int , progress : bool = True , hybrid : bool = False , ): \"\"\" Construct Hasher class instances for each file in torrent. \"\"\" self . path = path self . piece_length = piece_length self . pieces = [] self . layer_hashes = [] self . piece_layer = None self . root = None self . padding_piece = None self . padding_file = None self . amount = piece_length // BLOCK_SIZE self . end = False self . current = open ( path , \"rb\" ) self . hybrid = hybrid if progress : self . progressbar = True self . prog_start ( os . path . getsize ( path ), path , unit = \"bytes\" ) def __iter__ ( self ): \"\"\"Return `self`: needed to implement iterator implementation.\"\"\" return self def _pad_remaining ( self , block_count : int ): \"\"\" Generate Hash sized, 0 filled bytes for padding. Parameters ---------- block_count : int current total number of blocks collected. Returns ------- padding : bytes Padding to fill remaining portion of tree. \"\"\" # when the there is only one block for file remaining = self . amount - block_count if not self . layer_hashes : power2 = next_power_2 ( block_count ) remaining = power2 - block_count return [ bytes ( HASH_SIZE ) for _ in range ( remaining )] def __next__ ( self ) -> bytes : \"\"\" Calculate layer hashes for contents of file. Returns ------- bytes The layer merckle root hash. \"\"\" if self . end : self . end = False raise StopIteration plength = self . piece_length blocks = [] piece = sha1 () # nosec total = 0 block = bytearray ( BLOCK_SIZE ) for _ in range ( self . amount ): size = self . current . readinto ( block ) if not size : self . end = True break total += size plength -= size blocks . append ( sha256 ( block [: size ]) . digest ()) if self . hybrid : piece . update ( block [: size ]) if len ( blocks ) != self . amount : padding = self . _pad_remaining ( len ( blocks )) blocks . extend ( padding ) self . prog_update ( total ) layer_hash = merkle_root ( blocks ) self . layer_hashes . append ( layer_hash ) if self . _cb : self . _cb ( layer_hash ) if self . end : self . _calculate_root () self . prog_close () if self . hybrid : if plength > 0 : self . padding_file = { \"attr\" : \"p\" , \"length\" : plength , \"path\" : [ \".pad\" , str ( plength )], } piece . update ( bytes ( plength )) piece = piece . digest () self . pieces . append ( piece ) return layer_hash , piece return layer_hash def _calculate_root ( self ): \"\"\" Calculate the root hash for opened file. \"\"\" self . piece_layer = b \"\" . join ( self . layer_hashes ) if len ( self . layer_hashes ) > 1 : pad_piece = merkle_root ([ bytes ( 32 ) for _ in range ( self . amount )]) pow2 = next_power_2 ( len ( self . layer_hashes )) remainder = pow2 - len ( self . layer_hashes ) self . layer_hashes += [ pad_piece for _ in range ( remainder )] self . root = merkle_root ( self . layer_hashes ) self . current . close () __init__ ( path , piece_length , progress = True , hybrid = False ) \u00a4 Construct Hasher class instances for each file in torrent. Source code in torrentfile\\hasher.py 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 def __init__ ( self , path : str , piece_length : int , progress : bool = True , hybrid : bool = False , ): \"\"\" Construct Hasher class instances for each file in torrent. \"\"\" self . path = path self . piece_length = piece_length self . pieces = [] self . layer_hashes = [] self . piece_layer = None self . root = None self . padding_piece = None self . padding_file = None self . amount = piece_length // BLOCK_SIZE self . end = False self . current = open ( path , \"rb\" ) self . hybrid = hybrid if progress : self . progressbar = True self . prog_start ( os . path . getsize ( path ), path , unit = \"bytes\" ) __iter__ () \u00a4 Return self : needed to implement iterator implementation. Source code in torrentfile\\hasher.py 444 445 446 def __iter__ ( self ): \"\"\"Return `self`: needed to implement iterator implementation.\"\"\" return self __next__ () \u00a4 Calculate layer hashes for contents of file. Returns \u00a4 bytes The layer merckle root hash. Source code in torrentfile\\hasher.py 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 def __next__ ( self ) -> bytes : \"\"\" Calculate layer hashes for contents of file. Returns ------- bytes The layer merckle root hash. \"\"\" if self . end : self . end = False raise StopIteration plength = self . piece_length blocks = [] piece = sha1 () # nosec total = 0 block = bytearray ( BLOCK_SIZE ) for _ in range ( self . amount ): size = self . current . readinto ( block ) if not size : self . end = True break total += size plength -= size blocks . append ( sha256 ( block [: size ]) . digest ()) if self . hybrid : piece . update ( block [: size ]) if len ( blocks ) != self . amount : padding = self . _pad_remaining ( len ( blocks )) blocks . extend ( padding ) self . prog_update ( total ) layer_hash = merkle_root ( blocks ) self . layer_hashes . append ( layer_hash ) if self . _cb : self . _cb ( layer_hash ) if self . end : self . _calculate_root () self . prog_close () if self . hybrid : if plength > 0 : self . padding_file = { \"attr\" : \"p\" , \"length\" : plength , \"path\" : [ \".pad\" , str ( plength )], } piece . update ( bytes ( plength )) piece = piece . digest () self . pieces . append ( piece ) return layer_hash , piece return layer_hash _calculate_root () \u00a4 Calculate the root hash for opened file. Source code in torrentfile\\hasher.py 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 def _calculate_root ( self ): \"\"\" Calculate the root hash for opened file. \"\"\" self . piece_layer = b \"\" . join ( self . layer_hashes ) if len ( self . layer_hashes ) > 1 : pad_piece = merkle_root ([ bytes ( 32 ) for _ in range ( self . amount )]) pow2 = next_power_2 ( len ( self . layer_hashes )) remainder = pow2 - len ( self . layer_hashes ) self . layer_hashes += [ pad_piece for _ in range ( remainder )] self . root = merkle_root ( self . layer_hashes ) self . current . close () _pad_remaining ( block_count ) \u00a4 Generate Hash sized, 0 filled bytes for padding. Parameters \u00a4 int current total number of blocks collected. Returns \u00a4 bytes Padding to fill remaining portion of tree. Source code in torrentfile\\hasher.py 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 def _pad_remaining ( self , block_count : int ): \"\"\" Generate Hash sized, 0 filled bytes for padding. Parameters ---------- block_count : int current total number of blocks collected. Returns ------- padding : bytes Padding to fill remaining portion of tree. \"\"\" # when the there is only one block for file remaining = self . amount - block_count if not self . layer_hashes : power2 = next_power_2 ( block_count ) remaining = power2 - block_count return [ bytes ( HASH_SIZE ) for _ in range ( remaining )] Hasher \u00a4 Bases: CbMixin , ProgMixin Piece hasher for Bittorrent V1 files. Takes a sorted list of all file paths, calculates sha1 hash for fixed size pieces of file data from each file seemlessly until the last piece which may be smaller than others. Parameters \u00a4 list List of files. int Size of chuncks to split the data into. int default = None Source code in torrentfile\\hasher.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 class Hasher ( CbMixin , ProgMixin ): \"\"\" Piece hasher for Bittorrent V1 files. Takes a sorted list of all file paths, calculates sha1 hash for fixed size pieces of file data from each file seemlessly until the last piece which may be smaller than others. Parameters ---------- paths : list List of files. piece_length : int Size of chuncks to split the data into. progress : int default = None \"\"\" def __init__ ( self , paths : list , piece_length : int , progress : bool = True ): \"\"\"Generate hashes of piece length data from filelist contents.\"\"\" self . piece_length = piece_length self . paths = paths self . progress = progress self . total = sum ( os . path . getsize ( i ) for i in self . paths ) self . index = 0 self . current = open ( self . paths [ 0 ], \"rb\" ) if self . progress : total = os . path . getsize ( self . paths [ 0 ]) self . prog_start ( total , self . paths [ 0 ], unit = \"bytes\" ) logger . debug ( \"Hashing %s \" , str ( self . paths [ 0 ])) def __iter__ ( self ): \"\"\" Iterate through feed pieces. Returns ------- self : iterator Iterator for leaves/hash pieces. \"\"\" return self def _handle_partial ( self , arr : bytearray ) -> bytearray : \"\"\" Define the handling partial pieces that span 2 or more files. Parameters ---------- arr : bytearray Incomplete piece containing partial data Returns ------- digest : bytearray SHA1 digest of the complete piece. \"\"\" while len ( arr ) < self . piece_length and self . next_file (): target = self . piece_length - len ( arr ) temp = bytearray ( target ) size = self . current . readinto ( temp ) arr . extend ( temp [: size ]) self . prog_update ( size ) if size == target : break return sha1 ( arr ) . digest () # nosec def next_file ( self ) -> bool : \"\"\" Seemlessly transition to next file in file list. Returns ------- bool: True if there is a next file otherwise False. \"\"\" self . index += 1 self . prog_close () if self . index < len ( self . paths ): path = self . paths [ self . index ] logger . debug ( \"Hashing %s \" , str ( path )) self . current . close () if self . progress : self . prog_start ( os . path . getsize ( path ), path , unit = \"bytes\" ) self . current = open ( path , \"rb\" ) return True return False def __next__ ( self ) -> bytes : \"\"\" Generate piece-length pieces of data from input file list. Returns ------- bytes SHA1 hash of the piece extracted. \"\"\" while True : piece = bytearray ( self . piece_length ) size = self . current . readinto ( piece ) if size == 0 : if not self . next_file (): raise StopIteration elif size < self . piece_length : self . prog_update ( size ) return self . _handle_partial ( piece [: size ]) else : self . prog_update ( size ) return sha1 ( piece ) . digest () # nosec __init__ ( paths , piece_length , progress = True ) \u00a4 Generate hashes of piece length data from filelist contents. Source code in torrentfile\\hasher.py 54 55 56 57 58 59 60 61 62 63 64 65 def __init__ ( self , paths : list , piece_length : int , progress : bool = True ): \"\"\"Generate hashes of piece length data from filelist contents.\"\"\" self . piece_length = piece_length self . paths = paths self . progress = progress self . total = sum ( os . path . getsize ( i ) for i in self . paths ) self . index = 0 self . current = open ( self . paths [ 0 ], \"rb\" ) if self . progress : total = os . path . getsize ( self . paths [ 0 ]) self . prog_start ( total , self . paths [ 0 ], unit = \"bytes\" ) logger . debug ( \"Hashing %s \" , str ( self . paths [ 0 ])) __iter__ () \u00a4 Iterate through feed pieces. Returns \u00a4 iterator Iterator for leaves/hash pieces. Source code in torrentfile\\hasher.py 67 68 69 70 71 72 73 74 75 76 def __iter__ ( self ): \"\"\" Iterate through feed pieces. Returns ------- self : iterator Iterator for leaves/hash pieces. \"\"\" return self __next__ () \u00a4 Generate piece-length pieces of data from input file list. Returns \u00a4 bytes SHA1 hash of the piece extracted. Source code in torrentfile\\hasher.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def __next__ ( self ) -> bytes : \"\"\" Generate piece-length pieces of data from input file list. Returns ------- bytes SHA1 hash of the piece extracted. \"\"\" while True : piece = bytearray ( self . piece_length ) size = self . current . readinto ( piece ) if size == 0 : if not self . next_file (): raise StopIteration elif size < self . piece_length : self . prog_update ( size ) return self . _handle_partial ( piece [: size ]) else : self . prog_update ( size ) return sha1 ( piece ) . digest () # nosec _handle_partial ( arr ) \u00a4 Define the handling partial pieces that span 2 or more files. Parameters \u00a4 bytearray Incomplete piece containing partial data Returns \u00a4 bytearray SHA1 digest of the complete piece. Source code in torrentfile\\hasher.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def _handle_partial ( self , arr : bytearray ) -> bytearray : \"\"\" Define the handling partial pieces that span 2 or more files. Parameters ---------- arr : bytearray Incomplete piece containing partial data Returns ------- digest : bytearray SHA1 digest of the complete piece. \"\"\" while len ( arr ) < self . piece_length and self . next_file (): target = self . piece_length - len ( arr ) temp = bytearray ( target ) size = self . current . readinto ( temp ) arr . extend ( temp [: size ]) self . prog_update ( size ) if size == target : break return sha1 ( arr ) . digest () # nosec next_file () \u00a4 Seemlessly transition to next file in file list. Returns \u00a4 bool True if there is a next file otherwise False. Source code in torrentfile\\hasher.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def next_file ( self ) -> bool : \"\"\" Seemlessly transition to next file in file list. Returns ------- bool: True if there is a next file otherwise False. \"\"\" self . index += 1 self . prog_close () if self . index < len ( self . paths ): path = self . paths [ self . index ] logger . debug ( \"Hashing %s \" , str ( path )) self . current . close () if self . progress : self . prog_start ( os . path . getsize ( path ), path , unit = \"bytes\" ) self . current = open ( path , \"rb\" ) return True return False HasherHybrid \u00a4 Bases: CbMixin , ProgMixin Calculate root and piece hashes for creating hybrid torrent file. DEPRECATED Create merkle tree layers from sha256 hashed 16KiB blocks of contents. With a branching factor of 2, merge layer hashes until blocks equal piece_length bytes for the piece layer, and then the root hash. Parameters \u00a4 str path to target file. int piece length for data chunks. int default = None Source code in torrentfile\\hasher.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 class HasherHybrid ( CbMixin , ProgMixin ): \"\"\" Calculate root and piece hashes for creating hybrid torrent file. **DEPRECATED** Create merkle tree layers from sha256 hashed 16KiB blocks of contents. With a branching factor of 2, merge layer hashes until blocks equal piece_length bytes for the piece layer, and then the root hash. Parameters ---------- path : str path to target file. piece_length : int piece length for data chunks. progress : int default = None \"\"\" def __init__ ( self , path : str , piece_length : int , progress : bool = True ): \"\"\" Construct Hasher class instances for each file in torrent. **DEPRECATED** \"\"\" self . path = path self . piece_length = piece_length self . pieces = [] self . layer_hashes = [] self . piece_layer = None self . root = None self . padding_piece = None self . padding_file = None if progress : self . prog_start ( os . path . getsize ( path ), path , unit = \"bytes\" ) self . amount = piece_length // BLOCK_SIZE with open ( path , \"rb\" ) as data : self . process_file ( data ) def _pad_remaining ( self , block_count : int ): \"\"\" Generate Hash sized, 0 filled bytes for padding. **DEPRECATED** Parameters ---------- block_count : int current total number of blocks collected. Returns ------- padding : bytes Padding to fill remaining portion of tree. \"\"\" # when the there is only one block for file remaining = self . amount - block_count if not self . layer_hashes : power2 = next_power_2 ( block_count ) remaining = power2 - block_count self . prog_update ( HASH_SIZE * remaining ) return [ bytes ( HASH_SIZE ) for _ in range ( remaining )] def process_file ( self , data : bytearray ): \"\"\" Calculate layer hashes for contents of file. **DEPRECATED** Parameters ---------- data : BytesIO File opened in read mode. \"\"\" while True : plength = self . piece_length blocks = [] piece = sha1 () # nosec total = 0 block = bytearray ( BLOCK_SIZE ) for _ in range ( self . amount ): size = data . readinto ( block ) self . prog_update ( size ) if not size : break total += size plength -= size blocks . append ( sha256 ( block [: size ]) . digest ()) piece . update ( block [: size ]) if not blocks : break if len ( blocks ) != self . amount : padding = self . _pad_remaining ( len ( blocks )) blocks . extend ( padding ) layer_hash = merkle_root ( blocks ) if self . _cb : self . _cb ( layer_hash ) self . layer_hashes . append ( layer_hash ) if plength > 0 : self . padding_file = { \"attr\" : \"p\" , \"length\" : plength , \"path\" : [ \".pad\" , str ( plength )], } piece . update ( bytes ( plength )) self . pieces . append ( piece . digest ()) # nosec self . _calculate_root () self . prog_close () def _calculate_root ( self ): \"\"\" Calculate the root hash for opened file. **DEPRECATED** \"\"\" self . piece_layer = b \"\" . join ( self . layer_hashes ) if len ( self . layer_hashes ) > 1 : pad_piece = merkle_root ([ bytes ( 32 ) for _ in range ( self . amount )]) pow2 = next_power_2 ( len ( self . layer_hashes )) remainder = pow2 - len ( self . layer_hashes ) self . layer_hashes += [ pad_piece for _ in range ( remainder )] self . root = merkle_root ( self . layer_hashes ) __init__ ( path , piece_length , progress = True ) \u00a4 Construct Hasher class instances for each file in torrent. DEPRECATED Source code in torrentfile\\hasher.py 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 def __init__ ( self , path : str , piece_length : int , progress : bool = True ): \"\"\" Construct Hasher class instances for each file in torrent. **DEPRECATED** \"\"\" self . path = path self . piece_length = piece_length self . pieces = [] self . layer_hashes = [] self . piece_layer = None self . root = None self . padding_piece = None self . padding_file = None if progress : self . prog_start ( os . path . getsize ( path ), path , unit = \"bytes\" ) self . amount = piece_length // BLOCK_SIZE with open ( path , \"rb\" ) as data : self . process_file ( data ) _calculate_root () \u00a4 Calculate the root hash for opened file. DEPRECATED Source code in torrentfile\\hasher.py 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 def _calculate_root ( self ): \"\"\" Calculate the root hash for opened file. **DEPRECATED** \"\"\" self . piece_layer = b \"\" . join ( self . layer_hashes ) if len ( self . layer_hashes ) > 1 : pad_piece = merkle_root ([ bytes ( 32 ) for _ in range ( self . amount )]) pow2 = next_power_2 ( len ( self . layer_hashes )) remainder = pow2 - len ( self . layer_hashes ) self . layer_hashes += [ pad_piece for _ in range ( remainder )] self . root = merkle_root ( self . layer_hashes ) _pad_remaining ( block_count ) \u00a4 Generate Hash sized, 0 filled bytes for padding. DEPRECATED Parameters \u00a4 int current total number of blocks collected. Returns \u00a4 bytes Padding to fill remaining portion of tree. Source code in torrentfile\\hasher.py 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 def _pad_remaining ( self , block_count : int ): \"\"\" Generate Hash sized, 0 filled bytes for padding. **DEPRECATED** Parameters ---------- block_count : int current total number of blocks collected. Returns ------- padding : bytes Padding to fill remaining portion of tree. \"\"\" # when the there is only one block for file remaining = self . amount - block_count if not self . layer_hashes : power2 = next_power_2 ( block_count ) remaining = power2 - block_count self . prog_update ( HASH_SIZE * remaining ) return [ bytes ( HASH_SIZE ) for _ in range ( remaining )] process_file ( data ) \u00a4 Calculate layer hashes for contents of file. DEPRECATED Parameters \u00a4 BytesIO File opened in read mode. Source code in torrentfile\\hasher.py 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def process_file ( self , data : bytearray ): \"\"\" Calculate layer hashes for contents of file. **DEPRECATED** Parameters ---------- data : BytesIO File opened in read mode. \"\"\" while True : plength = self . piece_length blocks = [] piece = sha1 () # nosec total = 0 block = bytearray ( BLOCK_SIZE ) for _ in range ( self . amount ): size = data . readinto ( block ) self . prog_update ( size ) if not size : break total += size plength -= size blocks . append ( sha256 ( block [: size ]) . digest ()) piece . update ( block [: size ]) if not blocks : break if len ( blocks ) != self . amount : padding = self . _pad_remaining ( len ( blocks )) blocks . extend ( padding ) layer_hash = merkle_root ( blocks ) if self . _cb : self . _cb ( layer_hash ) self . layer_hashes . append ( layer_hash ) if plength > 0 : self . padding_file = { \"attr\" : \"p\" , \"length\" : plength , \"path\" : [ \".pad\" , str ( plength )], } piece . update ( bytes ( plength )) self . pieces . append ( piece . digest ()) # nosec self . _calculate_root () self . prog_close () HasherV2 \u00a4 Bases: CbMixin , ProgMixin Calculate the root hash and piece layers for file contents. DEPRECATED Iterates over 16KiB blocks of data from given file, hashes the data, then creates a hash tree from the individual block hashes until size of hashed data equals the piece-length. Then continues the hash tree until root hash is calculated. Parameters \u00a4 str Path to file. int Size of layer hashes pieces. int default = None Source code in torrentfile\\hasher.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 class HasherV2 ( CbMixin , ProgMixin ): \"\"\" Calculate the root hash and piece layers for file contents. **DEPRECATED** Iterates over 16KiB blocks of data from given file, hashes the data, then creates a hash tree from the individual block hashes until size of hashed data equals the piece-length. Then continues the hash tree until root hash is calculated. Parameters ---------- path : str Path to file. piece_length : int Size of layer hashes pieces. progress : int default = None \"\"\" def __init__ ( self , path : str , piece_length : int , progress : bool = True ): \"\"\" Calculate and store hash information for specific file. **DEPRECATED** \"\"\" self . path = path self . root = None self . piece_layer = None self . layer_hashes = [] self . piece_length = piece_length self . num_blocks = piece_length // BLOCK_SIZE if progress : self . prog_start ( os . path . getsize ( path ), path , unit = \"bytes\" ) with open ( self . path , \"rb\" ) as fd : self . process_file ( fd ) def process_file ( self , fd : str ): \"\"\" Calculate hashes over 16KiB chuncks of file content. **DEPRECATED** Parameters ---------- fd : TextIOWrapper Opened file in read mode. \"\"\" while True : blocks = [] leaf = bytearray ( BLOCK_SIZE ) # generate leaves of merkle tree for _ in range ( self . num_blocks ): size = fd . readinto ( leaf ) self . prog_update ( size ) if not size : break blocks . append ( sha256 ( leaf [: size ]) . digest ()) # blocks is empty mean eof if not blocks : break if len ( blocks ) != self . num_blocks : # when size of file doesn't fill the last block # when the file contains multiple pieces remaining = self . num_blocks - len ( blocks ) if not self . layer_hashes : # when the there is only one block for file power2 = next_power_2 ( len ( blocks )) remaining = power2 - len ( blocks ) # pad the the rest with zeroes to fill remaining space. padding = [ bytes ( 32 ) for _ in range ( remaining )] self . prog_update ( HASH_SIZE * remaining ) blocks . extend ( padding ) # calculate the root hash for the merkle tree up to piece-length layer_hash = merkle_root ( blocks ) if self . _cb : self . _cb ( layer_hash ) self . layer_hashes . append ( layer_hash ) self . _calculate_root () self . prog_close () def _calculate_root ( self ): \"\"\" Calculate root hash for the target file. **DEPRECATED** \"\"\" self . piece_layer = b \"\" . join ( self . layer_hashes ) hashes = len ( self . layer_hashes ) if hashes > 1 : pow2 = next_power_2 ( hashes ) remainder = pow2 - hashes pad_piece = [ bytes ( HASH_SIZE ) for _ in range ( self . num_blocks )] for _ in range ( remainder ): self . layer_hashes . append ( merkle_root ( pad_piece )) self . root = merkle_root ( self . layer_hashes ) __init__ ( path , piece_length , progress = True ) \u00a4 Calculate and store hash information for specific file. DEPRECATED Source code in torrentfile\\hasher.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def __init__ ( self , path : str , piece_length : int , progress : bool = True ): \"\"\" Calculate and store hash information for specific file. **DEPRECATED** \"\"\" self . path = path self . root = None self . piece_layer = None self . layer_hashes = [] self . piece_length = piece_length self . num_blocks = piece_length // BLOCK_SIZE if progress : self . prog_start ( os . path . getsize ( path ), path , unit = \"bytes\" ) with open ( self . path , \"rb\" ) as fd : self . process_file ( fd ) _calculate_root () \u00a4 Calculate root hash for the target file. DEPRECATED Source code in torrentfile\\hasher.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 def _calculate_root ( self ): \"\"\" Calculate root hash for the target file. **DEPRECATED** \"\"\" self . piece_layer = b \"\" . join ( self . layer_hashes ) hashes = len ( self . layer_hashes ) if hashes > 1 : pow2 = next_power_2 ( hashes ) remainder = pow2 - hashes pad_piece = [ bytes ( HASH_SIZE ) for _ in range ( self . num_blocks )] for _ in range ( remainder ): self . layer_hashes . append ( merkle_root ( pad_piece )) self . root = merkle_root ( self . layer_hashes ) process_file ( fd ) \u00a4 Calculate hashes over 16KiB chuncks of file content. DEPRECATED Parameters \u00a4 TextIOWrapper Opened file in read mode. Source code in torrentfile\\hasher.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def process_file ( self , fd : str ): \"\"\" Calculate hashes over 16KiB chuncks of file content. **DEPRECATED** Parameters ---------- fd : TextIOWrapper Opened file in read mode. \"\"\" while True : blocks = [] leaf = bytearray ( BLOCK_SIZE ) # generate leaves of merkle tree for _ in range ( self . num_blocks ): size = fd . readinto ( leaf ) self . prog_update ( size ) if not size : break blocks . append ( sha256 ( leaf [: size ]) . digest ()) # blocks is empty mean eof if not blocks : break if len ( blocks ) != self . num_blocks : # when size of file doesn't fill the last block # when the file contains multiple pieces remaining = self . num_blocks - len ( blocks ) if not self . layer_hashes : # when the there is only one block for file power2 = next_power_2 ( len ( blocks )) remaining = power2 - len ( blocks ) # pad the the rest with zeroes to fill remaining space. padding = [ bytes ( 32 ) for _ in range ( remaining )] self . prog_update ( HASH_SIZE * remaining ) blocks . extend ( padding ) # calculate the root hash for the merkle tree up to piece-length layer_hash = merkle_root ( blocks ) if self . _cb : self . _cb ( layer_hash ) self . layer_hashes . append ( layer_hash ) self . _calculate_root () self . prog_close () merkle_root ( blocks ) \u00a4 Calculate the merkle root for a seq of sha256 hash digests. Parameters \u00a4 list a sequence of sha256 layer hashes. Returns \u00a4 bytes the sha256 root hash of the merkle tree. Source code in torrentfile\\hasher.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def merkle_root ( blocks : list ) -> bytes : \"\"\" Calculate the merkle root for a seq of sha256 hash digests. Parameters ---------- blocks : list a sequence of sha256 layer hashes. Returns ------- bytes the sha256 root hash of the merkle tree. \"\"\" if blocks : while len ( blocks ) > 1 : blocks = [ sha256 ( x + y ) . digest () for x , y in zip ( * [ iter ( blocks )] * 2 ) ] return blocks [ 0 ] return blocks","title":"hasher"},{"location":"hasher/#torrentfile.hasher.FileHasher","text":"Bases: CbMixin , ProgMixin Calculate root and piece hashes for creating hybrid torrent file. Create merkle tree layers from sha256 hashed 16KiB blocks of contents. With a branching factor of 2, merge layer hashes until blocks equal piece_length bytes for the piece layer, and then the root hash.","title":"FileHasher"},{"location":"hasher/#torrentfile.hasher.FileHasher--parameters","text":"str path to target file. int piece length for data chunks. int default = None Source code in torrentfile\\hasher.py 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 class FileHasher ( CbMixin , ProgMixin ): \"\"\" Calculate root and piece hashes for creating hybrid torrent file. Create merkle tree layers from sha256 hashed 16KiB blocks of contents. With a branching factor of 2, merge layer hashes until blocks equal piece_length bytes for the piece layer, and then the root hash. Parameters ---------- path : str path to target file. piece_length : int piece length for data chunks. progress : int default = None \"\"\" def __init__ ( self , path : str , piece_length : int , progress : bool = True , hybrid : bool = False , ): \"\"\" Construct Hasher class instances for each file in torrent. \"\"\" self . path = path self . piece_length = piece_length self . pieces = [] self . layer_hashes = [] self . piece_layer = None self . root = None self . padding_piece = None self . padding_file = None self . amount = piece_length // BLOCK_SIZE self . end = False self . current = open ( path , \"rb\" ) self . hybrid = hybrid if progress : self . progressbar = True self . prog_start ( os . path . getsize ( path ), path , unit = \"bytes\" ) def __iter__ ( self ): \"\"\"Return `self`: needed to implement iterator implementation.\"\"\" return self def _pad_remaining ( self , block_count : int ): \"\"\" Generate Hash sized, 0 filled bytes for padding. Parameters ---------- block_count : int current total number of blocks collected. Returns ------- padding : bytes Padding to fill remaining portion of tree. \"\"\" # when the there is only one block for file remaining = self . amount - block_count if not self . layer_hashes : power2 = next_power_2 ( block_count ) remaining = power2 - block_count return [ bytes ( HASH_SIZE ) for _ in range ( remaining )] def __next__ ( self ) -> bytes : \"\"\" Calculate layer hashes for contents of file. Returns ------- bytes The layer merckle root hash. \"\"\" if self . end : self . end = False raise StopIteration plength = self . piece_length blocks = [] piece = sha1 () # nosec total = 0 block = bytearray ( BLOCK_SIZE ) for _ in range ( self . amount ): size = self . current . readinto ( block ) if not size : self . end = True break total += size plength -= size blocks . append ( sha256 ( block [: size ]) . digest ()) if self . hybrid : piece . update ( block [: size ]) if len ( blocks ) != self . amount : padding = self . _pad_remaining ( len ( blocks )) blocks . extend ( padding ) self . prog_update ( total ) layer_hash = merkle_root ( blocks ) self . layer_hashes . append ( layer_hash ) if self . _cb : self . _cb ( layer_hash ) if self . end : self . _calculate_root () self . prog_close () if self . hybrid : if plength > 0 : self . padding_file = { \"attr\" : \"p\" , \"length\" : plength , \"path\" : [ \".pad\" , str ( plength )], } piece . update ( bytes ( plength )) piece = piece . digest () self . pieces . append ( piece ) return layer_hash , piece return layer_hash def _calculate_root ( self ): \"\"\" Calculate the root hash for opened file. \"\"\" self . piece_layer = b \"\" . join ( self . layer_hashes ) if len ( self . layer_hashes ) > 1 : pad_piece = merkle_root ([ bytes ( 32 ) for _ in range ( self . amount )]) pow2 = next_power_2 ( len ( self . layer_hashes )) remainder = pow2 - len ( self . layer_hashes ) self . layer_hashes += [ pad_piece for _ in range ( remainder )] self . root = merkle_root ( self . layer_hashes ) self . current . close ()","title":"Parameters"},{"location":"hasher/#torrentfile.hasher.FileHasher.__init__","text":"Construct Hasher class instances for each file in torrent. Source code in torrentfile\\hasher.py 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 def __init__ ( self , path : str , piece_length : int , progress : bool = True , hybrid : bool = False , ): \"\"\" Construct Hasher class instances for each file in torrent. \"\"\" self . path = path self . piece_length = piece_length self . pieces = [] self . layer_hashes = [] self . piece_layer = None self . root = None self . padding_piece = None self . padding_file = None self . amount = piece_length // BLOCK_SIZE self . end = False self . current = open ( path , \"rb\" ) self . hybrid = hybrid if progress : self . progressbar = True self . prog_start ( os . path . getsize ( path ), path , unit = \"bytes\" )","title":"__init__()"},{"location":"hasher/#torrentfile.hasher.FileHasher.__iter__","text":"Return self : needed to implement iterator implementation. Source code in torrentfile\\hasher.py 444 445 446 def __iter__ ( self ): \"\"\"Return `self`: needed to implement iterator implementation.\"\"\" return self","title":"__iter__()"},{"location":"hasher/#torrentfile.hasher.FileHasher.__next__","text":"Calculate layer hashes for contents of file.","title":"__next__()"},{"location":"hasher/#torrentfile.hasher.FileHasher.__next__--returns","text":"bytes The layer merckle root hash. Source code in torrentfile\\hasher.py 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 def __next__ ( self ) -> bytes : \"\"\" Calculate layer hashes for contents of file. Returns ------- bytes The layer merckle root hash. \"\"\" if self . end : self . end = False raise StopIteration plength = self . piece_length blocks = [] piece = sha1 () # nosec total = 0 block = bytearray ( BLOCK_SIZE ) for _ in range ( self . amount ): size = self . current . readinto ( block ) if not size : self . end = True break total += size plength -= size blocks . append ( sha256 ( block [: size ]) . digest ()) if self . hybrid : piece . update ( block [: size ]) if len ( blocks ) != self . amount : padding = self . _pad_remaining ( len ( blocks )) blocks . extend ( padding ) self . prog_update ( total ) layer_hash = merkle_root ( blocks ) self . layer_hashes . append ( layer_hash ) if self . _cb : self . _cb ( layer_hash ) if self . end : self . _calculate_root () self . prog_close () if self . hybrid : if plength > 0 : self . padding_file = { \"attr\" : \"p\" , \"length\" : plength , \"path\" : [ \".pad\" , str ( plength )], } piece . update ( bytes ( plength )) piece = piece . digest () self . pieces . append ( piece ) return layer_hash , piece return layer_hash","title":"Returns"},{"location":"hasher/#torrentfile.hasher.FileHasher._calculate_root","text":"Calculate the root hash for opened file. Source code in torrentfile\\hasher.py 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 def _calculate_root ( self ): \"\"\" Calculate the root hash for opened file. \"\"\" self . piece_layer = b \"\" . join ( self . layer_hashes ) if len ( self . layer_hashes ) > 1 : pad_piece = merkle_root ([ bytes ( 32 ) for _ in range ( self . amount )]) pow2 = next_power_2 ( len ( self . layer_hashes )) remainder = pow2 - len ( self . layer_hashes ) self . layer_hashes += [ pad_piece for _ in range ( remainder )] self . root = merkle_root ( self . layer_hashes ) self . current . close ()","title":"_calculate_root()"},{"location":"hasher/#torrentfile.hasher.FileHasher._pad_remaining","text":"Generate Hash sized, 0 filled bytes for padding.","title":"_pad_remaining()"},{"location":"hasher/#torrentfile.hasher.FileHasher._pad_remaining--parameters","text":"int current total number of blocks collected.","title":"Parameters"},{"location":"hasher/#torrentfile.hasher.FileHasher._pad_remaining--returns","text":"bytes Padding to fill remaining portion of tree. Source code in torrentfile\\hasher.py 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 def _pad_remaining ( self , block_count : int ): \"\"\" Generate Hash sized, 0 filled bytes for padding. Parameters ---------- block_count : int current total number of blocks collected. Returns ------- padding : bytes Padding to fill remaining portion of tree. \"\"\" # when the there is only one block for file remaining = self . amount - block_count if not self . layer_hashes : power2 = next_power_2 ( block_count ) remaining = power2 - block_count return [ bytes ( HASH_SIZE ) for _ in range ( remaining )]","title":"Returns"},{"location":"hasher/#torrentfile.hasher.Hasher","text":"Bases: CbMixin , ProgMixin Piece hasher for Bittorrent V1 files. Takes a sorted list of all file paths, calculates sha1 hash for fixed size pieces of file data from each file seemlessly until the last piece which may be smaller than others.","title":"Hasher"},{"location":"hasher/#torrentfile.hasher.Hasher--parameters","text":"list List of files. int Size of chuncks to split the data into. int default = None Source code in torrentfile\\hasher.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 class Hasher ( CbMixin , ProgMixin ): \"\"\" Piece hasher for Bittorrent V1 files. Takes a sorted list of all file paths, calculates sha1 hash for fixed size pieces of file data from each file seemlessly until the last piece which may be smaller than others. Parameters ---------- paths : list List of files. piece_length : int Size of chuncks to split the data into. progress : int default = None \"\"\" def __init__ ( self , paths : list , piece_length : int , progress : bool = True ): \"\"\"Generate hashes of piece length data from filelist contents.\"\"\" self . piece_length = piece_length self . paths = paths self . progress = progress self . total = sum ( os . path . getsize ( i ) for i in self . paths ) self . index = 0 self . current = open ( self . paths [ 0 ], \"rb\" ) if self . progress : total = os . path . getsize ( self . paths [ 0 ]) self . prog_start ( total , self . paths [ 0 ], unit = \"bytes\" ) logger . debug ( \"Hashing %s \" , str ( self . paths [ 0 ])) def __iter__ ( self ): \"\"\" Iterate through feed pieces. Returns ------- self : iterator Iterator for leaves/hash pieces. \"\"\" return self def _handle_partial ( self , arr : bytearray ) -> bytearray : \"\"\" Define the handling partial pieces that span 2 or more files. Parameters ---------- arr : bytearray Incomplete piece containing partial data Returns ------- digest : bytearray SHA1 digest of the complete piece. \"\"\" while len ( arr ) < self . piece_length and self . next_file (): target = self . piece_length - len ( arr ) temp = bytearray ( target ) size = self . current . readinto ( temp ) arr . extend ( temp [: size ]) self . prog_update ( size ) if size == target : break return sha1 ( arr ) . digest () # nosec def next_file ( self ) -> bool : \"\"\" Seemlessly transition to next file in file list. Returns ------- bool: True if there is a next file otherwise False. \"\"\" self . index += 1 self . prog_close () if self . index < len ( self . paths ): path = self . paths [ self . index ] logger . debug ( \"Hashing %s \" , str ( path )) self . current . close () if self . progress : self . prog_start ( os . path . getsize ( path ), path , unit = \"bytes\" ) self . current = open ( path , \"rb\" ) return True return False def __next__ ( self ) -> bytes : \"\"\" Generate piece-length pieces of data from input file list. Returns ------- bytes SHA1 hash of the piece extracted. \"\"\" while True : piece = bytearray ( self . piece_length ) size = self . current . readinto ( piece ) if size == 0 : if not self . next_file (): raise StopIteration elif size < self . piece_length : self . prog_update ( size ) return self . _handle_partial ( piece [: size ]) else : self . prog_update ( size ) return sha1 ( piece ) . digest () # nosec","title":"Parameters"},{"location":"hasher/#torrentfile.hasher.Hasher.__init__","text":"Generate hashes of piece length data from filelist contents. Source code in torrentfile\\hasher.py 54 55 56 57 58 59 60 61 62 63 64 65 def __init__ ( self , paths : list , piece_length : int , progress : bool = True ): \"\"\"Generate hashes of piece length data from filelist contents.\"\"\" self . piece_length = piece_length self . paths = paths self . progress = progress self . total = sum ( os . path . getsize ( i ) for i in self . paths ) self . index = 0 self . current = open ( self . paths [ 0 ], \"rb\" ) if self . progress : total = os . path . getsize ( self . paths [ 0 ]) self . prog_start ( total , self . paths [ 0 ], unit = \"bytes\" ) logger . debug ( \"Hashing %s \" , str ( self . paths [ 0 ]))","title":"__init__()"},{"location":"hasher/#torrentfile.hasher.Hasher.__iter__","text":"Iterate through feed pieces.","title":"__iter__()"},{"location":"hasher/#torrentfile.hasher.Hasher.__iter__--returns","text":"iterator Iterator for leaves/hash pieces. Source code in torrentfile\\hasher.py 67 68 69 70 71 72 73 74 75 76 def __iter__ ( self ): \"\"\" Iterate through feed pieces. Returns ------- self : iterator Iterator for leaves/hash pieces. \"\"\" return self","title":"Returns"},{"location":"hasher/#torrentfile.hasher.Hasher.__next__","text":"Generate piece-length pieces of data from input file list.","title":"__next__()"},{"location":"hasher/#torrentfile.hasher.Hasher.__next__--returns","text":"bytes SHA1 hash of the piece extracted. Source code in torrentfile\\hasher.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def __next__ ( self ) -> bytes : \"\"\" Generate piece-length pieces of data from input file list. Returns ------- bytes SHA1 hash of the piece extracted. \"\"\" while True : piece = bytearray ( self . piece_length ) size = self . current . readinto ( piece ) if size == 0 : if not self . next_file (): raise StopIteration elif size < self . piece_length : self . prog_update ( size ) return self . _handle_partial ( piece [: size ]) else : self . prog_update ( size ) return sha1 ( piece ) . digest () # nosec","title":"Returns"},{"location":"hasher/#torrentfile.hasher.Hasher._handle_partial","text":"Define the handling partial pieces that span 2 or more files.","title":"_handle_partial()"},{"location":"hasher/#torrentfile.hasher.Hasher._handle_partial--parameters","text":"bytearray Incomplete piece containing partial data","title":"Parameters"},{"location":"hasher/#torrentfile.hasher.Hasher._handle_partial--returns","text":"bytearray SHA1 digest of the complete piece. Source code in torrentfile\\hasher.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def _handle_partial ( self , arr : bytearray ) -> bytearray : \"\"\" Define the handling partial pieces that span 2 or more files. Parameters ---------- arr : bytearray Incomplete piece containing partial data Returns ------- digest : bytearray SHA1 digest of the complete piece. \"\"\" while len ( arr ) < self . piece_length and self . next_file (): target = self . piece_length - len ( arr ) temp = bytearray ( target ) size = self . current . readinto ( temp ) arr . extend ( temp [: size ]) self . prog_update ( size ) if size == target : break return sha1 ( arr ) . digest () # nosec","title":"Returns"},{"location":"hasher/#torrentfile.hasher.Hasher.next_file","text":"Seemlessly transition to next file in file list.","title":"next_file()"},{"location":"hasher/#torrentfile.hasher.Hasher.next_file--returns","text":"bool True if there is a next file otherwise False. Source code in torrentfile\\hasher.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def next_file ( self ) -> bool : \"\"\" Seemlessly transition to next file in file list. Returns ------- bool: True if there is a next file otherwise False. \"\"\" self . index += 1 self . prog_close () if self . index < len ( self . paths ): path = self . paths [ self . index ] logger . debug ( \"Hashing %s \" , str ( path )) self . current . close () if self . progress : self . prog_start ( os . path . getsize ( path ), path , unit = \"bytes\" ) self . current = open ( path , \"rb\" ) return True return False","title":"Returns"},{"location":"hasher/#torrentfile.hasher.HasherHybrid","text":"Bases: CbMixin , ProgMixin Calculate root and piece hashes for creating hybrid torrent file. DEPRECATED Create merkle tree layers from sha256 hashed 16KiB blocks of contents. With a branching factor of 2, merge layer hashes until blocks equal piece_length bytes for the piece layer, and then the root hash.","title":"HasherHybrid"},{"location":"hasher/#torrentfile.hasher.HasherHybrid--parameters","text":"str path to target file. int piece length for data chunks. int default = None Source code in torrentfile\\hasher.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 class HasherHybrid ( CbMixin , ProgMixin ): \"\"\" Calculate root and piece hashes for creating hybrid torrent file. **DEPRECATED** Create merkle tree layers from sha256 hashed 16KiB blocks of contents. With a branching factor of 2, merge layer hashes until blocks equal piece_length bytes for the piece layer, and then the root hash. Parameters ---------- path : str path to target file. piece_length : int piece length for data chunks. progress : int default = None \"\"\" def __init__ ( self , path : str , piece_length : int , progress : bool = True ): \"\"\" Construct Hasher class instances for each file in torrent. **DEPRECATED** \"\"\" self . path = path self . piece_length = piece_length self . pieces = [] self . layer_hashes = [] self . piece_layer = None self . root = None self . padding_piece = None self . padding_file = None if progress : self . prog_start ( os . path . getsize ( path ), path , unit = \"bytes\" ) self . amount = piece_length // BLOCK_SIZE with open ( path , \"rb\" ) as data : self . process_file ( data ) def _pad_remaining ( self , block_count : int ): \"\"\" Generate Hash sized, 0 filled bytes for padding. **DEPRECATED** Parameters ---------- block_count : int current total number of blocks collected. Returns ------- padding : bytes Padding to fill remaining portion of tree. \"\"\" # when the there is only one block for file remaining = self . amount - block_count if not self . layer_hashes : power2 = next_power_2 ( block_count ) remaining = power2 - block_count self . prog_update ( HASH_SIZE * remaining ) return [ bytes ( HASH_SIZE ) for _ in range ( remaining )] def process_file ( self , data : bytearray ): \"\"\" Calculate layer hashes for contents of file. **DEPRECATED** Parameters ---------- data : BytesIO File opened in read mode. \"\"\" while True : plength = self . piece_length blocks = [] piece = sha1 () # nosec total = 0 block = bytearray ( BLOCK_SIZE ) for _ in range ( self . amount ): size = data . readinto ( block ) self . prog_update ( size ) if not size : break total += size plength -= size blocks . append ( sha256 ( block [: size ]) . digest ()) piece . update ( block [: size ]) if not blocks : break if len ( blocks ) != self . amount : padding = self . _pad_remaining ( len ( blocks )) blocks . extend ( padding ) layer_hash = merkle_root ( blocks ) if self . _cb : self . _cb ( layer_hash ) self . layer_hashes . append ( layer_hash ) if plength > 0 : self . padding_file = { \"attr\" : \"p\" , \"length\" : plength , \"path\" : [ \".pad\" , str ( plength )], } piece . update ( bytes ( plength )) self . pieces . append ( piece . digest ()) # nosec self . _calculate_root () self . prog_close () def _calculate_root ( self ): \"\"\" Calculate the root hash for opened file. **DEPRECATED** \"\"\" self . piece_layer = b \"\" . join ( self . layer_hashes ) if len ( self . layer_hashes ) > 1 : pad_piece = merkle_root ([ bytes ( 32 ) for _ in range ( self . amount )]) pow2 = next_power_2 ( len ( self . layer_hashes )) remainder = pow2 - len ( self . layer_hashes ) self . layer_hashes += [ pad_piece for _ in range ( remainder )] self . root = merkle_root ( self . layer_hashes )","title":"Parameters"},{"location":"hasher/#torrentfile.hasher.HasherHybrid.__init__","text":"Construct Hasher class instances for each file in torrent. DEPRECATED Source code in torrentfile\\hasher.py 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 def __init__ ( self , path : str , piece_length : int , progress : bool = True ): \"\"\" Construct Hasher class instances for each file in torrent. **DEPRECATED** \"\"\" self . path = path self . piece_length = piece_length self . pieces = [] self . layer_hashes = [] self . piece_layer = None self . root = None self . padding_piece = None self . padding_file = None if progress : self . prog_start ( os . path . getsize ( path ), path , unit = \"bytes\" ) self . amount = piece_length // BLOCK_SIZE with open ( path , \"rb\" ) as data : self . process_file ( data )","title":"__init__()"},{"location":"hasher/#torrentfile.hasher.HasherHybrid._calculate_root","text":"Calculate the root hash for opened file. DEPRECATED Source code in torrentfile\\hasher.py 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 def _calculate_root ( self ): \"\"\" Calculate the root hash for opened file. **DEPRECATED** \"\"\" self . piece_layer = b \"\" . join ( self . layer_hashes ) if len ( self . layer_hashes ) > 1 : pad_piece = merkle_root ([ bytes ( 32 ) for _ in range ( self . amount )]) pow2 = next_power_2 ( len ( self . layer_hashes )) remainder = pow2 - len ( self . layer_hashes ) self . layer_hashes += [ pad_piece for _ in range ( remainder )] self . root = merkle_root ( self . layer_hashes )","title":"_calculate_root()"},{"location":"hasher/#torrentfile.hasher.HasherHybrid._pad_remaining","text":"Generate Hash sized, 0 filled bytes for padding. DEPRECATED","title":"_pad_remaining()"},{"location":"hasher/#torrentfile.hasher.HasherHybrid._pad_remaining--parameters","text":"int current total number of blocks collected.","title":"Parameters"},{"location":"hasher/#torrentfile.hasher.HasherHybrid._pad_remaining--returns","text":"bytes Padding to fill remaining portion of tree. Source code in torrentfile\\hasher.py 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 def _pad_remaining ( self , block_count : int ): \"\"\" Generate Hash sized, 0 filled bytes for padding. **DEPRECATED** Parameters ---------- block_count : int current total number of blocks collected. Returns ------- padding : bytes Padding to fill remaining portion of tree. \"\"\" # when the there is only one block for file remaining = self . amount - block_count if not self . layer_hashes : power2 = next_power_2 ( block_count ) remaining = power2 - block_count self . prog_update ( HASH_SIZE * remaining ) return [ bytes ( HASH_SIZE ) for _ in range ( remaining )]","title":"Returns"},{"location":"hasher/#torrentfile.hasher.HasherHybrid.process_file","text":"Calculate layer hashes for contents of file. DEPRECATED","title":"process_file()"},{"location":"hasher/#torrentfile.hasher.HasherHybrid.process_file--parameters","text":"BytesIO File opened in read mode. Source code in torrentfile\\hasher.py 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def process_file ( self , data : bytearray ): \"\"\" Calculate layer hashes for contents of file. **DEPRECATED** Parameters ---------- data : BytesIO File opened in read mode. \"\"\" while True : plength = self . piece_length blocks = [] piece = sha1 () # nosec total = 0 block = bytearray ( BLOCK_SIZE ) for _ in range ( self . amount ): size = data . readinto ( block ) self . prog_update ( size ) if not size : break total += size plength -= size blocks . append ( sha256 ( block [: size ]) . digest ()) piece . update ( block [: size ]) if not blocks : break if len ( blocks ) != self . amount : padding = self . _pad_remaining ( len ( blocks )) blocks . extend ( padding ) layer_hash = merkle_root ( blocks ) if self . _cb : self . _cb ( layer_hash ) self . layer_hashes . append ( layer_hash ) if plength > 0 : self . padding_file = { \"attr\" : \"p\" , \"length\" : plength , \"path\" : [ \".pad\" , str ( plength )], } piece . update ( bytes ( plength )) self . pieces . append ( piece . digest ()) # nosec self . _calculate_root () self . prog_close ()","title":"Parameters"},{"location":"hasher/#torrentfile.hasher.HasherV2","text":"Bases: CbMixin , ProgMixin Calculate the root hash and piece layers for file contents. DEPRECATED Iterates over 16KiB blocks of data from given file, hashes the data, then creates a hash tree from the individual block hashes until size of hashed data equals the piece-length. Then continues the hash tree until root hash is calculated.","title":"HasherV2"},{"location":"hasher/#torrentfile.hasher.HasherV2--parameters","text":"str Path to file. int Size of layer hashes pieces. int default = None Source code in torrentfile\\hasher.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 class HasherV2 ( CbMixin , ProgMixin ): \"\"\" Calculate the root hash and piece layers for file contents. **DEPRECATED** Iterates over 16KiB blocks of data from given file, hashes the data, then creates a hash tree from the individual block hashes until size of hashed data equals the piece-length. Then continues the hash tree until root hash is calculated. Parameters ---------- path : str Path to file. piece_length : int Size of layer hashes pieces. progress : int default = None \"\"\" def __init__ ( self , path : str , piece_length : int , progress : bool = True ): \"\"\" Calculate and store hash information for specific file. **DEPRECATED** \"\"\" self . path = path self . root = None self . piece_layer = None self . layer_hashes = [] self . piece_length = piece_length self . num_blocks = piece_length // BLOCK_SIZE if progress : self . prog_start ( os . path . getsize ( path ), path , unit = \"bytes\" ) with open ( self . path , \"rb\" ) as fd : self . process_file ( fd ) def process_file ( self , fd : str ): \"\"\" Calculate hashes over 16KiB chuncks of file content. **DEPRECATED** Parameters ---------- fd : TextIOWrapper Opened file in read mode. \"\"\" while True : blocks = [] leaf = bytearray ( BLOCK_SIZE ) # generate leaves of merkle tree for _ in range ( self . num_blocks ): size = fd . readinto ( leaf ) self . prog_update ( size ) if not size : break blocks . append ( sha256 ( leaf [: size ]) . digest ()) # blocks is empty mean eof if not blocks : break if len ( blocks ) != self . num_blocks : # when size of file doesn't fill the last block # when the file contains multiple pieces remaining = self . num_blocks - len ( blocks ) if not self . layer_hashes : # when the there is only one block for file power2 = next_power_2 ( len ( blocks )) remaining = power2 - len ( blocks ) # pad the the rest with zeroes to fill remaining space. padding = [ bytes ( 32 ) for _ in range ( remaining )] self . prog_update ( HASH_SIZE * remaining ) blocks . extend ( padding ) # calculate the root hash for the merkle tree up to piece-length layer_hash = merkle_root ( blocks ) if self . _cb : self . _cb ( layer_hash ) self . layer_hashes . append ( layer_hash ) self . _calculate_root () self . prog_close () def _calculate_root ( self ): \"\"\" Calculate root hash for the target file. **DEPRECATED** \"\"\" self . piece_layer = b \"\" . join ( self . layer_hashes ) hashes = len ( self . layer_hashes ) if hashes > 1 : pow2 = next_power_2 ( hashes ) remainder = pow2 - hashes pad_piece = [ bytes ( HASH_SIZE ) for _ in range ( self . num_blocks )] for _ in range ( remainder ): self . layer_hashes . append ( merkle_root ( pad_piece )) self . root = merkle_root ( self . layer_hashes )","title":"Parameters"},{"location":"hasher/#torrentfile.hasher.HasherV2.__init__","text":"Calculate and store hash information for specific file. DEPRECATED Source code in torrentfile\\hasher.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def __init__ ( self , path : str , piece_length : int , progress : bool = True ): \"\"\" Calculate and store hash information for specific file. **DEPRECATED** \"\"\" self . path = path self . root = None self . piece_layer = None self . layer_hashes = [] self . piece_length = piece_length self . num_blocks = piece_length // BLOCK_SIZE if progress : self . prog_start ( os . path . getsize ( path ), path , unit = \"bytes\" ) with open ( self . path , \"rb\" ) as fd : self . process_file ( fd )","title":"__init__()"},{"location":"hasher/#torrentfile.hasher.HasherV2._calculate_root","text":"Calculate root hash for the target file. DEPRECATED Source code in torrentfile\\hasher.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 def _calculate_root ( self ): \"\"\" Calculate root hash for the target file. **DEPRECATED** \"\"\" self . piece_layer = b \"\" . join ( self . layer_hashes ) hashes = len ( self . layer_hashes ) if hashes > 1 : pow2 = next_power_2 ( hashes ) remainder = pow2 - hashes pad_piece = [ bytes ( HASH_SIZE ) for _ in range ( self . num_blocks )] for _ in range ( remainder ): self . layer_hashes . append ( merkle_root ( pad_piece )) self . root = merkle_root ( self . layer_hashes )","title":"_calculate_root()"},{"location":"hasher/#torrentfile.hasher.HasherV2.process_file","text":"Calculate hashes over 16KiB chuncks of file content. DEPRECATED","title":"process_file()"},{"location":"hasher/#torrentfile.hasher.HasherV2.process_file--parameters","text":"TextIOWrapper Opened file in read mode. Source code in torrentfile\\hasher.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def process_file ( self , fd : str ): \"\"\" Calculate hashes over 16KiB chuncks of file content. **DEPRECATED** Parameters ---------- fd : TextIOWrapper Opened file in read mode. \"\"\" while True : blocks = [] leaf = bytearray ( BLOCK_SIZE ) # generate leaves of merkle tree for _ in range ( self . num_blocks ): size = fd . readinto ( leaf ) self . prog_update ( size ) if not size : break blocks . append ( sha256 ( leaf [: size ]) . digest ()) # blocks is empty mean eof if not blocks : break if len ( blocks ) != self . num_blocks : # when size of file doesn't fill the last block # when the file contains multiple pieces remaining = self . num_blocks - len ( blocks ) if not self . layer_hashes : # when the there is only one block for file power2 = next_power_2 ( len ( blocks )) remaining = power2 - len ( blocks ) # pad the the rest with zeroes to fill remaining space. padding = [ bytes ( 32 ) for _ in range ( remaining )] self . prog_update ( HASH_SIZE * remaining ) blocks . extend ( padding ) # calculate the root hash for the merkle tree up to piece-length layer_hash = merkle_root ( blocks ) if self . _cb : self . _cb ( layer_hash ) self . layer_hashes . append ( layer_hash ) self . _calculate_root () self . prog_close ()","title":"Parameters"},{"location":"hasher/#torrentfile.hasher.merkle_root","text":"Calculate the merkle root for a seq of sha256 hash digests.","title":"merkle_root()"},{"location":"hasher/#torrentfile.hasher.merkle_root--parameters","text":"list a sequence of sha256 layer hashes.","title":"Parameters"},{"location":"hasher/#torrentfile.hasher.merkle_root--returns","text":"bytes the sha256 root hash of the merkle tree. Source code in torrentfile\\hasher.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def merkle_root ( blocks : list ) -> bytes : \"\"\" Calculate the merkle root for a seq of sha256 hash digests. Parameters ---------- blocks : list a sequence of sha256 layer hashes. Returns ------- bytes the sha256 root hash of the merkle tree. \"\"\" if blocks : while len ( blocks ) > 1 : blocks = [ sha256 ( x + y ) . digest () for x , y in zip ( * [ iter ( blocks )] * 2 ) ] return blocks [ 0 ] return blocks","title":"Returns"},{"location":"interactive/","text":"Module contains the procedures used for Interactive Mode. InteractiveCreator \u00a4 Class namespace for interactive program options. Source code in torrentfile\\interactive.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 class InteractiveCreator : \"\"\" Class namespace for interactive program options. \"\"\" def __init__ ( self ): \"\"\" Initialize interactive meta file creator dialog. \"\"\" self . kwargs = { \"announce\" : None , \"url_list\" : None , \"private\" : None , \"source\" : None , \"comment\" : None , \"piece_length\" : None , \"outfile\" : None , \"path\" : None , \"httpseeds\" : None , } self . outfile , self . meta = self . get_props () def get_props ( self ): \"\"\" Gather details for torrentfile from user. \"\"\" piece_length = get_input ( \"Piece Length (empty=auto): \" , lambda x : x . isdigit () ) self . kwargs [ \"piece_length\" ] = piece_length announce = get_input ( \"Tracker list (empty): \" , lambda x : isinstance ( x , str ) ) if announce : self . kwargs [ \"announce\" ] = announce . split () url_list = get_input ( \"Web Seed {GetRight} list (empty): \" , lambda x : isinstance ( x , str ) ) httpseeds = get_input ( \"Web Seed {Hoffman} list (empty): \" , lambda x : isinstance ( x , str ) ) if url_list : self . kwargs [ \"url_list\" ] = url_list . split () if httpseeds : self . kwargs [ \"httpseeds\" ] = httpseeds . split () comment = get_input ( \"Comment (empty): \" , None ) if comment : self . kwargs [ \"comment\" ] = comment source = get_input ( \"Source (empty): \" , None ) if source : self . kwargs [ \"source\" ] = source private = get_input ( \"Private Torrent? {Y/N}: (N)\" , lambda x : x in \"yYnN\" ) if private and private . lower () == \"y\" : self . kwargs [ \"private\" ] = 1 contents = get_input ( \"Content Path: \" , os . path . exists ) self . kwargs [ \"path\" ] = contents outfile = get_input ( f \"Output Path ( { contents } .torrent): \" , lambda x : os . path . exists ( os . path . dirname ( x )), ) if outfile : self . kwargs [ \"outfile\" ] = outfile meta_version = get_input ( \"Meta Version {1,2,3}: (1)\" , lambda x : x in \"123\" ) showcenter ( f \"creating { outfile } \" ) if meta_version == \"3\" : torrent = TorrentFileHybrid ( ** self . kwargs ) elif meta_version == \"2\" : torrent = TorrentFileV2 ( ** self . kwargs ) else : torrent = TorrentFile ( ** self . kwargs ) return torrent . write () __init__ () \u00a4 Initialize interactive meta file creator dialog. Source code in torrentfile\\interactive.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 def __init__ ( self ): \"\"\" Initialize interactive meta file creator dialog. \"\"\" self . kwargs = { \"announce\" : None , \"url_list\" : None , \"private\" : None , \"source\" : None , \"comment\" : None , \"piece_length\" : None , \"outfile\" : None , \"path\" : None , \"httpseeds\" : None , } self . outfile , self . meta = self . get_props () get_props () \u00a4 Gather details for torrentfile from user. Source code in torrentfile\\interactive.py 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 def get_props ( self ): \"\"\" Gather details for torrentfile from user. \"\"\" piece_length = get_input ( \"Piece Length (empty=auto): \" , lambda x : x . isdigit () ) self . kwargs [ \"piece_length\" ] = piece_length announce = get_input ( \"Tracker list (empty): \" , lambda x : isinstance ( x , str ) ) if announce : self . kwargs [ \"announce\" ] = announce . split () url_list = get_input ( \"Web Seed {GetRight} list (empty): \" , lambda x : isinstance ( x , str ) ) httpseeds = get_input ( \"Web Seed {Hoffman} list (empty): \" , lambda x : isinstance ( x , str ) ) if url_list : self . kwargs [ \"url_list\" ] = url_list . split () if httpseeds : self . kwargs [ \"httpseeds\" ] = httpseeds . split () comment = get_input ( \"Comment (empty): \" , None ) if comment : self . kwargs [ \"comment\" ] = comment source = get_input ( \"Source (empty): \" , None ) if source : self . kwargs [ \"source\" ] = source private = get_input ( \"Private Torrent? {Y/N}: (N)\" , lambda x : x in \"yYnN\" ) if private and private . lower () == \"y\" : self . kwargs [ \"private\" ] = 1 contents = get_input ( \"Content Path: \" , os . path . exists ) self . kwargs [ \"path\" ] = contents outfile = get_input ( f \"Output Path ( { contents } .torrent): \" , lambda x : os . path . exists ( os . path . dirname ( x )), ) if outfile : self . kwargs [ \"outfile\" ] = outfile meta_version = get_input ( \"Meta Version {1,2,3}: (1)\" , lambda x : x in \"123\" ) showcenter ( f \"creating { outfile } \" ) if meta_version == \"3\" : torrent = TorrentFileHybrid ( ** self . kwargs ) elif meta_version == \"2\" : torrent = TorrentFileV2 ( ** self . kwargs ) else : torrent = TorrentFile ( ** self . kwargs ) return torrent . write () InteractiveEditor \u00a4 Interactive dialog class for torrent editing. Source code in torrentfile\\interactive.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 class InteractiveEditor : \"\"\" Interactive dialog class for torrent editing. \"\"\" def __init__ ( self , metafile : str ): \"\"\" Initialize the Interactive torrent editor guide. Parameters ---------- metafile : str user input string identifying the path to a torrent meta file. \"\"\" self . metafile = metafile self . meta = pyben . load ( metafile ) self . info = self . meta [ \"info\" ] self . args = { \"url-list\" : self . meta . get ( \"url-list\" , None ), \"httpseeds\" : self . meta . get ( \"httpseeds\" , None ), \"announce\" : self . meta . get ( \"announce-list\" , None ), \"source\" : self . info . get ( \"source\" , None ), \"private\" : self . info . get ( \"private\" , None ), \"comment\" : self . info . get ( \"comment\" , None ), } def show_current ( self ): \"\"\" Display the current met file information to screen. \"\"\" out = \"Current properties and values: \\n \" longest = max ( len ( label ) for label in self . args ) + 3 for key , val in self . args . items (): txt = ( key . title () + \":\" ) . ljust ( longest ) + str ( val ) out += f \" \\t { txt } \\n \" showtext ( out ) def sanatize_response ( self , key , response ): \"\"\" Convert the input data into a form recognizable by the program. Parameters ---------- key : str name of the property and attribute being eddited. response : str User input value the property is being edited to. \"\"\" if key in [ \"announce\" , \"url-list\" , \"httpseeds\" ]: val = response . split () else : val = response self . args [ key ] = val def edit_props ( self ): \"\"\" Loop continuosly for edits until user signals DONE. \"\"\" while True : showcenter ( \"Choose the number for a propert the needs editing.\" \"Enter DONE when all editing has been completed.\" ) props = { 1 : \"comment\" , 2 : \"source\" , 3 : \"private\" , 4 : \"tracker\" , 5 : \"web-seed\" , 6 : \"httpseeds\" , } args = { 1 : \"comment\" , 2 : \"source\" , 3 : \"private\" , 4 : \"announce\" , 5 : \"url-list\" , 6 : \"httpseeds\" , } txt = \", \" . join (( str ( k ) + \": \" + v ) for k , v in props . items ()) prop = get_input ( txt ) if prop . lower () == \"done\" : break if prop . isdigit () and 0 < int ( prop ) < 6 : key = props [ int ( prop )] key2 = args [ int ( prop )] val = self . args . get ( key2 ) showtext ( \"Enter new property value or leave empty for no value.\" ) response = get_input ( f \" { key . title () } ( { val } ): \" ) self . sanatize_response ( key2 , response ) else : showtext ( \"Invalid input: Try again.\" ) edit_torrent ( self . metafile , self . args ) __init__ ( metafile ) \u00a4 Initialize the Interactive torrent editor guide. Parameters \u00a4 str user input string identifying the path to a torrent meta file. Source code in torrentfile\\interactive.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def __init__ ( self , metafile : str ): \"\"\" Initialize the Interactive torrent editor guide. Parameters ---------- metafile : str user input string identifying the path to a torrent meta file. \"\"\" self . metafile = metafile self . meta = pyben . load ( metafile ) self . info = self . meta [ \"info\" ] self . args = { \"url-list\" : self . meta . get ( \"url-list\" , None ), \"httpseeds\" : self . meta . get ( \"httpseeds\" , None ), \"announce\" : self . meta . get ( \"announce-list\" , None ), \"source\" : self . info . get ( \"source\" , None ), \"private\" : self . info . get ( \"private\" , None ), \"comment\" : self . info . get ( \"comment\" , None ), } edit_props () \u00a4 Loop continuosly for edits until user signals DONE. Source code in torrentfile\\interactive.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 def edit_props ( self ): \"\"\" Loop continuosly for edits until user signals DONE. \"\"\" while True : showcenter ( \"Choose the number for a propert the needs editing.\" \"Enter DONE when all editing has been completed.\" ) props = { 1 : \"comment\" , 2 : \"source\" , 3 : \"private\" , 4 : \"tracker\" , 5 : \"web-seed\" , 6 : \"httpseeds\" , } args = { 1 : \"comment\" , 2 : \"source\" , 3 : \"private\" , 4 : \"announce\" , 5 : \"url-list\" , 6 : \"httpseeds\" , } txt = \", \" . join (( str ( k ) + \": \" + v ) for k , v in props . items ()) prop = get_input ( txt ) if prop . lower () == \"done\" : break if prop . isdigit () and 0 < int ( prop ) < 6 : key = props [ int ( prop )] key2 = args [ int ( prop )] val = self . args . get ( key2 ) showtext ( \"Enter new property value or leave empty for no value.\" ) response = get_input ( f \" { key . title () } ( { val } ): \" ) self . sanatize_response ( key2 , response ) else : showtext ( \"Invalid input: Try again.\" ) edit_torrent ( self . metafile , self . args ) sanatize_response ( key , response ) \u00a4 Convert the input data into a form recognizable by the program. Parameters \u00a4 str name of the property and attribute being eddited. str User input value the property is being edited to. Source code in torrentfile\\interactive.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def sanatize_response ( self , key , response ): \"\"\" Convert the input data into a form recognizable by the program. Parameters ---------- key : str name of the property and attribute being eddited. response : str User input value the property is being edited to. \"\"\" if key in [ \"announce\" , \"url-list\" , \"httpseeds\" ]: val = response . split () else : val = response self . args [ key ] = val show_current () \u00a4 Display the current met file information to screen. Source code in torrentfile\\interactive.py 217 218 219 220 221 222 223 224 225 226 def show_current ( self ): \"\"\" Display the current met file information to screen. \"\"\" out = \"Current properties and values: \\n \" longest = max ( len ( label ) for label in self . args ) + 3 for key , val in self . args . items (): txt = ( key . title () + \":\" ) . ljust ( longest ) + str ( val ) out += f \" \\t { txt } \\n \" showtext ( out ) _get_input ( txt ) \u00a4 Gather information needed from user. Parameters \u00a4 str The message usually containing instructions for the user. Returns \u00a4 str The text input received from the user. Source code in torrentfile\\interactive.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def _get_input ( txt : str ): # pragma: no cover \"\"\" Gather information needed from user. Parameters ---------- txt : str The message usually containing instructions for the user. Returns ------- str The text input received from the user. \"\"\" value = input ( txt ) return value _get_input_loop ( txt , func ) \u00a4 Gather information needed from user. Parameters \u00a4 str The message usually containing instructions for the user. function Validate/Check user input data, failure = retry, success = continue. Returns \u00a4 str The text input received from the user. Source code in torrentfile\\interactive.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def _get_input_loop ( txt : str , func ): # pragma: no cover \"\"\" Gather information needed from user. Parameters ---------- txt : str The message usually containing instructions for the user. func : function Validate/Check user input data, failure = retry, success = continue. Returns ------- str The text input received from the user. \"\"\" while True : value = input ( txt ) if func and func ( value ): return value if not func or value == \"\" : return value showtext ( f \"Invalid input { value } : try again\" ) create_torrent () \u00a4 Create new torrent file interactively. Source code in torrentfile\\interactive.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 def create_torrent (): \"\"\" Create new torrent file interactively. \"\"\" showcenter ( \"Create Torrent\" ) showtext ( \" \\n Enter values for each of the options for the torrent creator, \" \"or leave blank for program defaults. \\n Spaces are considered item \" \"seperators for options that accept a list of values. \\n Values \" \"enclosed in () indicate the default value, while {} holds all \" \"valid choices available for the option. \\n\\n \" ) creator = InteractiveCreator () return creator edit_action () \u00a4 Edit the editable values of the torrent meta file. Source code in torrentfile\\interactive.py 179 180 181 182 183 184 185 186 187 def edit_action (): \"\"\" Edit the editable values of the torrent meta file. \"\"\" showcenter ( \"Edit Torrent\" ) metafile = get_input ( \"Metafile(.torrent): \" , os . path . exists ) dialog = InteractiveEditor ( metafile ) dialog . show_current () dialog . edit_props () get_input ( * args ) \u00a4 Determine appropriate input function to call. Parameters \u00a4 *args : tuple Arbitrary number of args to pass to next function Returns \u00a4 str The results of the function call. Source code in torrentfile\\interactive.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def get_input ( * args : tuple ): # pragma: no cover \"\"\" Determine appropriate input function to call. Parameters ---------- *args : tuple Arbitrary number of args to pass to next function Returns ------- str The results of the function call. \"\"\" if len ( args ) == 2 : return _get_input_loop ( * args ) return _get_input ( * args ) recheck_torrent () \u00a4 Check torrent download completed percentage. Source code in torrentfile\\interactive.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def recheck_torrent (): \"\"\" Check torrent download completed percentage. \"\"\" showcenter ( \"Check Torrent\" ) msg = \"Enter path to torrent contents, and corresponding torrent metafile.\" showtext ( msg ) metafile = get_input ( \"Conent Path (downloads/complete/torrentname):\" , os . path . exists ) contents = get_input ( \"Metafile (*.torrent): \" , os . path . exists ) checker = Checker ( metafile , contents ) results = checker . results () showtext ( f \"Completion for { metafile } is { results } %\" ) return results select_action () \u00a4 Operate TorrentFile program interactively through terminal. Source code in torrentfile\\interactive.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def select_action (): \"\"\" Operate TorrentFile program interactively through terminal. \"\"\" showcenter ( \"TorrentFile: Starting Interactive Mode\" ) action = get_input ( \"Enter the action you wish to perform. \\n \" \"Action ( Create (c) | Edit (e) | Recheck (r) ): \" ) action = action . lower () if \"create\" in action or action == \"c\" : return create_torrent () if \"check\" in action or action == \"r\" : return recheck_torrent () if \"edit\" in action or action == \"e\" : return edit_action () print ( \"Unable to recognize input. Please try again.\" ) # pragma: nocover return select_action () # pragma: nocover showcenter ( txt ) \u00a4 Print text to screen in the center position of the terminal. Parameters \u00a4 str the preformated message to send to stdout. Source code in torrentfile\\interactive.py 108 109 110 111 112 113 114 115 116 117 118 119 120 def showcenter ( txt : str ): \"\"\" Print text to screen in the center position of the terminal. Parameters ---------- txt : str the preformated message to send to stdout. \"\"\" termlen = shutil . get_terminal_size () . columns padding = \" \" * int ((( termlen - len ( txt )) / 2 )) string = \"\" . join ([ \" \\n \" , padding , txt , \" \\n \" ]) showtext ( string ) showtext ( txt ) \u00a4 Print contents of txt to screen. Parameters \u00a4 str text to print to terminal. Source code in torrentfile\\interactive.py 96 97 98 99 100 101 102 103 104 105 def showtext ( txt ): \"\"\" Print contents of txt to screen. Parameters ---------- txt : str text to print to terminal. \"\"\" sys . stdout . write ( txt )","title":"interactive"},{"location":"interactive/#torrentfile.interactive.InteractiveCreator","text":"Class namespace for interactive program options. Source code in torrentfile\\interactive.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 class InteractiveCreator : \"\"\" Class namespace for interactive program options. \"\"\" def __init__ ( self ): \"\"\" Initialize interactive meta file creator dialog. \"\"\" self . kwargs = { \"announce\" : None , \"url_list\" : None , \"private\" : None , \"source\" : None , \"comment\" : None , \"piece_length\" : None , \"outfile\" : None , \"path\" : None , \"httpseeds\" : None , } self . outfile , self . meta = self . get_props () def get_props ( self ): \"\"\" Gather details for torrentfile from user. \"\"\" piece_length = get_input ( \"Piece Length (empty=auto): \" , lambda x : x . isdigit () ) self . kwargs [ \"piece_length\" ] = piece_length announce = get_input ( \"Tracker list (empty): \" , lambda x : isinstance ( x , str ) ) if announce : self . kwargs [ \"announce\" ] = announce . split () url_list = get_input ( \"Web Seed {GetRight} list (empty): \" , lambda x : isinstance ( x , str ) ) httpseeds = get_input ( \"Web Seed {Hoffman} list (empty): \" , lambda x : isinstance ( x , str ) ) if url_list : self . kwargs [ \"url_list\" ] = url_list . split () if httpseeds : self . kwargs [ \"httpseeds\" ] = httpseeds . split () comment = get_input ( \"Comment (empty): \" , None ) if comment : self . kwargs [ \"comment\" ] = comment source = get_input ( \"Source (empty): \" , None ) if source : self . kwargs [ \"source\" ] = source private = get_input ( \"Private Torrent? {Y/N}: (N)\" , lambda x : x in \"yYnN\" ) if private and private . lower () == \"y\" : self . kwargs [ \"private\" ] = 1 contents = get_input ( \"Content Path: \" , os . path . exists ) self . kwargs [ \"path\" ] = contents outfile = get_input ( f \"Output Path ( { contents } .torrent): \" , lambda x : os . path . exists ( os . path . dirname ( x )), ) if outfile : self . kwargs [ \"outfile\" ] = outfile meta_version = get_input ( \"Meta Version {1,2,3}: (1)\" , lambda x : x in \"123\" ) showcenter ( f \"creating { outfile } \" ) if meta_version == \"3\" : torrent = TorrentFileHybrid ( ** self . kwargs ) elif meta_version == \"2\" : torrent = TorrentFileV2 ( ** self . kwargs ) else : torrent = TorrentFile ( ** self . kwargs ) return torrent . write ()","title":"InteractiveCreator"},{"location":"interactive/#torrentfile.interactive.InteractiveCreator.__init__","text":"Initialize interactive meta file creator dialog. Source code in torrentfile\\interactive.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 def __init__ ( self ): \"\"\" Initialize interactive meta file creator dialog. \"\"\" self . kwargs = { \"announce\" : None , \"url_list\" : None , \"private\" : None , \"source\" : None , \"comment\" : None , \"piece_length\" : None , \"outfile\" : None , \"path\" : None , \"httpseeds\" : None , } self . outfile , self . meta = self . get_props ()","title":"__init__()"},{"location":"interactive/#torrentfile.interactive.InteractiveCreator.get_props","text":"Gather details for torrentfile from user. Source code in torrentfile\\interactive.py 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 def get_props ( self ): \"\"\" Gather details for torrentfile from user. \"\"\" piece_length = get_input ( \"Piece Length (empty=auto): \" , lambda x : x . isdigit () ) self . kwargs [ \"piece_length\" ] = piece_length announce = get_input ( \"Tracker list (empty): \" , lambda x : isinstance ( x , str ) ) if announce : self . kwargs [ \"announce\" ] = announce . split () url_list = get_input ( \"Web Seed {GetRight} list (empty): \" , lambda x : isinstance ( x , str ) ) httpseeds = get_input ( \"Web Seed {Hoffman} list (empty): \" , lambda x : isinstance ( x , str ) ) if url_list : self . kwargs [ \"url_list\" ] = url_list . split () if httpseeds : self . kwargs [ \"httpseeds\" ] = httpseeds . split () comment = get_input ( \"Comment (empty): \" , None ) if comment : self . kwargs [ \"comment\" ] = comment source = get_input ( \"Source (empty): \" , None ) if source : self . kwargs [ \"source\" ] = source private = get_input ( \"Private Torrent? {Y/N}: (N)\" , lambda x : x in \"yYnN\" ) if private and private . lower () == \"y\" : self . kwargs [ \"private\" ] = 1 contents = get_input ( \"Content Path: \" , os . path . exists ) self . kwargs [ \"path\" ] = contents outfile = get_input ( f \"Output Path ( { contents } .torrent): \" , lambda x : os . path . exists ( os . path . dirname ( x )), ) if outfile : self . kwargs [ \"outfile\" ] = outfile meta_version = get_input ( \"Meta Version {1,2,3}: (1)\" , lambda x : x in \"123\" ) showcenter ( f \"creating { outfile } \" ) if meta_version == \"3\" : torrent = TorrentFileHybrid ( ** self . kwargs ) elif meta_version == \"2\" : torrent = TorrentFileV2 ( ** self . kwargs ) else : torrent = TorrentFile ( ** self . kwargs ) return torrent . write ()","title":"get_props()"},{"location":"interactive/#torrentfile.interactive.InteractiveEditor","text":"Interactive dialog class for torrent editing. Source code in torrentfile\\interactive.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 class InteractiveEditor : \"\"\" Interactive dialog class for torrent editing. \"\"\" def __init__ ( self , metafile : str ): \"\"\" Initialize the Interactive torrent editor guide. Parameters ---------- metafile : str user input string identifying the path to a torrent meta file. \"\"\" self . metafile = metafile self . meta = pyben . load ( metafile ) self . info = self . meta [ \"info\" ] self . args = { \"url-list\" : self . meta . get ( \"url-list\" , None ), \"httpseeds\" : self . meta . get ( \"httpseeds\" , None ), \"announce\" : self . meta . get ( \"announce-list\" , None ), \"source\" : self . info . get ( \"source\" , None ), \"private\" : self . info . get ( \"private\" , None ), \"comment\" : self . info . get ( \"comment\" , None ), } def show_current ( self ): \"\"\" Display the current met file information to screen. \"\"\" out = \"Current properties and values: \\n \" longest = max ( len ( label ) for label in self . args ) + 3 for key , val in self . args . items (): txt = ( key . title () + \":\" ) . ljust ( longest ) + str ( val ) out += f \" \\t { txt } \\n \" showtext ( out ) def sanatize_response ( self , key , response ): \"\"\" Convert the input data into a form recognizable by the program. Parameters ---------- key : str name of the property and attribute being eddited. response : str User input value the property is being edited to. \"\"\" if key in [ \"announce\" , \"url-list\" , \"httpseeds\" ]: val = response . split () else : val = response self . args [ key ] = val def edit_props ( self ): \"\"\" Loop continuosly for edits until user signals DONE. \"\"\" while True : showcenter ( \"Choose the number for a propert the needs editing.\" \"Enter DONE when all editing has been completed.\" ) props = { 1 : \"comment\" , 2 : \"source\" , 3 : \"private\" , 4 : \"tracker\" , 5 : \"web-seed\" , 6 : \"httpseeds\" , } args = { 1 : \"comment\" , 2 : \"source\" , 3 : \"private\" , 4 : \"announce\" , 5 : \"url-list\" , 6 : \"httpseeds\" , } txt = \", \" . join (( str ( k ) + \": \" + v ) for k , v in props . items ()) prop = get_input ( txt ) if prop . lower () == \"done\" : break if prop . isdigit () and 0 < int ( prop ) < 6 : key = props [ int ( prop )] key2 = args [ int ( prop )] val = self . args . get ( key2 ) showtext ( \"Enter new property value or leave empty for no value.\" ) response = get_input ( f \" { key . title () } ( { val } ): \" ) self . sanatize_response ( key2 , response ) else : showtext ( \"Invalid input: Try again.\" ) edit_torrent ( self . metafile , self . args )","title":"InteractiveEditor"},{"location":"interactive/#torrentfile.interactive.InteractiveEditor.__init__","text":"Initialize the Interactive torrent editor guide.","title":"__init__()"},{"location":"interactive/#torrentfile.interactive.InteractiveEditor.__init__--parameters","text":"str user input string identifying the path to a torrent meta file. Source code in torrentfile\\interactive.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def __init__ ( self , metafile : str ): \"\"\" Initialize the Interactive torrent editor guide. Parameters ---------- metafile : str user input string identifying the path to a torrent meta file. \"\"\" self . metafile = metafile self . meta = pyben . load ( metafile ) self . info = self . meta [ \"info\" ] self . args = { \"url-list\" : self . meta . get ( \"url-list\" , None ), \"httpseeds\" : self . meta . get ( \"httpseeds\" , None ), \"announce\" : self . meta . get ( \"announce-list\" , None ), \"source\" : self . info . get ( \"source\" , None ), \"private\" : self . info . get ( \"private\" , None ), \"comment\" : self . info . get ( \"comment\" , None ), }","title":"Parameters"},{"location":"interactive/#torrentfile.interactive.InteractiveEditor.edit_props","text":"Loop continuosly for edits until user signals DONE. Source code in torrentfile\\interactive.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 def edit_props ( self ): \"\"\" Loop continuosly for edits until user signals DONE. \"\"\" while True : showcenter ( \"Choose the number for a propert the needs editing.\" \"Enter DONE when all editing has been completed.\" ) props = { 1 : \"comment\" , 2 : \"source\" , 3 : \"private\" , 4 : \"tracker\" , 5 : \"web-seed\" , 6 : \"httpseeds\" , } args = { 1 : \"comment\" , 2 : \"source\" , 3 : \"private\" , 4 : \"announce\" , 5 : \"url-list\" , 6 : \"httpseeds\" , } txt = \", \" . join (( str ( k ) + \": \" + v ) for k , v in props . items ()) prop = get_input ( txt ) if prop . lower () == \"done\" : break if prop . isdigit () and 0 < int ( prop ) < 6 : key = props [ int ( prop )] key2 = args [ int ( prop )] val = self . args . get ( key2 ) showtext ( \"Enter new property value or leave empty for no value.\" ) response = get_input ( f \" { key . title () } ( { val } ): \" ) self . sanatize_response ( key2 , response ) else : showtext ( \"Invalid input: Try again.\" ) edit_torrent ( self . metafile , self . args )","title":"edit_props()"},{"location":"interactive/#torrentfile.interactive.InteractiveEditor.sanatize_response","text":"Convert the input data into a form recognizable by the program.","title":"sanatize_response()"},{"location":"interactive/#torrentfile.interactive.InteractiveEditor.sanatize_response--parameters","text":"str name of the property and attribute being eddited. str User input value the property is being edited to. Source code in torrentfile\\interactive.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def sanatize_response ( self , key , response ): \"\"\" Convert the input data into a form recognizable by the program. Parameters ---------- key : str name of the property and attribute being eddited. response : str User input value the property is being edited to. \"\"\" if key in [ \"announce\" , \"url-list\" , \"httpseeds\" ]: val = response . split () else : val = response self . args [ key ] = val","title":"Parameters"},{"location":"interactive/#torrentfile.interactive.InteractiveEditor.show_current","text":"Display the current met file information to screen. Source code in torrentfile\\interactive.py 217 218 219 220 221 222 223 224 225 226 def show_current ( self ): \"\"\" Display the current met file information to screen. \"\"\" out = \"Current properties and values: \\n \" longest = max ( len ( label ) for label in self . args ) + 3 for key , val in self . args . items (): txt = ( key . title () + \":\" ) . ljust ( longest ) + str ( val ) out += f \" \\t { txt } \\n \" showtext ( out )","title":"show_current()"},{"location":"interactive/#torrentfile.interactive._get_input","text":"Gather information needed from user.","title":"_get_input()"},{"location":"interactive/#torrentfile.interactive._get_input--parameters","text":"str The message usually containing instructions for the user.","title":"Parameters"},{"location":"interactive/#torrentfile.interactive._get_input--returns","text":"str The text input received from the user. Source code in torrentfile\\interactive.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def _get_input ( txt : str ): # pragma: no cover \"\"\" Gather information needed from user. Parameters ---------- txt : str The message usually containing instructions for the user. Returns ------- str The text input received from the user. \"\"\" value = input ( txt ) return value","title":"Returns"},{"location":"interactive/#torrentfile.interactive._get_input_loop","text":"Gather information needed from user.","title":"_get_input_loop()"},{"location":"interactive/#torrentfile.interactive._get_input_loop--parameters","text":"str The message usually containing instructions for the user. function Validate/Check user input data, failure = retry, success = continue.","title":"Parameters"},{"location":"interactive/#torrentfile.interactive._get_input_loop--returns","text":"str The text input received from the user. Source code in torrentfile\\interactive.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def _get_input_loop ( txt : str , func ): # pragma: no cover \"\"\" Gather information needed from user. Parameters ---------- txt : str The message usually containing instructions for the user. func : function Validate/Check user input data, failure = retry, success = continue. Returns ------- str The text input received from the user. \"\"\" while True : value = input ( txt ) if func and func ( value ): return value if not func or value == \"\" : return value showtext ( f \"Invalid input { value } : try again\" )","title":"Returns"},{"location":"interactive/#torrentfile.interactive.create_torrent","text":"Create new torrent file interactively. Source code in torrentfile\\interactive.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 def create_torrent (): \"\"\" Create new torrent file interactively. \"\"\" showcenter ( \"Create Torrent\" ) showtext ( \" \\n Enter values for each of the options for the torrent creator, \" \"or leave blank for program defaults. \\n Spaces are considered item \" \"seperators for options that accept a list of values. \\n Values \" \"enclosed in () indicate the default value, while {} holds all \" \"valid choices available for the option. \\n\\n \" ) creator = InteractiveCreator () return creator","title":"create_torrent()"},{"location":"interactive/#torrentfile.interactive.edit_action","text":"Edit the editable values of the torrent meta file. Source code in torrentfile\\interactive.py 179 180 181 182 183 184 185 186 187 def edit_action (): \"\"\" Edit the editable values of the torrent meta file. \"\"\" showcenter ( \"Edit Torrent\" ) metafile = get_input ( \"Metafile(.torrent): \" , os . path . exists ) dialog = InteractiveEditor ( metafile ) dialog . show_current () dialog . edit_props ()","title":"edit_action()"},{"location":"interactive/#torrentfile.interactive.get_input","text":"Determine appropriate input function to call.","title":"get_input()"},{"location":"interactive/#torrentfile.interactive.get_input--parameters","text":"*args : tuple Arbitrary number of args to pass to next function","title":"Parameters"},{"location":"interactive/#torrentfile.interactive.get_input--returns","text":"str The results of the function call. Source code in torrentfile\\interactive.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def get_input ( * args : tuple ): # pragma: no cover \"\"\" Determine appropriate input function to call. Parameters ---------- *args : tuple Arbitrary number of args to pass to next function Returns ------- str The results of the function call. \"\"\" if len ( args ) == 2 : return _get_input_loop ( * args ) return _get_input ( * args )","title":"Returns"},{"location":"interactive/#torrentfile.interactive.recheck_torrent","text":"Check torrent download completed percentage. Source code in torrentfile\\interactive.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def recheck_torrent (): \"\"\" Check torrent download completed percentage. \"\"\" showcenter ( \"Check Torrent\" ) msg = \"Enter path to torrent contents, and corresponding torrent metafile.\" showtext ( msg ) metafile = get_input ( \"Conent Path (downloads/complete/torrentname):\" , os . path . exists ) contents = get_input ( \"Metafile (*.torrent): \" , os . path . exists ) checker = Checker ( metafile , contents ) results = checker . results () showtext ( f \"Completion for { metafile } is { results } %\" ) return results","title":"recheck_torrent()"},{"location":"interactive/#torrentfile.interactive.select_action","text":"Operate TorrentFile program interactively through terminal. Source code in torrentfile\\interactive.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def select_action (): \"\"\" Operate TorrentFile program interactively through terminal. \"\"\" showcenter ( \"TorrentFile: Starting Interactive Mode\" ) action = get_input ( \"Enter the action you wish to perform. \\n \" \"Action ( Create (c) | Edit (e) | Recheck (r) ): \" ) action = action . lower () if \"create\" in action or action == \"c\" : return create_torrent () if \"check\" in action or action == \"r\" : return recheck_torrent () if \"edit\" in action or action == \"e\" : return edit_action () print ( \"Unable to recognize input. Please try again.\" ) # pragma: nocover return select_action () # pragma: nocover","title":"select_action()"},{"location":"interactive/#torrentfile.interactive.showcenter","text":"Print text to screen in the center position of the terminal.","title":"showcenter()"},{"location":"interactive/#torrentfile.interactive.showcenter--parameters","text":"str the preformated message to send to stdout. Source code in torrentfile\\interactive.py 108 109 110 111 112 113 114 115 116 117 118 119 120 def showcenter ( txt : str ): \"\"\" Print text to screen in the center position of the terminal. Parameters ---------- txt : str the preformated message to send to stdout. \"\"\" termlen = shutil . get_terminal_size () . columns padding = \" \" * int ((( termlen - len ( txt )) / 2 )) string = \"\" . join ([ \" \\n \" , padding , txt , \" \\n \" ]) showtext ( string )","title":"Parameters"},{"location":"interactive/#torrentfile.interactive.showtext","text":"Print contents of txt to screen.","title":"showtext()"},{"location":"interactive/#torrentfile.interactive.showtext--parameters","text":"str text to print to terminal. Source code in torrentfile\\interactive.py 96 97 98 99 100 101 102 103 104 105 def showtext ( txt ): \"\"\" Print contents of txt to screen. Parameters ---------- txt : str text to print to terminal. \"\"\" sys . stdout . write ( txt )","title":"Parameters"},{"location":"mixins/","text":"Collection of classes that can be used as Mixins with other base classes. Classes such as TorrentFile, TorrentFilev2, and all Hasher classes can use the progress bar mixin. And any class is eligible to use the callback mixin. CbMixin \u00a4 Mixin class to set a callback during hashing procedure. Source code in torrentfile\\mixins.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class CbMixin : \"\"\" Mixin class to set a callback during hashing procedure. \"\"\" _cb = None @classmethod def set_callback ( cls , func ): \"\"\" Assign a callback to the Hashing class. Parameters ---------- func : Callable the callback function \"\"\" cls . _cb = func # pragma: nocover set_callback ( func ) classmethod \u00a4 Assign a callback to the Hashing class. Parameters \u00a4 Callable the callback function Source code in torrentfile\\mixins.py 40 41 42 43 44 45 46 47 48 49 50 @classmethod def set_callback ( cls , func ): \"\"\" Assign a callback to the Hashing class. Parameters ---------- func : Callable the callback function \"\"\" cls . _cb = func # pragma: nocover ProgMixin \u00a4 Progress bar mixin class. Displays progress of hashing individual files, usefull when hashing really big files. Methods \u00a4 prog_start prog_update prog_close Source code in torrentfile\\mixins.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 class ProgMixin : \"\"\" Progress bar mixin class. Displays progress of hashing individual files, usefull when hashing really big files. Methods ------- prog_start prog_update prog_close \"\"\" def prog_start ( self , total : int , path : str , length : int = 50 , unit : str = None ): \"\"\" Generate a new progress bar for the given file path. Parameters ---------- total : int the total amount of units accumulating towards. path : str path to file being hashed. length : int the number of characters of the actual progress bar. unit : str the text representation of the value being measured. \"\"\" title = path width = shutil . get_terminal_size () . columns if len ( str ( title )) >= width // 2 : parts = list ( Path ( title ) . parts ) while len ( \"//\" . join ( parts )) > width // 2 and len ( parts ) > 0 : del parts [ 0 ] title = os . path . join ( * parts ) length = min ( length , width // 2 ) start = width - int ( length * 1.5 ) self . prog = ProgressBar ( total , title , length , unit , start ) def prog_update ( self , val : int ): \"\"\" Update progress bar with given amount of progress. Parameters ---------- val : int the number of bytes count the progress bar should increase. \"\"\" if self . is_active (): self . prog . state += val pbar = self . prog . pbar () output = f \" { self . prog . prefix }{ pbar }{ self . prog . suffix } \\r \" sys . stdout . write ( output ) sys . stdout . flush () def prog_close ( self ): \"\"\" Finalize the last bits of progress bar. Increment the terminal by one line leaving the progress bar in place, and deleting the progress bar object to clear a space for the next one. \"\"\" if self . is_active (): sys . stdout . flush () sys . stdout . write ( \" \\n \" ) del self . prog def is_active ( self ) -> bool : \"\"\" Test to see if there is an active progress bar for object. Returns ------- bool : True if there is, otherwise False. \"\"\" if hasattr ( self , \"prog\" ): return True return False is_active () \u00a4 Test to see if there is an active progress bar for object. Returns \u00a4 bool True if there is, otherwise False. Source code in torrentfile\\mixins.py 199 200 201 202 203 204 205 206 207 208 209 210 def is_active ( self ) -> bool : \"\"\" Test to see if there is an active progress bar for object. Returns ------- bool : True if there is, otherwise False. \"\"\" if hasattr ( self , \"prog\" ): return True return False prog_close () \u00a4 Finalize the last bits of progress bar. Increment the terminal by one line leaving the progress bar in place, and deleting the progress bar object to clear a space for the next one. Source code in torrentfile\\mixins.py 187 188 189 190 191 192 193 194 195 196 197 def prog_close ( self ): \"\"\" Finalize the last bits of progress bar. Increment the terminal by one line leaving the progress bar in place, and deleting the progress bar object to clear a space for the next one. \"\"\" if self . is_active (): sys . stdout . flush () sys . stdout . write ( \" \\n \" ) del self . prog prog_start ( total , path , length = 50 , unit = None ) \u00a4 Generate a new progress bar for the given file path. Parameters \u00a4 int the total amount of units accumulating towards. str path to file being hashed. int the number of characters of the actual progress bar. str the text representation of the value being measured. Source code in torrentfile\\mixins.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def prog_start ( self , total : int , path : str , length : int = 50 , unit : str = None ): \"\"\" Generate a new progress bar for the given file path. Parameters ---------- total : int the total amount of units accumulating towards. path : str path to file being hashed. length : int the number of characters of the actual progress bar. unit : str the text representation of the value being measured. \"\"\" title = path width = shutil . get_terminal_size () . columns if len ( str ( title )) >= width // 2 : parts = list ( Path ( title ) . parts ) while len ( \"//\" . join ( parts )) > width // 2 and len ( parts ) > 0 : del parts [ 0 ] title = os . path . join ( * parts ) length = min ( length , width // 2 ) start = width - int ( length * 1.5 ) self . prog = ProgressBar ( total , title , length , unit , start ) prog_update ( val ) \u00a4 Update progress bar with given amount of progress. Parameters \u00a4 int the number of bytes count the progress bar should increase. Source code in torrentfile\\mixins.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def prog_update ( self , val : int ): \"\"\" Update progress bar with given amount of progress. Parameters ---------- val : int the number of bytes count the progress bar should increase. \"\"\" if self . is_active (): self . prog . state += val pbar = self . prog . pbar () output = f \" { self . prog . prefix }{ pbar }{ self . prog . suffix } \\r \" sys . stdout . write ( output ) sys . stdout . flush () ProgressBar \u00a4 Holds the state and details of the terminal progress bars. Parameters \u00a4 int the total amount to be accumulated. str the subject of the progress tracker int the width of the progress bar str the text representation incremented int column where the progress bar should be drawn Source code in torrentfile\\mixins.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class ProgressBar : \"\"\" Holds the state and details of the terminal progress bars. Parameters ---------- total : int the total amount to be accumulated. title : str the subject of the progress tracker length : int the width of the progress bar unit : str the text representation incremented start : int column where the progress bar should be drawn \"\"\" def __init__ ( self , total : int , title : str , length : int , unit : str , start : int ): \"\"\" Construct the progress bar object and store state of it's properties. \"\"\" self . total = total self . start = start self . length = length self . fill = chr ( 9608 ) self . empty = chr ( 9617 ) self . state = 0 self . unit = unit self . show_total = total if not unit : self . unit = \"\" # pragma: nocover elif unit == \"bytes\" : if self . total > 1_000_000_000 : self . show_total = math . floor ( self . total / ( 2 ** 30 )) self . unit = \"GiB\" elif self . total > 1_000_000 : self . show_total = math . floor ( self . total / 1048576 ) self . unit = \"MiB\" elif self . total > 10000 : self . show_total = math . floor ( self . total / 1024 ) self . unit = \"KiB\" self . suffix = f \"/ { self . show_total } { self . unit } \" if len ( title ) > start : title = title [: start - 1 ] padding = ( start - len ( title )) * \" \" self . prefix = \"\" . join ([ title , padding ]) def pbar ( self ) -> str : \"\"\" Return the size of the filled portion of the progress bar. Returns ------- str : the progress bar characters \"\"\" if self . state >= self . total : fill = self . length else : fill = math . ceil (( self . state / self . total ) * self . length ) empt = self . length - fill if self . unit == \"GiB\" : state = math . floor ( self . state / ( 2 ** 30 )) elif self . unit == \"MiB\" : state = math . floor ( self . state / 1048576 ) elif self . unit == \"KiB\" : state = math . floor ( self . state / 1024 ) else : state = self . state progbar = [ \"|\" , self . fill * fill , self . empty * empt , \"| \" , str ( state )] return \"\" . join ( progbar ) __init__ ( total , title , length , unit , start ) \u00a4 Construct the progress bar object and store state of it's properties. Source code in torrentfile\\mixins.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def __init__ ( self , total : int , title : str , length : int , unit : str , start : int ): \"\"\" Construct the progress bar object and store state of it's properties. \"\"\" self . total = total self . start = start self . length = length self . fill = chr ( 9608 ) self . empty = chr ( 9617 ) self . state = 0 self . unit = unit self . show_total = total if not unit : self . unit = \"\" # pragma: nocover elif unit == \"bytes\" : if self . total > 1_000_000_000 : self . show_total = math . floor ( self . total / ( 2 ** 30 )) self . unit = \"GiB\" elif self . total > 1_000_000 : self . show_total = math . floor ( self . total / 1048576 ) self . unit = \"MiB\" elif self . total > 10000 : self . show_total = math . floor ( self . total / 1024 ) self . unit = \"KiB\" self . suffix = f \"/ { self . show_total } { self . unit } \" if len ( title ) > start : title = title [: start - 1 ] padding = ( start - len ( title )) * \" \" self . prefix = \"\" . join ([ title , padding ]) pbar () \u00a4 Return the size of the filled portion of the progress bar. Returns \u00a4 str the progress bar characters Source code in torrentfile\\mixins.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def pbar ( self ) -> str : \"\"\" Return the size of the filled portion of the progress bar. Returns ------- str : the progress bar characters \"\"\" if self . state >= self . total : fill = self . length else : fill = math . ceil (( self . state / self . total ) * self . length ) empt = self . length - fill if self . unit == \"GiB\" : state = math . floor ( self . state / ( 2 ** 30 )) elif self . unit == \"MiB\" : state = math . floor ( self . state / 1048576 ) elif self . unit == \"KiB\" : state = math . floor ( self . state / 1024 ) else : state = self . state progbar = [ \"|\" , self . fill * fill , self . empty * empt , \"| \" , str ( state )] return \"\" . join ( progbar ) waiting ( msg , flag , timeout = 20 ) \u00a4 Show loading message while thread completes processing. Parameters \u00a4 str Message string printed before the progress bar list Once flag is filled exit loop int max amount of time to run the function. Source code in torrentfile\\mixins.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def waiting ( msg : str , flag : list , timeout : int = 20 ): \"\"\" Show loading message while thread completes processing. Parameters ---------- msg : str Message string printed before the progress bar flag : list Once flag is filled exit loop timeout : int max amount of time to run the function. \"\"\" then = time . time () codes , fill = list ( range ( 9617 , 9620 )), chr ( 9619 ) size = idx = 0 total = shutil . get_terminal_size () . columns - len ( msg ) - 20 def output ( text : str ): \"\"\" Print parameter message to the console. Parameters ---------- text : str output message \"\"\" sys . stdout . write ( text ) sys . stdout . flush () output ( \" \\n \" ) time . sleep ( 0.16 ) while len ( flag ) == 0 : time . sleep ( 0.16 ) filled = ( fill * size ) + chr ( codes [ idx ]) + ( \" \" * ( total - size )) output ( f \" { msg } : { filled } \\r \" ) idx = idx + 1 if idx + 1 < len ( codes ) else 0 size = size + 1 if size < total else 0 if time . time () - then > timeout : break output ( \" \\n \" )","title":"mixins"},{"location":"mixins/#torrentfile.mixins.CbMixin","text":"Mixin class to set a callback during hashing procedure. Source code in torrentfile\\mixins.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class CbMixin : \"\"\" Mixin class to set a callback during hashing procedure. \"\"\" _cb = None @classmethod def set_callback ( cls , func ): \"\"\" Assign a callback to the Hashing class. Parameters ---------- func : Callable the callback function \"\"\" cls . _cb = func # pragma: nocover","title":"CbMixin"},{"location":"mixins/#torrentfile.mixins.CbMixin.set_callback","text":"Assign a callback to the Hashing class.","title":"set_callback()"},{"location":"mixins/#torrentfile.mixins.CbMixin.set_callback--parameters","text":"Callable the callback function Source code in torrentfile\\mixins.py 40 41 42 43 44 45 46 47 48 49 50 @classmethod def set_callback ( cls , func ): \"\"\" Assign a callback to the Hashing class. Parameters ---------- func : Callable the callback function \"\"\" cls . _cb = func # pragma: nocover","title":"Parameters"},{"location":"mixins/#torrentfile.mixins.ProgMixin","text":"Progress bar mixin class. Displays progress of hashing individual files, usefull when hashing really big files.","title":"ProgMixin"},{"location":"mixins/#torrentfile.mixins.ProgMixin--methods","text":"prog_start prog_update prog_close Source code in torrentfile\\mixins.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 class ProgMixin : \"\"\" Progress bar mixin class. Displays progress of hashing individual files, usefull when hashing really big files. Methods ------- prog_start prog_update prog_close \"\"\" def prog_start ( self , total : int , path : str , length : int = 50 , unit : str = None ): \"\"\" Generate a new progress bar for the given file path. Parameters ---------- total : int the total amount of units accumulating towards. path : str path to file being hashed. length : int the number of characters of the actual progress bar. unit : str the text representation of the value being measured. \"\"\" title = path width = shutil . get_terminal_size () . columns if len ( str ( title )) >= width // 2 : parts = list ( Path ( title ) . parts ) while len ( \"//\" . join ( parts )) > width // 2 and len ( parts ) > 0 : del parts [ 0 ] title = os . path . join ( * parts ) length = min ( length , width // 2 ) start = width - int ( length * 1.5 ) self . prog = ProgressBar ( total , title , length , unit , start ) def prog_update ( self , val : int ): \"\"\" Update progress bar with given amount of progress. Parameters ---------- val : int the number of bytes count the progress bar should increase. \"\"\" if self . is_active (): self . prog . state += val pbar = self . prog . pbar () output = f \" { self . prog . prefix }{ pbar }{ self . prog . suffix } \\r \" sys . stdout . write ( output ) sys . stdout . flush () def prog_close ( self ): \"\"\" Finalize the last bits of progress bar. Increment the terminal by one line leaving the progress bar in place, and deleting the progress bar object to clear a space for the next one. \"\"\" if self . is_active (): sys . stdout . flush () sys . stdout . write ( \" \\n \" ) del self . prog def is_active ( self ) -> bool : \"\"\" Test to see if there is an active progress bar for object. Returns ------- bool : True if there is, otherwise False. \"\"\" if hasattr ( self , \"prog\" ): return True return False","title":"Methods"},{"location":"mixins/#torrentfile.mixins.ProgMixin.is_active","text":"Test to see if there is an active progress bar for object.","title":"is_active()"},{"location":"mixins/#torrentfile.mixins.ProgMixin.is_active--returns","text":"bool True if there is, otherwise False. Source code in torrentfile\\mixins.py 199 200 201 202 203 204 205 206 207 208 209 210 def is_active ( self ) -> bool : \"\"\" Test to see if there is an active progress bar for object. Returns ------- bool : True if there is, otherwise False. \"\"\" if hasattr ( self , \"prog\" ): return True return False","title":"Returns"},{"location":"mixins/#torrentfile.mixins.ProgMixin.prog_close","text":"Finalize the last bits of progress bar. Increment the terminal by one line leaving the progress bar in place, and deleting the progress bar object to clear a space for the next one. Source code in torrentfile\\mixins.py 187 188 189 190 191 192 193 194 195 196 197 def prog_close ( self ): \"\"\" Finalize the last bits of progress bar. Increment the terminal by one line leaving the progress bar in place, and deleting the progress bar object to clear a space for the next one. \"\"\" if self . is_active (): sys . stdout . flush () sys . stdout . write ( \" \\n \" ) del self . prog","title":"prog_close()"},{"location":"mixins/#torrentfile.mixins.ProgMixin.prog_start","text":"Generate a new progress bar for the given file path.","title":"prog_start()"},{"location":"mixins/#torrentfile.mixins.ProgMixin.prog_start--parameters","text":"int the total amount of units accumulating towards. str path to file being hashed. int the number of characters of the actual progress bar. str the text representation of the value being measured. Source code in torrentfile\\mixins.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def prog_start ( self , total : int , path : str , length : int = 50 , unit : str = None ): \"\"\" Generate a new progress bar for the given file path. Parameters ---------- total : int the total amount of units accumulating towards. path : str path to file being hashed. length : int the number of characters of the actual progress bar. unit : str the text representation of the value being measured. \"\"\" title = path width = shutil . get_terminal_size () . columns if len ( str ( title )) >= width // 2 : parts = list ( Path ( title ) . parts ) while len ( \"//\" . join ( parts )) > width // 2 and len ( parts ) > 0 : del parts [ 0 ] title = os . path . join ( * parts ) length = min ( length , width // 2 ) start = width - int ( length * 1.5 ) self . prog = ProgressBar ( total , title , length , unit , start )","title":"Parameters"},{"location":"mixins/#torrentfile.mixins.ProgMixin.prog_update","text":"Update progress bar with given amount of progress.","title":"prog_update()"},{"location":"mixins/#torrentfile.mixins.ProgMixin.prog_update--parameters","text":"int the number of bytes count the progress bar should increase. Source code in torrentfile\\mixins.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def prog_update ( self , val : int ): \"\"\" Update progress bar with given amount of progress. Parameters ---------- val : int the number of bytes count the progress bar should increase. \"\"\" if self . is_active (): self . prog . state += val pbar = self . prog . pbar () output = f \" { self . prog . prefix }{ pbar }{ self . prog . suffix } \\r \" sys . stdout . write ( output ) sys . stdout . flush ()","title":"Parameters"},{"location":"mixins/#torrentfile.mixins.ProgressBar","text":"Holds the state and details of the terminal progress bars.","title":"ProgressBar"},{"location":"mixins/#torrentfile.mixins.ProgressBar--parameters","text":"int the total amount to be accumulated. str the subject of the progress tracker int the width of the progress bar str the text representation incremented int column where the progress bar should be drawn Source code in torrentfile\\mixins.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class ProgressBar : \"\"\" Holds the state and details of the terminal progress bars. Parameters ---------- total : int the total amount to be accumulated. title : str the subject of the progress tracker length : int the width of the progress bar unit : str the text representation incremented start : int column where the progress bar should be drawn \"\"\" def __init__ ( self , total : int , title : str , length : int , unit : str , start : int ): \"\"\" Construct the progress bar object and store state of it's properties. \"\"\" self . total = total self . start = start self . length = length self . fill = chr ( 9608 ) self . empty = chr ( 9617 ) self . state = 0 self . unit = unit self . show_total = total if not unit : self . unit = \"\" # pragma: nocover elif unit == \"bytes\" : if self . total > 1_000_000_000 : self . show_total = math . floor ( self . total / ( 2 ** 30 )) self . unit = \"GiB\" elif self . total > 1_000_000 : self . show_total = math . floor ( self . total / 1048576 ) self . unit = \"MiB\" elif self . total > 10000 : self . show_total = math . floor ( self . total / 1024 ) self . unit = \"KiB\" self . suffix = f \"/ { self . show_total } { self . unit } \" if len ( title ) > start : title = title [: start - 1 ] padding = ( start - len ( title )) * \" \" self . prefix = \"\" . join ([ title , padding ]) def pbar ( self ) -> str : \"\"\" Return the size of the filled portion of the progress bar. Returns ------- str : the progress bar characters \"\"\" if self . state >= self . total : fill = self . length else : fill = math . ceil (( self . state / self . total ) * self . length ) empt = self . length - fill if self . unit == \"GiB\" : state = math . floor ( self . state / ( 2 ** 30 )) elif self . unit == \"MiB\" : state = math . floor ( self . state / 1048576 ) elif self . unit == \"KiB\" : state = math . floor ( self . state / 1024 ) else : state = self . state progbar = [ \"|\" , self . fill * fill , self . empty * empt , \"| \" , str ( state )] return \"\" . join ( progbar )","title":"Parameters"},{"location":"mixins/#torrentfile.mixins.ProgressBar.__init__","text":"Construct the progress bar object and store state of it's properties. Source code in torrentfile\\mixins.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def __init__ ( self , total : int , title : str , length : int , unit : str , start : int ): \"\"\" Construct the progress bar object and store state of it's properties. \"\"\" self . total = total self . start = start self . length = length self . fill = chr ( 9608 ) self . empty = chr ( 9617 ) self . state = 0 self . unit = unit self . show_total = total if not unit : self . unit = \"\" # pragma: nocover elif unit == \"bytes\" : if self . total > 1_000_000_000 : self . show_total = math . floor ( self . total / ( 2 ** 30 )) self . unit = \"GiB\" elif self . total > 1_000_000 : self . show_total = math . floor ( self . total / 1048576 ) self . unit = \"MiB\" elif self . total > 10000 : self . show_total = math . floor ( self . total / 1024 ) self . unit = \"KiB\" self . suffix = f \"/ { self . show_total } { self . unit } \" if len ( title ) > start : title = title [: start - 1 ] padding = ( start - len ( title )) * \" \" self . prefix = \"\" . join ([ title , padding ])","title":"__init__()"},{"location":"mixins/#torrentfile.mixins.ProgressBar.pbar","text":"Return the size of the filled portion of the progress bar.","title":"pbar()"},{"location":"mixins/#torrentfile.mixins.ProgressBar.pbar--returns","text":"str the progress bar characters Source code in torrentfile\\mixins.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def pbar ( self ) -> str : \"\"\" Return the size of the filled portion of the progress bar. Returns ------- str : the progress bar characters \"\"\" if self . state >= self . total : fill = self . length else : fill = math . ceil (( self . state / self . total ) * self . length ) empt = self . length - fill if self . unit == \"GiB\" : state = math . floor ( self . state / ( 2 ** 30 )) elif self . unit == \"MiB\" : state = math . floor ( self . state / 1048576 ) elif self . unit == \"KiB\" : state = math . floor ( self . state / 1024 ) else : state = self . state progbar = [ \"|\" , self . fill * fill , self . empty * empt , \"| \" , str ( state )] return \"\" . join ( progbar )","title":"Returns"},{"location":"mixins/#torrentfile.mixins.waiting","text":"Show loading message while thread completes processing.","title":"waiting()"},{"location":"mixins/#torrentfile.mixins.waiting--parameters","text":"str Message string printed before the progress bar list Once flag is filled exit loop int max amount of time to run the function. Source code in torrentfile\\mixins.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def waiting ( msg : str , flag : list , timeout : int = 20 ): \"\"\" Show loading message while thread completes processing. Parameters ---------- msg : str Message string printed before the progress bar flag : list Once flag is filled exit loop timeout : int max amount of time to run the function. \"\"\" then = time . time () codes , fill = list ( range ( 9617 , 9620 )), chr ( 9619 ) size = idx = 0 total = shutil . get_terminal_size () . columns - len ( msg ) - 20 def output ( text : str ): \"\"\" Print parameter message to the console. Parameters ---------- text : str output message \"\"\" sys . stdout . write ( text ) sys . stdout . flush () output ( \" \\n \" ) time . sleep ( 0.16 ) while len ( flag ) == 0 : time . sleep ( 0.16 ) filled = ( fill * size ) + chr ( codes [ idx ]) + ( \" \" * ( total - size )) output ( f \" { msg } : { filled } \\r \" ) idx = idx + 1 if idx + 1 < len ( codes ) else 0 size = size + 1 if size < total else 0 if time . time () - then > timeout : break output ( \" \\n \" )","title":"Parameters"},{"location":"rebuild/","text":"Clases and functions for the rebuild or reassemble subcommand. Re-assemble a torrent into the propper directory structure as indicated by a torrent meta file, and validate the contents of each file allong the way. Displays a progress bar for each torrent. Assembler \u00a4 Does most of the work in attempting the structure of torrentfiles. Requires three paths as arguments. - torrent metafile or directory containing multiple meta files - directory containing the contents of meta file - directory where torrents will be re-assembled Source code in torrentfile\\rebuild.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 class Assembler : \"\"\" Does most of the work in attempting the structure of torrentfiles. Requires three paths as arguments. - torrent metafile or directory containing multiple meta files - directory containing the contents of meta file - directory where torrents will be re-assembled \"\"\" def __init__ ( self , metafile : str , contents : str , dest : str ): \"\"\" Construct the assembler object. Takes two paths as parameters, - file or directory containing 1 or more torrent meta files - path to where the contents are belived to be located. Parameters ---------- metafile : str path to torrent metafile or directory containing torrent metafiles. contents : str path to content or directory containing content that belongs to torrentfile. dest: str path to the directory where rebuild will take place. \"\"\" self . metafiles = self . _get_metafiles ( metafile ) self . contents = contents self . dest = dest self . fileinfo = {} self . counter = 0 @staticmethod def _get_metafiles ( metafile : str ): \"\"\" Collect all .torrent meta files from give directory or file. Parameters ---------- metafile : str path to a torrent meta file or directory containing torrent meta files. \"\"\" metafiles = [] if os . path . exists ( metafile ): if os . path . isdir ( metafile ): path = os . path . abspath ( metafile ) for filename in os . listdir ( path ): if filename . lower () . endswith ( \".torrent\" ): metafiles . append ( os . path . join ( path , filename )) elif os . path . isfile ( metafile ) and metafile . lower () . endswith ( \".torrent\" ): metafiles . append ( metafile ) return metafiles def rebuild ( self ): \"\"\" Build the torrent file structure from contents of directory. Traverse contents dir and compare discovered files with files listed in torrent metadata and copy the matches to the destination directory respecting folder structures along the way. \"\"\" if not self . fileinfo : self . _traverse_contents ( Path ( self . contents )) for path in self . metafiles : metadata = Metadata ( path ) for val in metadata . files : if val [ \"filename\" ] in self . fileinfo : self . _compare_files ( val ) return self . counter def _compare_files ( self , val : dict ): \"\"\" Compare all files with given filename. Compare and find which files with the same filename matches the length of the given files length and copy the file to the destination directory including it's relative file structure. Parameters ---------- val : dict Details about a particular file listed in torrent metadata. \"\"\" info = self . fileinfo [ val [ \"filename\" ]] for entry in info : if entry [ \"length\" ] != val [ \"length\" ]: continue full = os . path . join ( self . dest , val [ \"full\" ]) if os . path . exists ( full ): # pragma: nocover print ( f \"File already found at location { val [ 'filename' ] } \" ) break path = self . dest for part in val [ \"path\" ] . parts : path = os . path . join ( path , part ) if not os . path . exists ( path ): os . mkdir ( path ) shutil . copy ( entry [ \"path\" ], path ) self . counter += 1 if self . counter and self . counter % 20 == 0 : print ( f \"Success { self . counter } : { entry [ 'path' ] } -> { path } \" ) # pragma: nocover break def _traverse_contents ( self , path : PathLike ): \"\"\" Traverse the contents directory. Recursively walk the directory collecting file names and sizes for comparing to contents of torrent file. Parameters ---------- path : PathLike The current path being traversed. \"\"\" if path . is_file (): info = { \"path\" : str ( path . resolve ()), \"length\" : os . path . getsize ( path ), } if path . name not in self . fileinfo : self . fileinfo [ path . name ] = [ info ] else : self . fileinfo [ path . name ] . append ( info ) elif path . is_dir (): try : for item in path . iterdir (): self . _traverse_contents ( item ) except PermissionError : # pragma: nocover print ( f \"Warning { str ( path ) } skipped due to Permission Error.\" ) __init__ ( metafile , contents , dest ) \u00a4 Construct the assembler object. Takes two paths as parameters, - file or directory containing 1 or more torrent meta files - path to where the contents are belived to be located. Parameters \u00a4 str path to torrent metafile or directory containing torrent metafiles. str path to content or directory containing content that belongs to torrentfile. str path to the directory where rebuild will take place. Source code in torrentfile\\rebuild.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def __init__ ( self , metafile : str , contents : str , dest : str ): \"\"\" Construct the assembler object. Takes two paths as parameters, - file or directory containing 1 or more torrent meta files - path to where the contents are belived to be located. Parameters ---------- metafile : str path to torrent metafile or directory containing torrent metafiles. contents : str path to content or directory containing content that belongs to torrentfile. dest: str path to the directory where rebuild will take place. \"\"\" self . metafiles = self . _get_metafiles ( metafile ) self . contents = contents self . dest = dest self . fileinfo = {} self . counter = 0 _compare_files ( val ) \u00a4 Compare all files with given filename. Compare and find which files with the same filename matches the length of the given files length and copy the file to the destination directory including it's relative file structure. Parameters \u00a4 dict Details about a particular file listed in torrent metadata. Source code in torrentfile\\rebuild.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 def _compare_files ( self , val : dict ): \"\"\" Compare all files with given filename. Compare and find which files with the same filename matches the length of the given files length and copy the file to the destination directory including it's relative file structure. Parameters ---------- val : dict Details about a particular file listed in torrent metadata. \"\"\" info = self . fileinfo [ val [ \"filename\" ]] for entry in info : if entry [ \"length\" ] != val [ \"length\" ]: continue full = os . path . join ( self . dest , val [ \"full\" ]) if os . path . exists ( full ): # pragma: nocover print ( f \"File already found at location { val [ 'filename' ] } \" ) break path = self . dest for part in val [ \"path\" ] . parts : path = os . path . join ( path , part ) if not os . path . exists ( path ): os . mkdir ( path ) shutil . copy ( entry [ \"path\" ], path ) self . counter += 1 if self . counter and self . counter % 20 == 0 : print ( f \"Success { self . counter } : { entry [ 'path' ] } -> { path } \" ) # pragma: nocover break _get_metafiles ( metafile ) staticmethod \u00a4 Collect all .torrent meta files from give directory or file. Parameters \u00a4 str path to a torrent meta file or directory containing torrent meta files. Source code in torrentfile\\rebuild.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 @staticmethod def _get_metafiles ( metafile : str ): \"\"\" Collect all .torrent meta files from give directory or file. Parameters ---------- metafile : str path to a torrent meta file or directory containing torrent meta files. \"\"\" metafiles = [] if os . path . exists ( metafile ): if os . path . isdir ( metafile ): path = os . path . abspath ( metafile ) for filename in os . listdir ( path ): if filename . lower () . endswith ( \".torrent\" ): metafiles . append ( os . path . join ( path , filename )) elif os . path . isfile ( metafile ) and metafile . lower () . endswith ( \".torrent\" ): metafiles . append ( metafile ) return metafiles _traverse_contents ( path ) \u00a4 Traverse the contents directory. Recursively walk the directory collecting file names and sizes for comparing to contents of torrent file. Parameters \u00a4 PathLike The current path being traversed. Source code in torrentfile\\rebuild.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def _traverse_contents ( self , path : PathLike ): \"\"\" Traverse the contents directory. Recursively walk the directory collecting file names and sizes for comparing to contents of torrent file. Parameters ---------- path : PathLike The current path being traversed. \"\"\" if path . is_file (): info = { \"path\" : str ( path . resolve ()), \"length\" : os . path . getsize ( path ), } if path . name not in self . fileinfo : self . fileinfo [ path . name ] = [ info ] else : self . fileinfo [ path . name ] . append ( info ) elif path . is_dir (): try : for item in path . iterdir (): self . _traverse_contents ( item ) except PermissionError : # pragma: nocover print ( f \"Warning { str ( path ) } skipped due to Permission Error.\" ) rebuild () \u00a4 Build the torrent file structure from contents of directory. Traverse contents dir and compare discovered files with files listed in torrent metadata and copy the matches to the destination directory respecting folder structures along the way. Source code in torrentfile\\rebuild.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def rebuild ( self ): \"\"\" Build the torrent file structure from contents of directory. Traverse contents dir and compare discovered files with files listed in torrent metadata and copy the matches to the destination directory respecting folder structures along the way. \"\"\" if not self . fileinfo : self . _traverse_contents ( Path ( self . contents )) for path in self . metafiles : metadata = Metadata ( path ) for val in metadata . files : if val [ \"filename\" ] in self . fileinfo : self . _compare_files ( val ) return self . counter Metadata \u00a4 Class containing the metadata contents of a torrent file. Source code in torrentfile\\rebuild.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 class Metadata : \"\"\" Class containing the metadata contents of a torrent file. \"\"\" def __init__ ( self , path : str ): \"\"\" Construct metadata object for torrent info. Parameters ---------- path : str path to the .torrent file. \"\"\" self . path = os . path . abspath ( path ) self . meta = None self . name = None self . length = 0 self . files = [] self . filenames = set () self . extract () def extract ( self ): \"\"\" Decode and extract information for the .torrent file. \"\"\" self . meta = pyben . load ( self . path ) info = self . meta [ \"info\" ] self . name = info [ \"name\" ] if \"length\" in info : self . length += info [ \"length\" ] self . is_file = True self . filenames . add ( info [ \"name\" ]) self . files . append ( { \"path\" : Path ( self . name ) . parent , \"filename\" : self . name , \"full\" : self . name , \"length\" : self . length , } ) if \"files\" in info : for f in info [ \"files\" ]: path = f [ \"path\" ] full = os . path . join ( self . name , * path ) self . files . append ( { \"path\" : Path ( full ) . parent , \"filename\" : path [ - 1 ], \"full\" : full , \"length\" : f [ \"length\" ], } ) self . length += f [ \"length\" ] self . filenames . add ( path [ - 1 ]) elif \"file tree\" in info : self . _parse_tree ( info [ \"file tree\" ], [ self . name ]) def _parse_tree ( self , tree : dict , partials : list ): \"\"\" Parse the file tree dictionary of the torrent metafile. Parameters ---------- tree : dict the dictionary representation of a file tree. partials : list list of paths leading up to the current key value. \"\"\" for key , val in tree . items (): if \"\" in val : self . filenames . add ( key ) path = Path ( os . path . join ( * partials )) full = Path ( os . path . join ( path , key )) length = val [ \"\" ][ \"length\" ] self . files . append ( { \"path\" : path , \"full\" : full , \"filename\" : key , \"length\" : length , } ) self . length += length else : self . _parse_tree ( val , partials + [ key ]) __init__ ( path ) \u00a4 Construct metadata object for torrent info. Parameters \u00a4 str path to the .torrent file. Source code in torrentfile\\rebuild.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def __init__ ( self , path : str ): \"\"\" Construct metadata object for torrent info. Parameters ---------- path : str path to the .torrent file. \"\"\" self . path = os . path . abspath ( path ) self . meta = None self . name = None self . length = 0 self . files = [] self . filenames = set () self . extract () _parse_tree ( tree , partials ) \u00a4 Parse the file tree dictionary of the torrent metafile. Parameters \u00a4 dict the dictionary representation of a file tree. list list of paths leading up to the current key value. Source code in torrentfile\\rebuild.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def _parse_tree ( self , tree : dict , partials : list ): \"\"\" Parse the file tree dictionary of the torrent metafile. Parameters ---------- tree : dict the dictionary representation of a file tree. partials : list list of paths leading up to the current key value. \"\"\" for key , val in tree . items (): if \"\" in val : self . filenames . add ( key ) path = Path ( os . path . join ( * partials )) full = Path ( os . path . join ( path , key )) length = val [ \"\" ][ \"length\" ] self . files . append ( { \"path\" : path , \"full\" : full , \"filename\" : key , \"length\" : length , } ) self . length += length else : self . _parse_tree ( val , partials + [ key ]) extract () \u00a4 Decode and extract information for the .torrent file. Source code in torrentfile\\rebuild.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def extract ( self ): \"\"\" Decode and extract information for the .torrent file. \"\"\" self . meta = pyben . load ( self . path ) info = self . meta [ \"info\" ] self . name = info [ \"name\" ] if \"length\" in info : self . length += info [ \"length\" ] self . is_file = True self . filenames . add ( info [ \"name\" ]) self . files . append ( { \"path\" : Path ( self . name ) . parent , \"filename\" : self . name , \"full\" : self . name , \"length\" : self . length , } ) if \"files\" in info : for f in info [ \"files\" ]: path = f [ \"path\" ] full = os . path . join ( self . name , * path ) self . files . append ( { \"path\" : Path ( full ) . parent , \"filename\" : path [ - 1 ], \"full\" : full , \"length\" : f [ \"length\" ], } ) self . length += f [ \"length\" ] self . filenames . add ( path [ - 1 ]) elif \"file tree\" in info : self . _parse_tree ( info [ \"file tree\" ], [ self . name ])","title":"rebuild"},{"location":"rebuild/#torrentfile.rebuild.Assembler","text":"Does most of the work in attempting the structure of torrentfiles. Requires three paths as arguments. - torrent metafile or directory containing multiple meta files - directory containing the contents of meta file - directory where torrents will be re-assembled Source code in torrentfile\\rebuild.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 class Assembler : \"\"\" Does most of the work in attempting the structure of torrentfiles. Requires three paths as arguments. - torrent metafile or directory containing multiple meta files - directory containing the contents of meta file - directory where torrents will be re-assembled \"\"\" def __init__ ( self , metafile : str , contents : str , dest : str ): \"\"\" Construct the assembler object. Takes two paths as parameters, - file or directory containing 1 or more torrent meta files - path to where the contents are belived to be located. Parameters ---------- metafile : str path to torrent metafile or directory containing torrent metafiles. contents : str path to content or directory containing content that belongs to torrentfile. dest: str path to the directory where rebuild will take place. \"\"\" self . metafiles = self . _get_metafiles ( metafile ) self . contents = contents self . dest = dest self . fileinfo = {} self . counter = 0 @staticmethod def _get_metafiles ( metafile : str ): \"\"\" Collect all .torrent meta files from give directory or file. Parameters ---------- metafile : str path to a torrent meta file or directory containing torrent meta files. \"\"\" metafiles = [] if os . path . exists ( metafile ): if os . path . isdir ( metafile ): path = os . path . abspath ( metafile ) for filename in os . listdir ( path ): if filename . lower () . endswith ( \".torrent\" ): metafiles . append ( os . path . join ( path , filename )) elif os . path . isfile ( metafile ) and metafile . lower () . endswith ( \".torrent\" ): metafiles . append ( metafile ) return metafiles def rebuild ( self ): \"\"\" Build the torrent file structure from contents of directory. Traverse contents dir and compare discovered files with files listed in torrent metadata and copy the matches to the destination directory respecting folder structures along the way. \"\"\" if not self . fileinfo : self . _traverse_contents ( Path ( self . contents )) for path in self . metafiles : metadata = Metadata ( path ) for val in metadata . files : if val [ \"filename\" ] in self . fileinfo : self . _compare_files ( val ) return self . counter def _compare_files ( self , val : dict ): \"\"\" Compare all files with given filename. Compare and find which files with the same filename matches the length of the given files length and copy the file to the destination directory including it's relative file structure. Parameters ---------- val : dict Details about a particular file listed in torrent metadata. \"\"\" info = self . fileinfo [ val [ \"filename\" ]] for entry in info : if entry [ \"length\" ] != val [ \"length\" ]: continue full = os . path . join ( self . dest , val [ \"full\" ]) if os . path . exists ( full ): # pragma: nocover print ( f \"File already found at location { val [ 'filename' ] } \" ) break path = self . dest for part in val [ \"path\" ] . parts : path = os . path . join ( path , part ) if not os . path . exists ( path ): os . mkdir ( path ) shutil . copy ( entry [ \"path\" ], path ) self . counter += 1 if self . counter and self . counter % 20 == 0 : print ( f \"Success { self . counter } : { entry [ 'path' ] } -> { path } \" ) # pragma: nocover break def _traverse_contents ( self , path : PathLike ): \"\"\" Traverse the contents directory. Recursively walk the directory collecting file names and sizes for comparing to contents of torrent file. Parameters ---------- path : PathLike The current path being traversed. \"\"\" if path . is_file (): info = { \"path\" : str ( path . resolve ()), \"length\" : os . path . getsize ( path ), } if path . name not in self . fileinfo : self . fileinfo [ path . name ] = [ info ] else : self . fileinfo [ path . name ] . append ( info ) elif path . is_dir (): try : for item in path . iterdir (): self . _traverse_contents ( item ) except PermissionError : # pragma: nocover print ( f \"Warning { str ( path ) } skipped due to Permission Error.\" )","title":"Assembler"},{"location":"rebuild/#torrentfile.rebuild.Assembler.__init__","text":"Construct the assembler object. Takes two paths as parameters, - file or directory containing 1 or more torrent meta files - path to where the contents are belived to be located.","title":"__init__()"},{"location":"rebuild/#torrentfile.rebuild.Assembler.__init__--parameters","text":"str path to torrent metafile or directory containing torrent metafiles. str path to content or directory containing content that belongs to torrentfile. str path to the directory where rebuild will take place. Source code in torrentfile\\rebuild.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def __init__ ( self , metafile : str , contents : str , dest : str ): \"\"\" Construct the assembler object. Takes two paths as parameters, - file or directory containing 1 or more torrent meta files - path to where the contents are belived to be located. Parameters ---------- metafile : str path to torrent metafile or directory containing torrent metafiles. contents : str path to content or directory containing content that belongs to torrentfile. dest: str path to the directory where rebuild will take place. \"\"\" self . metafiles = self . _get_metafiles ( metafile ) self . contents = contents self . dest = dest self . fileinfo = {} self . counter = 0","title":"Parameters"},{"location":"rebuild/#torrentfile.rebuild.Assembler._compare_files","text":"Compare all files with given filename. Compare and find which files with the same filename matches the length of the given files length and copy the file to the destination directory including it's relative file structure.","title":"_compare_files()"},{"location":"rebuild/#torrentfile.rebuild.Assembler._compare_files--parameters","text":"dict Details about a particular file listed in torrent metadata. Source code in torrentfile\\rebuild.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 def _compare_files ( self , val : dict ): \"\"\" Compare all files with given filename. Compare and find which files with the same filename matches the length of the given files length and copy the file to the destination directory including it's relative file structure. Parameters ---------- val : dict Details about a particular file listed in torrent metadata. \"\"\" info = self . fileinfo [ val [ \"filename\" ]] for entry in info : if entry [ \"length\" ] != val [ \"length\" ]: continue full = os . path . join ( self . dest , val [ \"full\" ]) if os . path . exists ( full ): # pragma: nocover print ( f \"File already found at location { val [ 'filename' ] } \" ) break path = self . dest for part in val [ \"path\" ] . parts : path = os . path . join ( path , part ) if not os . path . exists ( path ): os . mkdir ( path ) shutil . copy ( entry [ \"path\" ], path ) self . counter += 1 if self . counter and self . counter % 20 == 0 : print ( f \"Success { self . counter } : { entry [ 'path' ] } -> { path } \" ) # pragma: nocover break","title":"Parameters"},{"location":"rebuild/#torrentfile.rebuild.Assembler._get_metafiles","text":"Collect all .torrent meta files from give directory or file.","title":"_get_metafiles()"},{"location":"rebuild/#torrentfile.rebuild.Assembler._get_metafiles--parameters","text":"str path to a torrent meta file or directory containing torrent meta files. Source code in torrentfile\\rebuild.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 @staticmethod def _get_metafiles ( metafile : str ): \"\"\" Collect all .torrent meta files from give directory or file. Parameters ---------- metafile : str path to a torrent meta file or directory containing torrent meta files. \"\"\" metafiles = [] if os . path . exists ( metafile ): if os . path . isdir ( metafile ): path = os . path . abspath ( metafile ) for filename in os . listdir ( path ): if filename . lower () . endswith ( \".torrent\" ): metafiles . append ( os . path . join ( path , filename )) elif os . path . isfile ( metafile ) and metafile . lower () . endswith ( \".torrent\" ): metafiles . append ( metafile ) return metafiles","title":"Parameters"},{"location":"rebuild/#torrentfile.rebuild.Assembler._traverse_contents","text":"Traverse the contents directory. Recursively walk the directory collecting file names and sizes for comparing to contents of torrent file.","title":"_traverse_contents()"},{"location":"rebuild/#torrentfile.rebuild.Assembler._traverse_contents--parameters","text":"PathLike The current path being traversed. Source code in torrentfile\\rebuild.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def _traverse_contents ( self , path : PathLike ): \"\"\" Traverse the contents directory. Recursively walk the directory collecting file names and sizes for comparing to contents of torrent file. Parameters ---------- path : PathLike The current path being traversed. \"\"\" if path . is_file (): info = { \"path\" : str ( path . resolve ()), \"length\" : os . path . getsize ( path ), } if path . name not in self . fileinfo : self . fileinfo [ path . name ] = [ info ] else : self . fileinfo [ path . name ] . append ( info ) elif path . is_dir (): try : for item in path . iterdir (): self . _traverse_contents ( item ) except PermissionError : # pragma: nocover print ( f \"Warning { str ( path ) } skipped due to Permission Error.\" )","title":"Parameters"},{"location":"rebuild/#torrentfile.rebuild.Assembler.rebuild","text":"Build the torrent file structure from contents of directory. Traverse contents dir and compare discovered files with files listed in torrent metadata and copy the matches to the destination directory respecting folder structures along the way. Source code in torrentfile\\rebuild.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def rebuild ( self ): \"\"\" Build the torrent file structure from contents of directory. Traverse contents dir and compare discovered files with files listed in torrent metadata and copy the matches to the destination directory respecting folder structures along the way. \"\"\" if not self . fileinfo : self . _traverse_contents ( Path ( self . contents )) for path in self . metafiles : metadata = Metadata ( path ) for val in metadata . files : if val [ \"filename\" ] in self . fileinfo : self . _compare_files ( val ) return self . counter","title":"rebuild()"},{"location":"rebuild/#torrentfile.rebuild.Metadata","text":"Class containing the metadata contents of a torrent file. Source code in torrentfile\\rebuild.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 class Metadata : \"\"\" Class containing the metadata contents of a torrent file. \"\"\" def __init__ ( self , path : str ): \"\"\" Construct metadata object for torrent info. Parameters ---------- path : str path to the .torrent file. \"\"\" self . path = os . path . abspath ( path ) self . meta = None self . name = None self . length = 0 self . files = [] self . filenames = set () self . extract () def extract ( self ): \"\"\" Decode and extract information for the .torrent file. \"\"\" self . meta = pyben . load ( self . path ) info = self . meta [ \"info\" ] self . name = info [ \"name\" ] if \"length\" in info : self . length += info [ \"length\" ] self . is_file = True self . filenames . add ( info [ \"name\" ]) self . files . append ( { \"path\" : Path ( self . name ) . parent , \"filename\" : self . name , \"full\" : self . name , \"length\" : self . length , } ) if \"files\" in info : for f in info [ \"files\" ]: path = f [ \"path\" ] full = os . path . join ( self . name , * path ) self . files . append ( { \"path\" : Path ( full ) . parent , \"filename\" : path [ - 1 ], \"full\" : full , \"length\" : f [ \"length\" ], } ) self . length += f [ \"length\" ] self . filenames . add ( path [ - 1 ]) elif \"file tree\" in info : self . _parse_tree ( info [ \"file tree\" ], [ self . name ]) def _parse_tree ( self , tree : dict , partials : list ): \"\"\" Parse the file tree dictionary of the torrent metafile. Parameters ---------- tree : dict the dictionary representation of a file tree. partials : list list of paths leading up to the current key value. \"\"\" for key , val in tree . items (): if \"\" in val : self . filenames . add ( key ) path = Path ( os . path . join ( * partials )) full = Path ( os . path . join ( path , key )) length = val [ \"\" ][ \"length\" ] self . files . append ( { \"path\" : path , \"full\" : full , \"filename\" : key , \"length\" : length , } ) self . length += length else : self . _parse_tree ( val , partials + [ key ])","title":"Metadata"},{"location":"rebuild/#torrentfile.rebuild.Metadata.__init__","text":"Construct metadata object for torrent info.","title":"__init__()"},{"location":"rebuild/#torrentfile.rebuild.Metadata.__init__--parameters","text":"str path to the .torrent file. Source code in torrentfile\\rebuild.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def __init__ ( self , path : str ): \"\"\" Construct metadata object for torrent info. Parameters ---------- path : str path to the .torrent file. \"\"\" self . path = os . path . abspath ( path ) self . meta = None self . name = None self . length = 0 self . files = [] self . filenames = set () self . extract ()","title":"Parameters"},{"location":"rebuild/#torrentfile.rebuild.Metadata._parse_tree","text":"Parse the file tree dictionary of the torrent metafile.","title":"_parse_tree()"},{"location":"rebuild/#torrentfile.rebuild.Metadata._parse_tree--parameters","text":"dict the dictionary representation of a file tree. list list of paths leading up to the current key value. Source code in torrentfile\\rebuild.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def _parse_tree ( self , tree : dict , partials : list ): \"\"\" Parse the file tree dictionary of the torrent metafile. Parameters ---------- tree : dict the dictionary representation of a file tree. partials : list list of paths leading up to the current key value. \"\"\" for key , val in tree . items (): if \"\" in val : self . filenames . add ( key ) path = Path ( os . path . join ( * partials )) full = Path ( os . path . join ( path , key )) length = val [ \"\" ][ \"length\" ] self . files . append ( { \"path\" : path , \"full\" : full , \"filename\" : key , \"length\" : length , } ) self . length += length else : self . _parse_tree ( val , partials + [ key ])","title":"Parameters"},{"location":"rebuild/#torrentfile.rebuild.Metadata.extract","text":"Decode and extract information for the .torrent file. Source code in torrentfile\\rebuild.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def extract ( self ): \"\"\" Decode and extract information for the .torrent file. \"\"\" self . meta = pyben . load ( self . path ) info = self . meta [ \"info\" ] self . name = info [ \"name\" ] if \"length\" in info : self . length += info [ \"length\" ] self . is_file = True self . filenames . add ( info [ \"name\" ]) self . files . append ( { \"path\" : Path ( self . name ) . parent , \"filename\" : self . name , \"full\" : self . name , \"length\" : self . length , } ) if \"files\" in info : for f in info [ \"files\" ]: path = f [ \"path\" ] full = os . path . join ( self . name , * path ) self . files . append ( { \"path\" : Path ( full ) . parent , \"filename\" : path [ - 1 ], \"full\" : full , \"length\" : f [ \"length\" ], } ) self . length += f [ \"length\" ] self . filenames . add ( path [ - 1 ]) elif \"file tree\" in info : self . _parse_tree ( info [ \"file tree\" ], [ self . name ])","title":"extract()"},{"location":"recheck/","text":"Module container Checker Class. The CheckerClass takes a torrentfile and tha path to it's contents. It will then iterate through every file and directory contained and compare their data to values contained within the torrent file. Completion percentages will be printed to screen for each file and at the end for the torrentfile as a whole. Checker \u00a4 Check a given file or directory to see if it matches a torrentfile. Public constructor for Checker class instance. Parameters \u00a4 str Path to \".torrent\" file. str Path where the content is located in filesystem. Example \u00a4 >> metafile = \"/path/to/torrentfile/content_file_or_dir.torrent\" >> location = \"/path/to/location\" >> os.path.exists(\"/path/to/location/content_file_or_dir\") Out: True >> checker = Checker(metafile, location) Source code in torrentfile\\recheck.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 class Checker : \"\"\" Check a given file or directory to see if it matches a torrentfile. Public constructor for Checker class instance. Parameters ---------- metafile : str Path to \".torrent\" file. path : str Path where the content is located in filesystem. Example ------- >> metafile = \"/path/to/torrentfile/content_file_or_dir.torrent\" >> location = \"/path/to/location\" >> os.path.exists(\"/path/to/location/content_file_or_dir\") Out: True >> checker = Checker(metafile, location) \"\"\" _hook = None def __init__ ( self , metafile : str , path : str ): \"\"\" Validate data against hashes contained in .torrent file. Parameters ---------- metafile : str path to .torrent file path : str path to content or contents parent directory. \"\"\" if not os . path . exists ( metafile ): raise FileNotFoundError if os . path . isdir ( metafile ): raise ArgumentError ( \"The <metafile> must be a .torrent file. Not a directory\" ) self . last_log = None self . log_msg ( \"Checking: %s , %s \" , metafile , path ) self . metafile = metafile self . total = 0 self . paths = [] self . fileinfo = {} print ( \"Extracting data from torrent file...\" ) self . meta = pyben . load ( metafile ) self . info = self . meta [ \"info\" ] self . name = self . info [ \"name\" ] self . piece_length = self . info [ \"piece length\" ] if \"meta version\" in self . info : if \"pieces\" in self . info : self . meta_version = 3 else : self . meta_version = 2 else : self . meta_version = 1 self . root = self . find_root ( path ) self . check_paths () @classmethod def register_callback ( cls , hook ): \"\"\" Register hooks from 3rd party programs to access generated info. Parameters ---------- hook : function callback function for the logging feature. \"\"\" cls . _hook = hook def piece_checker ( self ): \"\"\" Check individual pieces of the torrent. Returns ------- HashChecker | FeedChecker Individual piece hasher. \"\"\" if self . meta_version == 1 : return FeedChecker return HashChecker def results ( self ): \"\"\" Generate result percentage and store for future calls. \"\"\" responses = [] for response in self . iter_hashes (): responses . append ( response ) self . log_msg ( \"Final result for %s recheck: %s \" , self . metafile , self . _result ) return self . _result def log_msg ( self , * args , level : int = logging . INFO ): \"\"\" Log message `msg` to logger and send `msg` to callback hook. Parameters ---------- *args : dict formatting args for log message level : int Log level for this message; default=`logging.INFO` \"\"\" message = args [ 0 ] if len ( args ) >= 3 : message = message % tuple ( args [ 1 :]) elif len ( args ) == 2 : message = message % args [ 1 ] # Repeat log messages should be ignored. if message != self . last_log : self . last_log = message logger . log ( level , message ) if self . _hook and level == logging . INFO : self . _hook ( message ) def find_root ( self , path : str ) -> str : \"\"\" Check path for torrent content. The path can be a relative or absolute filesystem path. In the case where the content is a single file, the path may point directly to the the file, or it may point to the parent directory. If content points to a directory. The directory will be checked to see if it matches the torrent's name, if not the directories contents will be searched. The returned value will be the absolute path that matches the torrent's name. Parameters ---------- path : str root path to torrent content Returns ------- str root path to content \"\"\" if not os . path . exists ( path ): self . log_msg ( \"Could not locate torrent content %s .\" , path ) raise FileNotFoundError ( path ) root = Path ( path ) if root . name == self . name : self . log_msg ( \"Content found: %s .\" , str ( root )) return root if self . name in os . listdir ( root ): return root / self . name self . log_msg ( \"Could not locate torrent content in: %s \" , str ( root )) raise FileNotFoundError ( root ) def check_paths ( self ): \"\"\" Gather all file paths described in the torrent file. \"\"\" finfo = self . fileinfo if \"length\" in self . info : self . log_msg ( \" %s points to a single file\" , self . root ) self . total = self . info [ \"length\" ] self . paths . append ( str ( self . root )) finfo [ 0 ] = { \"path\" : self . root , \"length\" : self . info [ \"length\" ], } if self . meta_version > 1 : root = self . info [ \"file tree\" ][ self . name ][ \"\" ][ \"pieces root\" ] finfo [ 0 ][ \"pieces root\" ] = root return # Otherwise Content is more than 1 file. self . log_msg ( \" %s points to a directory\" , self . root ) if self . meta_version == 1 : for i , item in enumerate ( self . info [ \"files\" ]): self . total += item [ \"length\" ] base = os . path . join ( * item [ \"path\" ]) self . fileinfo [ i ] = { \"path\" : str ( self . root / base ), \"length\" : item [ \"length\" ], } self . paths . append ( str ( self . root / base )) return self . walk_file_tree ( self . info [ \"file tree\" ], []) def walk_file_tree ( self , tree : dict , partials : list ): \"\"\" Traverse File Tree dictionary to get file details. Extract full pathnames, length, root hash, and layer hashes for each file included in the .torrent's file tree. Parameters ---------- tree : dict File Tree dict extracted from torrent file. partials : list list of intermediate pathnames. \"\"\" for key , val in tree . items (): # Empty string means the tree's leaf is value if \"\" in val : base = os . path . join ( * partials , key ) roothash = None length = val [ \"\" ][ \"length\" ] roothash = None if not length else val [ \"\" ][ \"pieces root\" ] full = str ( self . root / base ) self . fileinfo [ len ( self . paths )] = { \"path\" : full , \"length\" : length , \"pieces root\" : roothash , } self . paths . append ( full ) self . total += length else : self . walk_file_tree ( val , partials + [ key ]) def iter_hashes ( self ) -> tuple : \"\"\" Produce results of comparing torrent contents piece by piece. Yields ------ chunck : bytes hash of data found on disk piece : bytes hash of data when complete and correct path : str path to file being hashed size : int length of bytes hashed for piece \"\"\" matched = consumed = 0 checker = self . piece_checker () for chunk , piece , path , size in checker ( self ): consumed += size matching = 0 if chunk == piece : matching += size matched += size yield chunk , piece , path , size total_consumed = str ( int ( consumed / self . total * 100 )) percent_matched = str ( int ( matched / consumed * 100 )) self . log_msg ( \"Processed: %s%% , Matched: %s%% \" , total_consumed , percent_matched , ) self . _result = ( matched / consumed ) * 100 if consumed > 0 else 0 __init__ ( metafile , path ) \u00a4 Validate data against hashes contained in .torrent file. Parameters \u00a4 str path to .torrent file str path to content or contents parent directory. Source code in torrentfile\\recheck.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def __init__ ( self , metafile : str , path : str ): \"\"\" Validate data against hashes contained in .torrent file. Parameters ---------- metafile : str path to .torrent file path : str path to content or contents parent directory. \"\"\" if not os . path . exists ( metafile ): raise FileNotFoundError if os . path . isdir ( metafile ): raise ArgumentError ( \"The <metafile> must be a .torrent file. Not a directory\" ) self . last_log = None self . log_msg ( \"Checking: %s , %s \" , metafile , path ) self . metafile = metafile self . total = 0 self . paths = [] self . fileinfo = {} print ( \"Extracting data from torrent file...\" ) self . meta = pyben . load ( metafile ) self . info = self . meta [ \"info\" ] self . name = self . info [ \"name\" ] self . piece_length = self . info [ \"piece length\" ] if \"meta version\" in self . info : if \"pieces\" in self . info : self . meta_version = 3 else : self . meta_version = 2 else : self . meta_version = 1 self . root = self . find_root ( path ) self . check_paths () check_paths () \u00a4 Gather all file paths described in the torrent file. Source code in torrentfile\\recheck.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 def check_paths ( self ): \"\"\" Gather all file paths described in the torrent file. \"\"\" finfo = self . fileinfo if \"length\" in self . info : self . log_msg ( \" %s points to a single file\" , self . root ) self . total = self . info [ \"length\" ] self . paths . append ( str ( self . root )) finfo [ 0 ] = { \"path\" : self . root , \"length\" : self . info [ \"length\" ], } if self . meta_version > 1 : root = self . info [ \"file tree\" ][ self . name ][ \"\" ][ \"pieces root\" ] finfo [ 0 ][ \"pieces root\" ] = root return # Otherwise Content is more than 1 file. self . log_msg ( \" %s points to a directory\" , self . root ) if self . meta_version == 1 : for i , item in enumerate ( self . info [ \"files\" ]): self . total += item [ \"length\" ] base = os . path . join ( * item [ \"path\" ]) self . fileinfo [ i ] = { \"path\" : str ( self . root / base ), \"length\" : item [ \"length\" ], } self . paths . append ( str ( self . root / base )) return self . walk_file_tree ( self . info [ \"file tree\" ], []) find_root ( path ) \u00a4 Check path for torrent content. The path can be a relative or absolute filesystem path. In the case where the content is a single file, the path may point directly to the the file, or it may point to the parent directory. If content points to a directory. The directory will be checked to see if it matches the torrent's name, if not the directories contents will be searched. The returned value will be the absolute path that matches the torrent's name. Parameters \u00a4 str root path to torrent content Returns \u00a4 str root path to content Source code in torrentfile\\recheck.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def find_root ( self , path : str ) -> str : \"\"\" Check path for torrent content. The path can be a relative or absolute filesystem path. In the case where the content is a single file, the path may point directly to the the file, or it may point to the parent directory. If content points to a directory. The directory will be checked to see if it matches the torrent's name, if not the directories contents will be searched. The returned value will be the absolute path that matches the torrent's name. Parameters ---------- path : str root path to torrent content Returns ------- str root path to content \"\"\" if not os . path . exists ( path ): self . log_msg ( \"Could not locate torrent content %s .\" , path ) raise FileNotFoundError ( path ) root = Path ( path ) if root . name == self . name : self . log_msg ( \"Content found: %s .\" , str ( root )) return root if self . name in os . listdir ( root ): return root / self . name self . log_msg ( \"Could not locate torrent content in: %s \" , str ( root )) raise FileNotFoundError ( root ) iter_hashes () \u00a4 Produce results of comparing torrent contents piece by piece. Yields \u00a4 bytes hash of data found on disk bytes hash of data when complete and correct str path to file being hashed int length of bytes hashed for piece Source code in torrentfile\\recheck.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 def iter_hashes ( self ) -> tuple : \"\"\" Produce results of comparing torrent contents piece by piece. Yields ------ chunck : bytes hash of data found on disk piece : bytes hash of data when complete and correct path : str path to file being hashed size : int length of bytes hashed for piece \"\"\" matched = consumed = 0 checker = self . piece_checker () for chunk , piece , path , size in checker ( self ): consumed += size matching = 0 if chunk == piece : matching += size matched += size yield chunk , piece , path , size total_consumed = str ( int ( consumed / self . total * 100 )) percent_matched = str ( int ( matched / consumed * 100 )) self . log_msg ( \"Processed: %s%% , Matched: %s%% \" , total_consumed , percent_matched , ) self . _result = ( matched / consumed ) * 100 if consumed > 0 else 0 log_msg ( * args , level = logging . INFO ) \u00a4 Log message msg to logger and send msg to callback hook. Parameters \u00a4 *args : dict formatting args for log message int Log level for this message; default= logging.INFO Source code in torrentfile\\recheck.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def log_msg ( self , * args , level : int = logging . INFO ): \"\"\" Log message `msg` to logger and send `msg` to callback hook. Parameters ---------- *args : dict formatting args for log message level : int Log level for this message; default=`logging.INFO` \"\"\" message = args [ 0 ] if len ( args ) >= 3 : message = message % tuple ( args [ 1 :]) elif len ( args ) == 2 : message = message % args [ 1 ] # Repeat log messages should be ignored. if message != self . last_log : self . last_log = message logger . log ( level , message ) if self . _hook and level == logging . INFO : self . _hook ( message ) piece_checker () \u00a4 Check individual pieces of the torrent. Returns \u00a4 HashChecker | FeedChecker Individual piece hasher. Source code in torrentfile\\recheck.py 123 124 125 126 127 128 129 130 131 132 133 134 def piece_checker ( self ): \"\"\" Check individual pieces of the torrent. Returns ------- HashChecker | FeedChecker Individual piece hasher. \"\"\" if self . meta_version == 1 : return FeedChecker return HashChecker register_callback ( hook ) classmethod \u00a4 Register hooks from 3rd party programs to access generated info. Parameters \u00a4 function callback function for the logging feature. Source code in torrentfile\\recheck.py 111 112 113 114 115 116 117 118 119 120 121 @classmethod def register_callback ( cls , hook ): \"\"\" Register hooks from 3rd party programs to access generated info. Parameters ---------- hook : function callback function for the logging feature. \"\"\" cls . _hook = hook results () \u00a4 Generate result percentage and store for future calls. Source code in torrentfile\\recheck.py 136 137 138 139 140 141 142 143 144 145 146 147 148 def results ( self ): \"\"\" Generate result percentage and store for future calls. \"\"\" responses = [] for response in self . iter_hashes (): responses . append ( response ) self . log_msg ( \"Final result for %s recheck: %s \" , self . metafile , self . _result ) return self . _result walk_file_tree ( tree , partials ) \u00a4 Traverse File Tree dictionary to get file details. Extract full pathnames, length, root hash, and layer hashes for each file included in the .torrent's file tree. Parameters \u00a4 dict File Tree dict extracted from torrent file. list list of intermediate pathnames. Source code in torrentfile\\recheck.py 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 def walk_file_tree ( self , tree : dict , partials : list ): \"\"\" Traverse File Tree dictionary to get file details. Extract full pathnames, length, root hash, and layer hashes for each file included in the .torrent's file tree. Parameters ---------- tree : dict File Tree dict extracted from torrent file. partials : list list of intermediate pathnames. \"\"\" for key , val in tree . items (): # Empty string means the tree's leaf is value if \"\" in val : base = os . path . join ( * partials , key ) roothash = None length = val [ \"\" ][ \"length\" ] roothash = None if not length else val [ \"\" ][ \"pieces root\" ] full = str ( self . root / base ) self . fileinfo [ len ( self . paths )] = { \"path\" : full , \"length\" : length , \"pieces root\" : roothash , } self . paths . append ( full ) self . total += length else : self . walk_file_tree ( val , partials + [ key ]) FeedChecker \u00a4 Bases: ProgMixin Validates torrent content. Seemlesly validate torrent file contents by comparing hashes in metafile against data on disk. Parameters \u00a4 object the checker class instance. Source code in torrentfile\\recheck.py 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 class FeedChecker ( ProgMixin ): \"\"\" Validates torrent content. Seemlesly validate torrent file contents by comparing hashes in metafile against data on disk. Parameters ---------- checker : object the checker class instance. \"\"\" def __init__ ( self , checker : Checker ): \"\"\" Generate hashes of piece length data from filelist contents. \"\"\" self . piece_length = checker . piece_length self . paths = checker . paths self . pieces = checker . info [ \"pieces\" ] self . fileinfo = checker . fileinfo self . piece_map = {} self . index = 0 self . piece_count = 0 self . it = None def __iter__ ( self ): \"\"\" Assign iterator and return self. \"\"\" self . it = self . iter_pieces () return self def __next__ ( self ): \"\"\" Yield back result of comparison. \"\"\" try : partial = next ( self . it ) except StopIteration as itererror : raise StopIteration from itererror chunck = sha1 ( partial ) . digest () # nosec start = self . piece_count * SHA1 end = start + SHA1 piece = self . pieces [ start : end ] self . piece_count += 1 path = self . paths [ self . index ] return chunck , piece , path , len ( partial ) def iter_pieces ( self ): \"\"\" Iterate through, and hash pieces of torrent contents. Yields ------ piece : bytes hash digest for block of torrent data. \"\"\" partial = bytearray () for i , path in enumerate ( self . paths ): total = self . fileinfo [ i ][ \"length\" ] self . prog_start ( total , path , unit = \"bytes\" ) self . index = i if os . path . exists ( path ): for piece in self . extract ( path , partial ): if ( len ( piece ) == self . piece_length ) or ( i + 1 == len ( self . paths ) ): yield piece else : partial = piece else : length = self . fileinfo [ i ][ \"length\" ] for pad in self . _gen_padding ( partial , length ): if len ( pad ) == self . piece_length : yield pad else : partial = pad self . prog_close () def extract ( self , path : str , partial : bytearray ) -> bytearray : \"\"\" Split file paths contents into blocks of data for hash pieces. Parameters ---------- path : str path to content. partial : bytes any remaining content from last file. Returns ------- bytearray Hash digest for block of .torrent contents. \"\"\" read = 0 length = self . fileinfo [ self . index ][ \"length\" ] partial = bytearray () if len ( partial ) == self . piece_length else partial if path not in self . paths : # pragma: no cover raise MissingPathError ( path ) with open ( path , \"rb\" ) as current : while True : bitlength = self . piece_length - len ( partial ) part = bytearray ( bitlength ) amount = current . readinto ( part ) read += amount partial . extend ( part [: amount ]) if amount < bitlength : if amount > 0 and read == length : self . prog_update ( amount ) yield partial break self . prog_update ( amount ) yield partial partial = bytearray ( 0 ) if length != read : for pad in self . _gen_padding ( partial , length , read ): yield pad def _gen_padding ( self , partial : bytes , length : int , read = 0 ) -> bytes : \"\"\" Create padded pieces where file sizes do not match. Parameters ---------- partial : bytes any remaining data from last file processed. length : int size of space that needs padding read : int portion of length already padded Yields ------ bytes A piece length sized block of zeros. \"\"\" while read < length : left = self . piece_length - len ( partial ) if length - read > left : padding = bytearray ( left ) partial . extend ( padding ) yield partial read += left partial = bytearray ( 0 ) else : partial . extend ( bytearray ( length - read )) read = length yield partial __init__ ( checker ) \u00a4 Generate hashes of piece length data from filelist contents. Source code in torrentfile\\recheck.py 332 333 334 335 336 337 338 339 340 341 342 343 def __init__ ( self , checker : Checker ): \"\"\" Generate hashes of piece length data from filelist contents. \"\"\" self . piece_length = checker . piece_length self . paths = checker . paths self . pieces = checker . info [ \"pieces\" ] self . fileinfo = checker . fileinfo self . piece_map = {} self . index = 0 self . piece_count = 0 self . it = None __iter__ () \u00a4 Assign iterator and return self. Source code in torrentfile\\recheck.py 345 346 347 348 349 350 def __iter__ ( self ): \"\"\" Assign iterator and return self. \"\"\" self . it = self . iter_pieces () return self __next__ () \u00a4 Yield back result of comparison. Source code in torrentfile\\recheck.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 def __next__ ( self ): \"\"\" Yield back result of comparison. \"\"\" try : partial = next ( self . it ) except StopIteration as itererror : raise StopIteration from itererror chunck = sha1 ( partial ) . digest () # nosec start = self . piece_count * SHA1 end = start + SHA1 piece = self . pieces [ start : end ] self . piece_count += 1 path = self . paths [ self . index ] return chunck , piece , path , len ( partial ) _gen_padding ( partial , length , read = 0 ) \u00a4 Create padded pieces where file sizes do not match. Parameters \u00a4 bytes any remaining data from last file processed. int size of space that needs padding int portion of length already padded Yields \u00a4 bytes A piece length sized block of zeros. Source code in torrentfile\\recheck.py 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 def _gen_padding ( self , partial : bytes , length : int , read = 0 ) -> bytes : \"\"\" Create padded pieces where file sizes do not match. Parameters ---------- partial : bytes any remaining data from last file processed. length : int size of space that needs padding read : int portion of length already padded Yields ------ bytes A piece length sized block of zeros. \"\"\" while read < length : left = self . piece_length - len ( partial ) if length - read > left : padding = bytearray ( left ) partial . extend ( padding ) yield partial read += left partial = bytearray ( 0 ) else : partial . extend ( bytearray ( length - read )) read = length yield partial extract ( path , partial ) \u00a4 Split file paths contents into blocks of data for hash pieces. Parameters \u00a4 str path to content. bytes any remaining content from last file. Returns \u00a4 bytearray Hash digest for block of .torrent contents. Source code in torrentfile\\recheck.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 def extract ( self , path : str , partial : bytearray ) -> bytearray : \"\"\" Split file paths contents into blocks of data for hash pieces. Parameters ---------- path : str path to content. partial : bytes any remaining content from last file. Returns ------- bytearray Hash digest for block of .torrent contents. \"\"\" read = 0 length = self . fileinfo [ self . index ][ \"length\" ] partial = bytearray () if len ( partial ) == self . piece_length else partial if path not in self . paths : # pragma: no cover raise MissingPathError ( path ) with open ( path , \"rb\" ) as current : while True : bitlength = self . piece_length - len ( partial ) part = bytearray ( bitlength ) amount = current . readinto ( part ) read += amount partial . extend ( part [: amount ]) if amount < bitlength : if amount > 0 and read == length : self . prog_update ( amount ) yield partial break self . prog_update ( amount ) yield partial partial = bytearray ( 0 ) if length != read : for pad in self . _gen_padding ( partial , length , read ): yield pad iter_pieces () \u00a4 Iterate through, and hash pieces of torrent contents. Yields \u00a4 bytes hash digest for block of torrent data. Source code in torrentfile\\recheck.py 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 def iter_pieces ( self ): \"\"\" Iterate through, and hash pieces of torrent contents. Yields ------ piece : bytes hash digest for block of torrent data. \"\"\" partial = bytearray () for i , path in enumerate ( self . paths ): total = self . fileinfo [ i ][ \"length\" ] self . prog_start ( total , path , unit = \"bytes\" ) self . index = i if os . path . exists ( path ): for piece in self . extract ( path , partial ): if ( len ( piece ) == self . piece_length ) or ( i + 1 == len ( self . paths ) ): yield piece else : partial = piece else : length = self . fileinfo [ i ][ \"length\" ] for pad in self . _gen_padding ( partial , length ): if len ( pad ) == self . piece_length : yield pad else : partial = pad self . prog_close () HashChecker \u00a4 Bases: ProgMixin Iterate through contents of meta data and verify with file contents. Parameters \u00a4 Checker the checker instance that maintains variables. Source code in torrentfile\\recheck.py 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 class HashChecker ( ProgMixin ): \"\"\" Iterate through contents of meta data and verify with file contents. Parameters ---------- checker : Checker the checker instance that maintains variables. \"\"\" def __init__ ( self , checker : Checker ): \"\"\" Construct a HybridChecker instance. \"\"\" self . checker = checker self . paths = checker . paths self . piece_length = checker . piece_length self . fileinfo = checker . fileinfo self . piece_layers = checker . meta [ \"piece layers\" ] self . current = None self . index = - 1 def __iter__ ( self ): \"\"\" Assign iterator and return self. \"\"\" return self def __next__ ( self ): \"\"\" Provide the result of comparison. \"\"\" if self . current is None : self . next_file () try : return self . process_current () except StopIteration as itererr : if self . next_file (): return self . process_current () raise StopIteration from itererr class Padder : \"\"\" Padding class to generate padding hashes wherever needed. Parameters ---------- length: int the total size of the mock file generating padding for. piece_length : int the block size that each hash represents. \"\"\" def __init__ ( self , length , piece_length ): \"\"\" Construct padding class to Mock missing or incomplete files. Parameters ---------- length : int size of the file piece_length : int the piece length for each iteration. \"\"\" self . length = length self . piece_length = piece_length self . pad = sha256 ( bytearray ( piece_length )) . digest () def __iter__ ( self ): \"\"\" Return self to correctly implement iterator type. \"\"\" return self # pragma: nocover def __next__ ( self ) -> bytes : \"\"\" Iterate through seemingly endless sha256 hashes of zeros. Returns ------- tuple : returns the padding Raises ------ StopIteration \"\"\" if self . length >= self . piece_length : self . length -= self . piece_length return self . pad if self . length > 0 : pad = sha256 ( bytearray ( self . length )) . digest () self . length -= self . length return pad raise StopIteration def next_file ( self ) -> bool : \"\"\" Remove all references to processed files and prepare for the next. Returns ------- bool if there is a next file found \"\"\" self . index += 1 self . prog_close () if self . current is None or self . index < len ( self . paths ): self . current = self . paths [ self . index ] self . length = self . fileinfo [ self . index ][ \"length\" ] self . root_hash = self . fileinfo [ self . index ][ \"pieces root\" ] if self . length > self . piece_length : self . pieces = self . piece_layers [ self . root_hash ] else : self . pieces = self . root_hash path = self . paths [ self . index ] self . prog_start ( self . length , path , unit = \"bytes\" ) self . count = 0 if os . path . exists ( self . current ): self . hasher = FileHasher ( path , self . piece_length , progress = 0 ) else : self . hasher = self . Padder ( self . length , self . piece_length ) return True if self . index >= len ( self . paths ): del self . current del self . length del self . root_hash del self . pieces return False def process_current ( self ) -> tuple : \"\"\" Gather necessary information to compare to metafile details. Returns ------- tuple a tuple containing the layer, piece, current path and size Raises ------ StopIteration \"\"\" try : layer = next ( self . hasher ) piece , size = self . advance () self . prog_update ( size ) return layer , piece , self . current , size except StopIteration as err : if self . length > 0 and self . count * SHA256 < len ( self . pieces ): self . hasher = self . Padder ( self . length , self . piece_length ) piece , size = self . advance () layer = next ( self . hasher ) self . prog_update ( 0 ) return layer , piece , self . current , size raise StopIteration from err def advance ( self ) -> tuple : \"\"\" Increment the number of pieces processed for the current file. Returns ------- tuple the piece and size \"\"\" start = self . count * SHA256 end = start + SHA256 piece = self . pieces [ start : end ] self . count += 1 if self . length >= self . piece_length : self . length -= self . piece_length size = self . piece_length else : size = self . length self . length -= self . length return piece , size Padder \u00a4 Padding class to generate padding hashes wherever needed. Parameters \u00a4 int the total size of the mock file generating padding for. int the block size that each hash represents. Source code in torrentfile\\recheck.py 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 class Padder : \"\"\" Padding class to generate padding hashes wherever needed. Parameters ---------- length: int the total size of the mock file generating padding for. piece_length : int the block size that each hash represents. \"\"\" def __init__ ( self , length , piece_length ): \"\"\" Construct padding class to Mock missing or incomplete files. Parameters ---------- length : int size of the file piece_length : int the piece length for each iteration. \"\"\" self . length = length self . piece_length = piece_length self . pad = sha256 ( bytearray ( piece_length )) . digest () def __iter__ ( self ): \"\"\" Return self to correctly implement iterator type. \"\"\" return self # pragma: nocover def __next__ ( self ) -> bytes : \"\"\" Iterate through seemingly endless sha256 hashes of zeros. Returns ------- tuple : returns the padding Raises ------ StopIteration \"\"\" if self . length >= self . piece_length : self . length -= self . piece_length return self . pad if self . length > 0 : pad = sha256 ( bytearray ( self . length )) . digest () self . length -= self . length return pad raise StopIteration __init__ ( length , piece_length ) \u00a4 Construct padding class to Mock missing or incomplete files. Parameters \u00a4 int size of the file int the piece length for each iteration. Source code in torrentfile\\recheck.py 526 527 528 529 530 531 532 533 534 535 536 537 538 539 def __init__ ( self , length , piece_length ): \"\"\" Construct padding class to Mock missing or incomplete files. Parameters ---------- length : int size of the file piece_length : int the piece length for each iteration. \"\"\" self . length = length self . piece_length = piece_length self . pad = sha256 ( bytearray ( piece_length )) . digest () __iter__ () \u00a4 Return self to correctly implement iterator type. Source code in torrentfile\\recheck.py 541 542 543 544 545 def __iter__ ( self ): \"\"\" Return self to correctly implement iterator type. \"\"\" return self # pragma: nocover __next__ () \u00a4 Iterate through seemingly endless sha256 hashes of zeros. Returns \u00a4 tuple returns the padding Raises \u00a4 StopIteration Source code in torrentfile\\recheck.py 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 def __next__ ( self ) -> bytes : \"\"\" Iterate through seemingly endless sha256 hashes of zeros. Returns ------- tuple : returns the padding Raises ------ StopIteration \"\"\" if self . length >= self . piece_length : self . length -= self . piece_length return self . pad if self . length > 0 : pad = sha256 ( bytearray ( self . length )) . digest () self . length -= self . length return pad raise StopIteration __init__ ( checker ) \u00a4 Construct a HybridChecker instance. Source code in torrentfile\\recheck.py 483 484 485 486 487 488 489 490 491 492 493 def __init__ ( self , checker : Checker ): \"\"\" Construct a HybridChecker instance. \"\"\" self . checker = checker self . paths = checker . paths self . piece_length = checker . piece_length self . fileinfo = checker . fileinfo self . piece_layers = checker . meta [ \"piece layers\" ] self . current = None self . index = - 1 __iter__ () \u00a4 Assign iterator and return self. Source code in torrentfile\\recheck.py 495 496 497 498 499 def __iter__ ( self ): \"\"\" Assign iterator and return self. \"\"\" return self __next__ () \u00a4 Provide the result of comparison. Source code in torrentfile\\recheck.py 501 502 503 504 505 506 507 508 509 510 511 512 def __next__ ( self ): \"\"\" Provide the result of comparison. \"\"\" if self . current is None : self . next_file () try : return self . process_current () except StopIteration as itererr : if self . next_file (): return self . process_current () raise StopIteration from itererr advance () \u00a4 Increment the number of pieces processed for the current file. Returns \u00a4 tuple the piece and size Source code in torrentfile\\recheck.py 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 def advance ( self ) -> tuple : \"\"\" Increment the number of pieces processed for the current file. Returns ------- tuple the piece and size \"\"\" start = self . count * SHA256 end = start + SHA256 piece = self . pieces [ start : end ] self . count += 1 if self . length >= self . piece_length : self . length -= self . piece_length size = self . piece_length else : size = self . length self . length -= self . length return piece , size next_file () \u00a4 Remove all references to processed files and prepare for the next. Returns \u00a4 bool if there is a next file found Source code in torrentfile\\recheck.py 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 def next_file ( self ) -> bool : \"\"\" Remove all references to processed files and prepare for the next. Returns ------- bool if there is a next file found \"\"\" self . index += 1 self . prog_close () if self . current is None or self . index < len ( self . paths ): self . current = self . paths [ self . index ] self . length = self . fileinfo [ self . index ][ \"length\" ] self . root_hash = self . fileinfo [ self . index ][ \"pieces root\" ] if self . length > self . piece_length : self . pieces = self . piece_layers [ self . root_hash ] else : self . pieces = self . root_hash path = self . paths [ self . index ] self . prog_start ( self . length , path , unit = \"bytes\" ) self . count = 0 if os . path . exists ( self . current ): self . hasher = FileHasher ( path , self . piece_length , progress = 0 ) else : self . hasher = self . Padder ( self . length , self . piece_length ) return True if self . index >= len ( self . paths ): del self . current del self . length del self . root_hash del self . pieces return False process_current () \u00a4 Gather necessary information to compare to metafile details. Returns \u00a4 tuple a tuple containing the layer, piece, current path and size Raises \u00a4 StopIteration Source code in torrentfile\\recheck.py 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 def process_current ( self ) -> tuple : \"\"\" Gather necessary information to compare to metafile details. Returns ------- tuple a tuple containing the layer, piece, current path and size Raises ------ StopIteration \"\"\" try : layer = next ( self . hasher ) piece , size = self . advance () self . prog_update ( size ) return layer , piece , self . current , size except StopIteration as err : if self . length > 0 and self . count * SHA256 < len ( self . pieces ): self . hasher = self . Padder ( self . length , self . piece_length ) piece , size = self . advance () layer = next ( self . hasher ) self . prog_update ( 0 ) return layer , piece , self . current , size raise StopIteration from err","title":"recheck"},{"location":"recheck/#torrentfile.recheck.Checker","text":"Check a given file or directory to see if it matches a torrentfile. Public constructor for Checker class instance.","title":"Checker"},{"location":"recheck/#torrentfile.recheck.Checker--parameters","text":"str Path to \".torrent\" file. str Path where the content is located in filesystem.","title":"Parameters"},{"location":"recheck/#torrentfile.recheck.Checker--example","text":">> metafile = \"/path/to/torrentfile/content_file_or_dir.torrent\" >> location = \"/path/to/location\" >> os.path.exists(\"/path/to/location/content_file_or_dir\") Out: True >> checker = Checker(metafile, location) Source code in torrentfile\\recheck.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 class Checker : \"\"\" Check a given file or directory to see if it matches a torrentfile. Public constructor for Checker class instance. Parameters ---------- metafile : str Path to \".torrent\" file. path : str Path where the content is located in filesystem. Example ------- >> metafile = \"/path/to/torrentfile/content_file_or_dir.torrent\" >> location = \"/path/to/location\" >> os.path.exists(\"/path/to/location/content_file_or_dir\") Out: True >> checker = Checker(metafile, location) \"\"\" _hook = None def __init__ ( self , metafile : str , path : str ): \"\"\" Validate data against hashes contained in .torrent file. Parameters ---------- metafile : str path to .torrent file path : str path to content or contents parent directory. \"\"\" if not os . path . exists ( metafile ): raise FileNotFoundError if os . path . isdir ( metafile ): raise ArgumentError ( \"The <metafile> must be a .torrent file. Not a directory\" ) self . last_log = None self . log_msg ( \"Checking: %s , %s \" , metafile , path ) self . metafile = metafile self . total = 0 self . paths = [] self . fileinfo = {} print ( \"Extracting data from torrent file...\" ) self . meta = pyben . load ( metafile ) self . info = self . meta [ \"info\" ] self . name = self . info [ \"name\" ] self . piece_length = self . info [ \"piece length\" ] if \"meta version\" in self . info : if \"pieces\" in self . info : self . meta_version = 3 else : self . meta_version = 2 else : self . meta_version = 1 self . root = self . find_root ( path ) self . check_paths () @classmethod def register_callback ( cls , hook ): \"\"\" Register hooks from 3rd party programs to access generated info. Parameters ---------- hook : function callback function for the logging feature. \"\"\" cls . _hook = hook def piece_checker ( self ): \"\"\" Check individual pieces of the torrent. Returns ------- HashChecker | FeedChecker Individual piece hasher. \"\"\" if self . meta_version == 1 : return FeedChecker return HashChecker def results ( self ): \"\"\" Generate result percentage and store for future calls. \"\"\" responses = [] for response in self . iter_hashes (): responses . append ( response ) self . log_msg ( \"Final result for %s recheck: %s \" , self . metafile , self . _result ) return self . _result def log_msg ( self , * args , level : int = logging . INFO ): \"\"\" Log message `msg` to logger and send `msg` to callback hook. Parameters ---------- *args : dict formatting args for log message level : int Log level for this message; default=`logging.INFO` \"\"\" message = args [ 0 ] if len ( args ) >= 3 : message = message % tuple ( args [ 1 :]) elif len ( args ) == 2 : message = message % args [ 1 ] # Repeat log messages should be ignored. if message != self . last_log : self . last_log = message logger . log ( level , message ) if self . _hook and level == logging . INFO : self . _hook ( message ) def find_root ( self , path : str ) -> str : \"\"\" Check path for torrent content. The path can be a relative or absolute filesystem path. In the case where the content is a single file, the path may point directly to the the file, or it may point to the parent directory. If content points to a directory. The directory will be checked to see if it matches the torrent's name, if not the directories contents will be searched. The returned value will be the absolute path that matches the torrent's name. Parameters ---------- path : str root path to torrent content Returns ------- str root path to content \"\"\" if not os . path . exists ( path ): self . log_msg ( \"Could not locate torrent content %s .\" , path ) raise FileNotFoundError ( path ) root = Path ( path ) if root . name == self . name : self . log_msg ( \"Content found: %s .\" , str ( root )) return root if self . name in os . listdir ( root ): return root / self . name self . log_msg ( \"Could not locate torrent content in: %s \" , str ( root )) raise FileNotFoundError ( root ) def check_paths ( self ): \"\"\" Gather all file paths described in the torrent file. \"\"\" finfo = self . fileinfo if \"length\" in self . info : self . log_msg ( \" %s points to a single file\" , self . root ) self . total = self . info [ \"length\" ] self . paths . append ( str ( self . root )) finfo [ 0 ] = { \"path\" : self . root , \"length\" : self . info [ \"length\" ], } if self . meta_version > 1 : root = self . info [ \"file tree\" ][ self . name ][ \"\" ][ \"pieces root\" ] finfo [ 0 ][ \"pieces root\" ] = root return # Otherwise Content is more than 1 file. self . log_msg ( \" %s points to a directory\" , self . root ) if self . meta_version == 1 : for i , item in enumerate ( self . info [ \"files\" ]): self . total += item [ \"length\" ] base = os . path . join ( * item [ \"path\" ]) self . fileinfo [ i ] = { \"path\" : str ( self . root / base ), \"length\" : item [ \"length\" ], } self . paths . append ( str ( self . root / base )) return self . walk_file_tree ( self . info [ \"file tree\" ], []) def walk_file_tree ( self , tree : dict , partials : list ): \"\"\" Traverse File Tree dictionary to get file details. Extract full pathnames, length, root hash, and layer hashes for each file included in the .torrent's file tree. Parameters ---------- tree : dict File Tree dict extracted from torrent file. partials : list list of intermediate pathnames. \"\"\" for key , val in tree . items (): # Empty string means the tree's leaf is value if \"\" in val : base = os . path . join ( * partials , key ) roothash = None length = val [ \"\" ][ \"length\" ] roothash = None if not length else val [ \"\" ][ \"pieces root\" ] full = str ( self . root / base ) self . fileinfo [ len ( self . paths )] = { \"path\" : full , \"length\" : length , \"pieces root\" : roothash , } self . paths . append ( full ) self . total += length else : self . walk_file_tree ( val , partials + [ key ]) def iter_hashes ( self ) -> tuple : \"\"\" Produce results of comparing torrent contents piece by piece. Yields ------ chunck : bytes hash of data found on disk piece : bytes hash of data when complete and correct path : str path to file being hashed size : int length of bytes hashed for piece \"\"\" matched = consumed = 0 checker = self . piece_checker () for chunk , piece , path , size in checker ( self ): consumed += size matching = 0 if chunk == piece : matching += size matched += size yield chunk , piece , path , size total_consumed = str ( int ( consumed / self . total * 100 )) percent_matched = str ( int ( matched / consumed * 100 )) self . log_msg ( \"Processed: %s%% , Matched: %s%% \" , total_consumed , percent_matched , ) self . _result = ( matched / consumed ) * 100 if consumed > 0 else 0","title":"Example"},{"location":"recheck/#torrentfile.recheck.Checker.__init__","text":"Validate data against hashes contained in .torrent file.","title":"__init__()"},{"location":"recheck/#torrentfile.recheck.Checker.__init__--parameters","text":"str path to .torrent file str path to content or contents parent directory. Source code in torrentfile\\recheck.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def __init__ ( self , metafile : str , path : str ): \"\"\" Validate data against hashes contained in .torrent file. Parameters ---------- metafile : str path to .torrent file path : str path to content or contents parent directory. \"\"\" if not os . path . exists ( metafile ): raise FileNotFoundError if os . path . isdir ( metafile ): raise ArgumentError ( \"The <metafile> must be a .torrent file. Not a directory\" ) self . last_log = None self . log_msg ( \"Checking: %s , %s \" , metafile , path ) self . metafile = metafile self . total = 0 self . paths = [] self . fileinfo = {} print ( \"Extracting data from torrent file...\" ) self . meta = pyben . load ( metafile ) self . info = self . meta [ \"info\" ] self . name = self . info [ \"name\" ] self . piece_length = self . info [ \"piece length\" ] if \"meta version\" in self . info : if \"pieces\" in self . info : self . meta_version = 3 else : self . meta_version = 2 else : self . meta_version = 1 self . root = self . find_root ( path ) self . check_paths ()","title":"Parameters"},{"location":"recheck/#torrentfile.recheck.Checker.check_paths","text":"Gather all file paths described in the torrent file. Source code in torrentfile\\recheck.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 def check_paths ( self ): \"\"\" Gather all file paths described in the torrent file. \"\"\" finfo = self . fileinfo if \"length\" in self . info : self . log_msg ( \" %s points to a single file\" , self . root ) self . total = self . info [ \"length\" ] self . paths . append ( str ( self . root )) finfo [ 0 ] = { \"path\" : self . root , \"length\" : self . info [ \"length\" ], } if self . meta_version > 1 : root = self . info [ \"file tree\" ][ self . name ][ \"\" ][ \"pieces root\" ] finfo [ 0 ][ \"pieces root\" ] = root return # Otherwise Content is more than 1 file. self . log_msg ( \" %s points to a directory\" , self . root ) if self . meta_version == 1 : for i , item in enumerate ( self . info [ \"files\" ]): self . total += item [ \"length\" ] base = os . path . join ( * item [ \"path\" ]) self . fileinfo [ i ] = { \"path\" : str ( self . root / base ), \"length\" : item [ \"length\" ], } self . paths . append ( str ( self . root / base )) return self . walk_file_tree ( self . info [ \"file tree\" ], [])","title":"check_paths()"},{"location":"recheck/#torrentfile.recheck.Checker.find_root","text":"Check path for torrent content. The path can be a relative or absolute filesystem path. In the case where the content is a single file, the path may point directly to the the file, or it may point to the parent directory. If content points to a directory. The directory will be checked to see if it matches the torrent's name, if not the directories contents will be searched. The returned value will be the absolute path that matches the torrent's name.","title":"find_root()"},{"location":"recheck/#torrentfile.recheck.Checker.find_root--parameters","text":"str root path to torrent content","title":"Parameters"},{"location":"recheck/#torrentfile.recheck.Checker.find_root--returns","text":"str root path to content Source code in torrentfile\\recheck.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def find_root ( self , path : str ) -> str : \"\"\" Check path for torrent content. The path can be a relative or absolute filesystem path. In the case where the content is a single file, the path may point directly to the the file, or it may point to the parent directory. If content points to a directory. The directory will be checked to see if it matches the torrent's name, if not the directories contents will be searched. The returned value will be the absolute path that matches the torrent's name. Parameters ---------- path : str root path to torrent content Returns ------- str root path to content \"\"\" if not os . path . exists ( path ): self . log_msg ( \"Could not locate torrent content %s .\" , path ) raise FileNotFoundError ( path ) root = Path ( path ) if root . name == self . name : self . log_msg ( \"Content found: %s .\" , str ( root )) return root if self . name in os . listdir ( root ): return root / self . name self . log_msg ( \"Could not locate torrent content in: %s \" , str ( root )) raise FileNotFoundError ( root )","title":"Returns"},{"location":"recheck/#torrentfile.recheck.Checker.iter_hashes","text":"Produce results of comparing torrent contents piece by piece.","title":"iter_hashes()"},{"location":"recheck/#torrentfile.recheck.Checker.iter_hashes--yields","text":"bytes hash of data found on disk bytes hash of data when complete and correct str path to file being hashed int length of bytes hashed for piece Source code in torrentfile\\recheck.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 def iter_hashes ( self ) -> tuple : \"\"\" Produce results of comparing torrent contents piece by piece. Yields ------ chunck : bytes hash of data found on disk piece : bytes hash of data when complete and correct path : str path to file being hashed size : int length of bytes hashed for piece \"\"\" matched = consumed = 0 checker = self . piece_checker () for chunk , piece , path , size in checker ( self ): consumed += size matching = 0 if chunk == piece : matching += size matched += size yield chunk , piece , path , size total_consumed = str ( int ( consumed / self . total * 100 )) percent_matched = str ( int ( matched / consumed * 100 )) self . log_msg ( \"Processed: %s%% , Matched: %s%% \" , total_consumed , percent_matched , ) self . _result = ( matched / consumed ) * 100 if consumed > 0 else 0","title":"Yields"},{"location":"recheck/#torrentfile.recheck.Checker.log_msg","text":"Log message msg to logger and send msg to callback hook.","title":"log_msg()"},{"location":"recheck/#torrentfile.recheck.Checker.log_msg--parameters","text":"*args : dict formatting args for log message int Log level for this message; default= logging.INFO Source code in torrentfile\\recheck.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def log_msg ( self , * args , level : int = logging . INFO ): \"\"\" Log message `msg` to logger and send `msg` to callback hook. Parameters ---------- *args : dict formatting args for log message level : int Log level for this message; default=`logging.INFO` \"\"\" message = args [ 0 ] if len ( args ) >= 3 : message = message % tuple ( args [ 1 :]) elif len ( args ) == 2 : message = message % args [ 1 ] # Repeat log messages should be ignored. if message != self . last_log : self . last_log = message logger . log ( level , message ) if self . _hook and level == logging . INFO : self . _hook ( message )","title":"Parameters"},{"location":"recheck/#torrentfile.recheck.Checker.piece_checker","text":"Check individual pieces of the torrent.","title":"piece_checker()"},{"location":"recheck/#torrentfile.recheck.Checker.piece_checker--returns","text":"HashChecker | FeedChecker Individual piece hasher. Source code in torrentfile\\recheck.py 123 124 125 126 127 128 129 130 131 132 133 134 def piece_checker ( self ): \"\"\" Check individual pieces of the torrent. Returns ------- HashChecker | FeedChecker Individual piece hasher. \"\"\" if self . meta_version == 1 : return FeedChecker return HashChecker","title":"Returns"},{"location":"recheck/#torrentfile.recheck.Checker.register_callback","text":"Register hooks from 3rd party programs to access generated info.","title":"register_callback()"},{"location":"recheck/#torrentfile.recheck.Checker.register_callback--parameters","text":"function callback function for the logging feature. Source code in torrentfile\\recheck.py 111 112 113 114 115 116 117 118 119 120 121 @classmethod def register_callback ( cls , hook ): \"\"\" Register hooks from 3rd party programs to access generated info. Parameters ---------- hook : function callback function for the logging feature. \"\"\" cls . _hook = hook","title":"Parameters"},{"location":"recheck/#torrentfile.recheck.Checker.results","text":"Generate result percentage and store for future calls. Source code in torrentfile\\recheck.py 136 137 138 139 140 141 142 143 144 145 146 147 148 def results ( self ): \"\"\" Generate result percentage and store for future calls. \"\"\" responses = [] for response in self . iter_hashes (): responses . append ( response ) self . log_msg ( \"Final result for %s recheck: %s \" , self . metafile , self . _result ) return self . _result","title":"results()"},{"location":"recheck/#torrentfile.recheck.Checker.walk_file_tree","text":"Traverse File Tree dictionary to get file details. Extract full pathnames, length, root hash, and layer hashes for each file included in the .torrent's file tree.","title":"walk_file_tree()"},{"location":"recheck/#torrentfile.recheck.Checker.walk_file_tree--parameters","text":"dict File Tree dict extracted from torrent file. list list of intermediate pathnames. Source code in torrentfile\\recheck.py 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 def walk_file_tree ( self , tree : dict , partials : list ): \"\"\" Traverse File Tree dictionary to get file details. Extract full pathnames, length, root hash, and layer hashes for each file included in the .torrent's file tree. Parameters ---------- tree : dict File Tree dict extracted from torrent file. partials : list list of intermediate pathnames. \"\"\" for key , val in tree . items (): # Empty string means the tree's leaf is value if \"\" in val : base = os . path . join ( * partials , key ) roothash = None length = val [ \"\" ][ \"length\" ] roothash = None if not length else val [ \"\" ][ \"pieces root\" ] full = str ( self . root / base ) self . fileinfo [ len ( self . paths )] = { \"path\" : full , \"length\" : length , \"pieces root\" : roothash , } self . paths . append ( full ) self . total += length else : self . walk_file_tree ( val , partials + [ key ])","title":"Parameters"},{"location":"recheck/#torrentfile.recheck.FeedChecker","text":"Bases: ProgMixin Validates torrent content. Seemlesly validate torrent file contents by comparing hashes in metafile against data on disk.","title":"FeedChecker"},{"location":"recheck/#torrentfile.recheck.FeedChecker--parameters","text":"object the checker class instance. Source code in torrentfile\\recheck.py 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 class FeedChecker ( ProgMixin ): \"\"\" Validates torrent content. Seemlesly validate torrent file contents by comparing hashes in metafile against data on disk. Parameters ---------- checker : object the checker class instance. \"\"\" def __init__ ( self , checker : Checker ): \"\"\" Generate hashes of piece length data from filelist contents. \"\"\" self . piece_length = checker . piece_length self . paths = checker . paths self . pieces = checker . info [ \"pieces\" ] self . fileinfo = checker . fileinfo self . piece_map = {} self . index = 0 self . piece_count = 0 self . it = None def __iter__ ( self ): \"\"\" Assign iterator and return self. \"\"\" self . it = self . iter_pieces () return self def __next__ ( self ): \"\"\" Yield back result of comparison. \"\"\" try : partial = next ( self . it ) except StopIteration as itererror : raise StopIteration from itererror chunck = sha1 ( partial ) . digest () # nosec start = self . piece_count * SHA1 end = start + SHA1 piece = self . pieces [ start : end ] self . piece_count += 1 path = self . paths [ self . index ] return chunck , piece , path , len ( partial ) def iter_pieces ( self ): \"\"\" Iterate through, and hash pieces of torrent contents. Yields ------ piece : bytes hash digest for block of torrent data. \"\"\" partial = bytearray () for i , path in enumerate ( self . paths ): total = self . fileinfo [ i ][ \"length\" ] self . prog_start ( total , path , unit = \"bytes\" ) self . index = i if os . path . exists ( path ): for piece in self . extract ( path , partial ): if ( len ( piece ) == self . piece_length ) or ( i + 1 == len ( self . paths ) ): yield piece else : partial = piece else : length = self . fileinfo [ i ][ \"length\" ] for pad in self . _gen_padding ( partial , length ): if len ( pad ) == self . piece_length : yield pad else : partial = pad self . prog_close () def extract ( self , path : str , partial : bytearray ) -> bytearray : \"\"\" Split file paths contents into blocks of data for hash pieces. Parameters ---------- path : str path to content. partial : bytes any remaining content from last file. Returns ------- bytearray Hash digest for block of .torrent contents. \"\"\" read = 0 length = self . fileinfo [ self . index ][ \"length\" ] partial = bytearray () if len ( partial ) == self . piece_length else partial if path not in self . paths : # pragma: no cover raise MissingPathError ( path ) with open ( path , \"rb\" ) as current : while True : bitlength = self . piece_length - len ( partial ) part = bytearray ( bitlength ) amount = current . readinto ( part ) read += amount partial . extend ( part [: amount ]) if amount < bitlength : if amount > 0 and read == length : self . prog_update ( amount ) yield partial break self . prog_update ( amount ) yield partial partial = bytearray ( 0 ) if length != read : for pad in self . _gen_padding ( partial , length , read ): yield pad def _gen_padding ( self , partial : bytes , length : int , read = 0 ) -> bytes : \"\"\" Create padded pieces where file sizes do not match. Parameters ---------- partial : bytes any remaining data from last file processed. length : int size of space that needs padding read : int portion of length already padded Yields ------ bytes A piece length sized block of zeros. \"\"\" while read < length : left = self . piece_length - len ( partial ) if length - read > left : padding = bytearray ( left ) partial . extend ( padding ) yield partial read += left partial = bytearray ( 0 ) else : partial . extend ( bytearray ( length - read )) read = length yield partial","title":"Parameters"},{"location":"recheck/#torrentfile.recheck.FeedChecker.__init__","text":"Generate hashes of piece length data from filelist contents. Source code in torrentfile\\recheck.py 332 333 334 335 336 337 338 339 340 341 342 343 def __init__ ( self , checker : Checker ): \"\"\" Generate hashes of piece length data from filelist contents. \"\"\" self . piece_length = checker . piece_length self . paths = checker . paths self . pieces = checker . info [ \"pieces\" ] self . fileinfo = checker . fileinfo self . piece_map = {} self . index = 0 self . piece_count = 0 self . it = None","title":"__init__()"},{"location":"recheck/#torrentfile.recheck.FeedChecker.__iter__","text":"Assign iterator and return self. Source code in torrentfile\\recheck.py 345 346 347 348 349 350 def __iter__ ( self ): \"\"\" Assign iterator and return self. \"\"\" self . it = self . iter_pieces () return self","title":"__iter__()"},{"location":"recheck/#torrentfile.recheck.FeedChecker.__next__","text":"Yield back result of comparison. Source code in torrentfile\\recheck.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 def __next__ ( self ): \"\"\" Yield back result of comparison. \"\"\" try : partial = next ( self . it ) except StopIteration as itererror : raise StopIteration from itererror chunck = sha1 ( partial ) . digest () # nosec start = self . piece_count * SHA1 end = start + SHA1 piece = self . pieces [ start : end ] self . piece_count += 1 path = self . paths [ self . index ] return chunck , piece , path , len ( partial )","title":"__next__()"},{"location":"recheck/#torrentfile.recheck.FeedChecker._gen_padding","text":"Create padded pieces where file sizes do not match.","title":"_gen_padding()"},{"location":"recheck/#torrentfile.recheck.FeedChecker._gen_padding--parameters","text":"bytes any remaining data from last file processed. int size of space that needs padding int portion of length already padded","title":"Parameters"},{"location":"recheck/#torrentfile.recheck.FeedChecker._gen_padding--yields","text":"bytes A piece length sized block of zeros. Source code in torrentfile\\recheck.py 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 def _gen_padding ( self , partial : bytes , length : int , read = 0 ) -> bytes : \"\"\" Create padded pieces where file sizes do not match. Parameters ---------- partial : bytes any remaining data from last file processed. length : int size of space that needs padding read : int portion of length already padded Yields ------ bytes A piece length sized block of zeros. \"\"\" while read < length : left = self . piece_length - len ( partial ) if length - read > left : padding = bytearray ( left ) partial . extend ( padding ) yield partial read += left partial = bytearray ( 0 ) else : partial . extend ( bytearray ( length - read )) read = length yield partial","title":"Yields"},{"location":"recheck/#torrentfile.recheck.FeedChecker.extract","text":"Split file paths contents into blocks of data for hash pieces.","title":"extract()"},{"location":"recheck/#torrentfile.recheck.FeedChecker.extract--parameters","text":"str path to content. bytes any remaining content from last file.","title":"Parameters"},{"location":"recheck/#torrentfile.recheck.FeedChecker.extract--returns","text":"bytearray Hash digest for block of .torrent contents. Source code in torrentfile\\recheck.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 def extract ( self , path : str , partial : bytearray ) -> bytearray : \"\"\" Split file paths contents into blocks of data for hash pieces. Parameters ---------- path : str path to content. partial : bytes any remaining content from last file. Returns ------- bytearray Hash digest for block of .torrent contents. \"\"\" read = 0 length = self . fileinfo [ self . index ][ \"length\" ] partial = bytearray () if len ( partial ) == self . piece_length else partial if path not in self . paths : # pragma: no cover raise MissingPathError ( path ) with open ( path , \"rb\" ) as current : while True : bitlength = self . piece_length - len ( partial ) part = bytearray ( bitlength ) amount = current . readinto ( part ) read += amount partial . extend ( part [: amount ]) if amount < bitlength : if amount > 0 and read == length : self . prog_update ( amount ) yield partial break self . prog_update ( amount ) yield partial partial = bytearray ( 0 ) if length != read : for pad in self . _gen_padding ( partial , length , read ): yield pad","title":"Returns"},{"location":"recheck/#torrentfile.recheck.FeedChecker.iter_pieces","text":"Iterate through, and hash pieces of torrent contents.","title":"iter_pieces()"},{"location":"recheck/#torrentfile.recheck.FeedChecker.iter_pieces--yields","text":"bytes hash digest for block of torrent data. Source code in torrentfile\\recheck.py 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 def iter_pieces ( self ): \"\"\" Iterate through, and hash pieces of torrent contents. Yields ------ piece : bytes hash digest for block of torrent data. \"\"\" partial = bytearray () for i , path in enumerate ( self . paths ): total = self . fileinfo [ i ][ \"length\" ] self . prog_start ( total , path , unit = \"bytes\" ) self . index = i if os . path . exists ( path ): for piece in self . extract ( path , partial ): if ( len ( piece ) == self . piece_length ) or ( i + 1 == len ( self . paths ) ): yield piece else : partial = piece else : length = self . fileinfo [ i ][ \"length\" ] for pad in self . _gen_padding ( partial , length ): if len ( pad ) == self . piece_length : yield pad else : partial = pad self . prog_close ()","title":"Yields"},{"location":"recheck/#torrentfile.recheck.HashChecker","text":"Bases: ProgMixin Iterate through contents of meta data and verify with file contents.","title":"HashChecker"},{"location":"recheck/#torrentfile.recheck.HashChecker--parameters","text":"Checker the checker instance that maintains variables. Source code in torrentfile\\recheck.py 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 class HashChecker ( ProgMixin ): \"\"\" Iterate through contents of meta data and verify with file contents. Parameters ---------- checker : Checker the checker instance that maintains variables. \"\"\" def __init__ ( self , checker : Checker ): \"\"\" Construct a HybridChecker instance. \"\"\" self . checker = checker self . paths = checker . paths self . piece_length = checker . piece_length self . fileinfo = checker . fileinfo self . piece_layers = checker . meta [ \"piece layers\" ] self . current = None self . index = - 1 def __iter__ ( self ): \"\"\" Assign iterator and return self. \"\"\" return self def __next__ ( self ): \"\"\" Provide the result of comparison. \"\"\" if self . current is None : self . next_file () try : return self . process_current () except StopIteration as itererr : if self . next_file (): return self . process_current () raise StopIteration from itererr class Padder : \"\"\" Padding class to generate padding hashes wherever needed. Parameters ---------- length: int the total size of the mock file generating padding for. piece_length : int the block size that each hash represents. \"\"\" def __init__ ( self , length , piece_length ): \"\"\" Construct padding class to Mock missing or incomplete files. Parameters ---------- length : int size of the file piece_length : int the piece length for each iteration. \"\"\" self . length = length self . piece_length = piece_length self . pad = sha256 ( bytearray ( piece_length )) . digest () def __iter__ ( self ): \"\"\" Return self to correctly implement iterator type. \"\"\" return self # pragma: nocover def __next__ ( self ) -> bytes : \"\"\" Iterate through seemingly endless sha256 hashes of zeros. Returns ------- tuple : returns the padding Raises ------ StopIteration \"\"\" if self . length >= self . piece_length : self . length -= self . piece_length return self . pad if self . length > 0 : pad = sha256 ( bytearray ( self . length )) . digest () self . length -= self . length return pad raise StopIteration def next_file ( self ) -> bool : \"\"\" Remove all references to processed files and prepare for the next. Returns ------- bool if there is a next file found \"\"\" self . index += 1 self . prog_close () if self . current is None or self . index < len ( self . paths ): self . current = self . paths [ self . index ] self . length = self . fileinfo [ self . index ][ \"length\" ] self . root_hash = self . fileinfo [ self . index ][ \"pieces root\" ] if self . length > self . piece_length : self . pieces = self . piece_layers [ self . root_hash ] else : self . pieces = self . root_hash path = self . paths [ self . index ] self . prog_start ( self . length , path , unit = \"bytes\" ) self . count = 0 if os . path . exists ( self . current ): self . hasher = FileHasher ( path , self . piece_length , progress = 0 ) else : self . hasher = self . Padder ( self . length , self . piece_length ) return True if self . index >= len ( self . paths ): del self . current del self . length del self . root_hash del self . pieces return False def process_current ( self ) -> tuple : \"\"\" Gather necessary information to compare to metafile details. Returns ------- tuple a tuple containing the layer, piece, current path and size Raises ------ StopIteration \"\"\" try : layer = next ( self . hasher ) piece , size = self . advance () self . prog_update ( size ) return layer , piece , self . current , size except StopIteration as err : if self . length > 0 and self . count * SHA256 < len ( self . pieces ): self . hasher = self . Padder ( self . length , self . piece_length ) piece , size = self . advance () layer = next ( self . hasher ) self . prog_update ( 0 ) return layer , piece , self . current , size raise StopIteration from err def advance ( self ) -> tuple : \"\"\" Increment the number of pieces processed for the current file. Returns ------- tuple the piece and size \"\"\" start = self . count * SHA256 end = start + SHA256 piece = self . pieces [ start : end ] self . count += 1 if self . length >= self . piece_length : self . length -= self . piece_length size = self . piece_length else : size = self . length self . length -= self . length return piece , size","title":"Parameters"},{"location":"recheck/#torrentfile.recheck.HashChecker.Padder","text":"Padding class to generate padding hashes wherever needed.","title":"Padder"},{"location":"recheck/#torrentfile.recheck.HashChecker.Padder--parameters","text":"int the total size of the mock file generating padding for. int the block size that each hash represents. Source code in torrentfile\\recheck.py 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 class Padder : \"\"\" Padding class to generate padding hashes wherever needed. Parameters ---------- length: int the total size of the mock file generating padding for. piece_length : int the block size that each hash represents. \"\"\" def __init__ ( self , length , piece_length ): \"\"\" Construct padding class to Mock missing or incomplete files. Parameters ---------- length : int size of the file piece_length : int the piece length for each iteration. \"\"\" self . length = length self . piece_length = piece_length self . pad = sha256 ( bytearray ( piece_length )) . digest () def __iter__ ( self ): \"\"\" Return self to correctly implement iterator type. \"\"\" return self # pragma: nocover def __next__ ( self ) -> bytes : \"\"\" Iterate through seemingly endless sha256 hashes of zeros. Returns ------- tuple : returns the padding Raises ------ StopIteration \"\"\" if self . length >= self . piece_length : self . length -= self . piece_length return self . pad if self . length > 0 : pad = sha256 ( bytearray ( self . length )) . digest () self . length -= self . length return pad raise StopIteration","title":"Parameters"},{"location":"recheck/#torrentfile.recheck.HashChecker.Padder.__init__","text":"Construct padding class to Mock missing or incomplete files.","title":"__init__()"},{"location":"recheck/#torrentfile.recheck.HashChecker.Padder.__init__--parameters","text":"int size of the file int the piece length for each iteration. Source code in torrentfile\\recheck.py 526 527 528 529 530 531 532 533 534 535 536 537 538 539 def __init__ ( self , length , piece_length ): \"\"\" Construct padding class to Mock missing or incomplete files. Parameters ---------- length : int size of the file piece_length : int the piece length for each iteration. \"\"\" self . length = length self . piece_length = piece_length self . pad = sha256 ( bytearray ( piece_length )) . digest ()","title":"Parameters"},{"location":"recheck/#torrentfile.recheck.HashChecker.Padder.__iter__","text":"Return self to correctly implement iterator type. Source code in torrentfile\\recheck.py 541 542 543 544 545 def __iter__ ( self ): \"\"\" Return self to correctly implement iterator type. \"\"\" return self # pragma: nocover","title":"__iter__()"},{"location":"recheck/#torrentfile.recheck.HashChecker.Padder.__next__","text":"Iterate through seemingly endless sha256 hashes of zeros.","title":"__next__()"},{"location":"recheck/#torrentfile.recheck.HashChecker.Padder.__next__--returns","text":"tuple returns the padding","title":"Returns"},{"location":"recheck/#torrentfile.recheck.HashChecker.Padder.__next__--raises","text":"StopIteration Source code in torrentfile\\recheck.py 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 def __next__ ( self ) -> bytes : \"\"\" Iterate through seemingly endless sha256 hashes of zeros. Returns ------- tuple : returns the padding Raises ------ StopIteration \"\"\" if self . length >= self . piece_length : self . length -= self . piece_length return self . pad if self . length > 0 : pad = sha256 ( bytearray ( self . length )) . digest () self . length -= self . length return pad raise StopIteration","title":"Raises"},{"location":"recheck/#torrentfile.recheck.HashChecker.__init__","text":"Construct a HybridChecker instance. Source code in torrentfile\\recheck.py 483 484 485 486 487 488 489 490 491 492 493 def __init__ ( self , checker : Checker ): \"\"\" Construct a HybridChecker instance. \"\"\" self . checker = checker self . paths = checker . paths self . piece_length = checker . piece_length self . fileinfo = checker . fileinfo self . piece_layers = checker . meta [ \"piece layers\" ] self . current = None self . index = - 1","title":"__init__()"},{"location":"recheck/#torrentfile.recheck.HashChecker.__iter__","text":"Assign iterator and return self. Source code in torrentfile\\recheck.py 495 496 497 498 499 def __iter__ ( self ): \"\"\" Assign iterator and return self. \"\"\" return self","title":"__iter__()"},{"location":"recheck/#torrentfile.recheck.HashChecker.__next__","text":"Provide the result of comparison. Source code in torrentfile\\recheck.py 501 502 503 504 505 506 507 508 509 510 511 512 def __next__ ( self ): \"\"\" Provide the result of comparison. \"\"\" if self . current is None : self . next_file () try : return self . process_current () except StopIteration as itererr : if self . next_file (): return self . process_current () raise StopIteration from itererr","title":"__next__()"},{"location":"recheck/#torrentfile.recheck.HashChecker.advance","text":"Increment the number of pieces processed for the current file.","title":"advance()"},{"location":"recheck/#torrentfile.recheck.HashChecker.advance--returns","text":"tuple the piece and size Source code in torrentfile\\recheck.py 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 def advance ( self ) -> tuple : \"\"\" Increment the number of pieces processed for the current file. Returns ------- tuple the piece and size \"\"\" start = self . count * SHA256 end = start + SHA256 piece = self . pieces [ start : end ] self . count += 1 if self . length >= self . piece_length : self . length -= self . piece_length size = self . piece_length else : size = self . length self . length -= self . length return piece , size","title":"Returns"},{"location":"recheck/#torrentfile.recheck.HashChecker.next_file","text":"Remove all references to processed files and prepare for the next.","title":"next_file()"},{"location":"recheck/#torrentfile.recheck.HashChecker.next_file--returns","text":"bool if there is a next file found Source code in torrentfile\\recheck.py 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 def next_file ( self ) -> bool : \"\"\" Remove all references to processed files and prepare for the next. Returns ------- bool if there is a next file found \"\"\" self . index += 1 self . prog_close () if self . current is None or self . index < len ( self . paths ): self . current = self . paths [ self . index ] self . length = self . fileinfo [ self . index ][ \"length\" ] self . root_hash = self . fileinfo [ self . index ][ \"pieces root\" ] if self . length > self . piece_length : self . pieces = self . piece_layers [ self . root_hash ] else : self . pieces = self . root_hash path = self . paths [ self . index ] self . prog_start ( self . length , path , unit = \"bytes\" ) self . count = 0 if os . path . exists ( self . current ): self . hasher = FileHasher ( path , self . piece_length , progress = 0 ) else : self . hasher = self . Padder ( self . length , self . piece_length ) return True if self . index >= len ( self . paths ): del self . current del self . length del self . root_hash del self . pieces return False","title":"Returns"},{"location":"recheck/#torrentfile.recheck.HashChecker.process_current","text":"Gather necessary information to compare to metafile details.","title":"process_current()"},{"location":"recheck/#torrentfile.recheck.HashChecker.process_current--returns","text":"tuple a tuple containing the layer, piece, current path and size","title":"Returns"},{"location":"recheck/#torrentfile.recheck.HashChecker.process_current--raises","text":"StopIteration Source code in torrentfile\\recheck.py 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 def process_current ( self ) -> tuple : \"\"\" Gather necessary information to compare to metafile details. Returns ------- tuple a tuple containing the layer, piece, current path and size Raises ------ StopIteration \"\"\" try : layer = next ( self . hasher ) piece , size = self . advance () self . prog_update ( size ) return layer , piece , self . current , size except StopIteration as err : if self . length > 0 and self . count * SHA256 < len ( self . pieces ): self . hasher = self . Padder ( self . length , self . piece_length ) piece , size = self . advance () layer = next ( self . hasher ) self . prog_update ( 0 ) return layer , piece , self . current , size raise StopIteration from err","title":"Raises"},{"location":"source/","text":"TorrentFile \u00a4 API and Source \u00a4 Torrent Module \u00a4 module torrentfile. torrent Classes and procedures pertaining to the creation of torrent meta files. Classes \u00a4 TorrentFile construct .torrent file. TorrentFileV2 construct .torrent v2 files using provided data. MetaFile base class for all MetaFile classes. Constants \u00a4 BLOCK_SIZE : int size of leaf hashes for merkle tree. HASH_SIZE : int Length of a sha256 hash. Bittorrent V2 \u00a4 From Bittorrent.org Documentation pages. Implementation details for Bittorrent Protocol v2. Note All strings in a .torrent file that contain text must be UTF-8 encoded. Meta Version 2 Dictionary: \u00a4 \"announce\": The URL of the tracker. \"info\": This maps to a dictionary, with keys described below. \"name\": A display name for the torrent. It is purely advisory. \"piece length\": The number of bytes that each logical piece in the peer protocol refers to. I.e. it sets the granularity of piece, request, bitfield and have messages. It must be a power of two and at least 6KiB. \"meta version\": An integer value, set to 2 to indicate compatibility with the current revision of this specification. Version 1 is not assigned to avoid confusion with BEP3. Future revisions will only increment this issue to indicate an incompatible change has been made, for example that hash algorithms were changed due to newly discovered vulnerabilities. Lementations must check this field first and indicate that a torrent is of a newer version than they can handle before performing other idations which may result in more general messages about invalid files. Files are mapped into this piece address space so that each non-empty \"file tree\": A tree of dictionaries where dictionary keys represent UTF-8 encoded path elements. Entries with zero-length keys describe the properties of the composed path at that point. 'UTF-8 encoded' context only means that if the native encoding is known at creation time it must be converted to UTF-8. Keys may contain invalid UTF-8 sequences or characters and names that are reserved on specific filesystems. Implementations must be prepared to sanitize them. On platforms path components exactly matching '.' and '..' must be sanitized since they could lead to directory traversal attacks and conflicting path descriptions. On platforms that require UTF-8 path components this sanitizing step must happen after normalizing overlong UTF-8 encodings. File is aligned to a piece boundary and occurs in same order as the file tree. The last piece of each file may be shorter than the specified piece length, resulting in an alignment gap. \"length\": Length of the file in bytes. Presence of this field indicates that the dictionary describes a file, not a directory. Which means it must not have any sibling entries. \"pieces root\": For non-empty files this is the the root hash of a merkle tree with a branching factor of 2, constructed from 16KiB blocks of the file. The last block may be shorter than 16KiB. The remaining leaf hashes beyond the end of the file required to construct upper layers of the merkle tree are set to zero. As of meta version 2 SHA2-256 is used as digest function for the merkle tree. The hash is stored in its binary form, not as human-readable string. \"piece layers\": A dictionary of strings. For each file in the file tree that is larger than the piece size it contains one string value. The keys are the merkle roots while the values consist of concatenated hashes of one layer within that merkle tree. The layer is chosen so that one hash covers piece length bytes. For example if the piece size is 16KiB then the leaf hashes are used. If a piece size of 128KiB is used then 3rd layer up from the leaf hashes is used. Layer hashes which exclusively cover data beyond the end of file, i.e. are only needed to balance the tree, are omitted. All hashes are stored in their binary format. A torrent is not valid if this field is absent, the contained hashes do not match the merkle roots or are not from the correct layer. Important The file tree root dictionary itself must not be a file, i.e. it must not contain a zero-length key with a dictionary containing a length key. Bittorrent V1 \u00a4 v1 meta-dictionary \u00a4 announce: The URL of the tracker. info: This maps to a dictionary, with keys described below. name : maps to a UTF-8 encoded string which is the suggested name to save the file (or directory) as. It is purely advisory. piece length : maps to the number of bytes in each piece the file is split into. For the purposes of transfer, files are split into fixed-size pieces which are all the same length except for possibly the last one which may be truncated. piece length : is almost always a power of two, most commonly 2^18 = 256 K pieces : maps to a string whose length is a multiple of 20. It is to be subdivided into strings of length 20, each of which is the SHA1 hash of the piece at the corresponding index. length : In the single file case, maps to the length of the file in bytes. files : If present then the download represents a single file, otherwise it represents a set of files which go in a directory structure. For the purposes of the other keys, the multi-file case is treated as only having a single file by concatenating the files in the order they appear in the files list. The files list is the value files maps to, and is a list of dictionaries containing the following keys: path : A list of UTF-8 encoded strings corresponding to subdirectory names, the last of which is the actual file name length : Maps to the length of the file in bytes. length : Only present if the content is a single file. Maps to the length of the file in bytes. Note In the single file case, the name key is the name of a file, in the muliple file case, it's the name of a directory. Classes MetaFile \u2014 Base Class for all TorrentFile classes. TorrentFile \u2014 Class for creating Bittorrent meta files. TorrentFileV2 \u2014 Class for creating Bittorrent meta v2 files. TorrentFileHybrid \u2014 Construct the Hybrid torrent meta file with provided parameters. TorrentAssembler \u2014 Assembler class for Bittorrent version 2 and hybrid meta files. Utils Module \u00a4 module torrentfile. utils Utility functions and classes used throughout package. Functions: get_piece_length: calculate ideal piece length for torrent file. sortfiles: traverse directory in sorted order yielding paths encountered. path_size: Sum the sizes of each file in path. get_file_list: Return list of all files contained in directory. path_stat: Get ideal piece length, total size, and file list for directory. path_piece_length: Get ideal piece length based on size of directory. Classes: MissingPathError: Custom exception raised when no path was provided to CLI. PieceLengthValueError: Custom exception raised when incorrect input value used for piece length field. Classes Memo \u2014 Memoize cache. MissingPathError \u2014 Path parameter is required to specify target content. PieceLengthValueError \u2014 Piece Length parameter must equal a perfect power of 2. ArgumentError \u2014 Exception for mismatched or mistyped CLI arguments. Functions get_file_list ( path ) (list) \u2014 Return a sorted list of file paths contained in directory. get_piece_length ( size ) (int) \u2014 Calculate the ideal piece length for bittorrent data. humanize_bytes ( amount ) (str) \u2014 Convert integer into human readable memory sized denomination. next_power_2 ( value ) (int) \u2014 Calculate the next perfect power of 2 equal to or greater than value. normalize_piece_length ( piece_length ) (int) \u2014 Verify input piece_length is valid and convert accordingly. path_piece_length ( path ) (int) \u2014 Calculate piece length for input path and contents. path_size ( path ) (int) \u2014 Return the total size of all files in path recursively. path_stat ( path ) (list) \u2014 Calculate directory statistics. Edit Module \u00a4 module torrentfile. edit Edit torrent module. Provides a facility by which certain properties of a torrent meta file can be edited by the user. The various command line arguments indicate which fields should be edited, and what the new value should be. Depending on what fields are chosen to edit, this command can trigger a new info hash which means the torrent will no longer be able to participate in the same swarm as the original unedited torrent. Keywords \u00a4 private comment source trackers web-seeds Functions edit_torrent ( metafile , args ) (dict) \u2014 Edit the properties and values in a torrent meta file. filter_empty ( args , meta , info ) \u2014 Remove dictionary keys with empty values. Interactive Module \u00a4 module torrentfile. interactive Module contains the procedures used for Interactive Mode. Classes InteractiveEditor \u2014 Interactive dialog class for torrent editing. InteractiveCreator \u2014 Class namespace for interactive program options. Functions create_torrent ( ) \u2014 Create new torrent file interactively. edit_action ( ) \u2014 Edit the editable values of the torrent meta file. get_input ( *args ) (str) \u2014 Determine appropriate input function to call. recheck_torrent ( ) \u2014 Check torrent download completed percentage. select_action ( ) \u2014 Operate TorrentFile program interactively through terminal. showcenter ( txt ) \u2014 Print text to screen in the center position of the terminal. showtext ( txt ) \u2014 Print contents of txt to screen. CLI Module \u00a4 module torrentfile. cli Command Line Interface for TorrentFile project. This module provides the primary command line argument parser for the torrentfile package. The main_script function is automatically invoked when called from command line, and parses accompanying arguments. Functions: main_script: process command line arguments and run program. activate_logger: turns on debug mode and logging facility. Classes Config \u2014 Class the controls the logging configuration and output settings. TorrentFileHelpFormatter \u2014 Formatting class for help tips provided by the CLI. Functions execute ( args ) (list) \u2014 Initialize Command Line Interface for torrentfile. execute ( args ) (list) \u2014 Initialize Command Line Interface for torrentfile. main ( ) \u2014 Initiate main function for CLI script. Recheck Module \u00a4 module torrentfile. recheck Module container Checker Class. The CheckerClass takes a torrentfile and tha path to it's contents. It will then iterate through every file and directory contained and compare their data to values contained within the torrent file. Completion percentages will be printed to screen for each file and at the end for the torrentfile as a whole. Classes Checker \u2014 Check a given file or directory to see if it matches a torrentfile. FeedChecker \u2014 Validates torrent content. HashChecker \u2014 Iterate through contents of meta data and verify with file contents. Hasher Module \u00a4 module torrentfile. hasher Piece/File Hashers for Bittorrent meta file contents. Classes Hasher \u2014 Piece hasher for Bittorrent V1 files. HasherV2 \u2014 Calculate the root hash and piece layers for file contents. HasherHybrid \u2014 Calculate root and piece hashes for creating hybrid torrent file. FileHasher \u2014 Calculate root and piece hashes for creating hybrid torrent file. Functions merkle_root ( blocks ) (bytes) \u2014 Calculate the merkle root for a seq of sha256 hash digests.","title":"API"},{"location":"source/#torrentfile","text":"","title":"TorrentFile"},{"location":"source/#api-and-source","text":"","title":"API and Source"},{"location":"source/#torrent-module","text":"module torrentfile. torrent Classes and procedures pertaining to the creation of torrent meta files.","title":"Torrent Module"},{"location":"source/#classes","text":"TorrentFile construct .torrent file. TorrentFileV2 construct .torrent v2 files using provided data. MetaFile base class for all MetaFile classes.","title":"Classes"},{"location":"source/#constants","text":"BLOCK_SIZE : int size of leaf hashes for merkle tree. HASH_SIZE : int Length of a sha256 hash.","title":"Constants"},{"location":"source/#bittorrent-v2","text":"From Bittorrent.org Documentation pages. Implementation details for Bittorrent Protocol v2. Note All strings in a .torrent file that contain text must be UTF-8 encoded.","title":"Bittorrent V2"},{"location":"source/#meta-version-2-dictionary","text":"\"announce\": The URL of the tracker. \"info\": This maps to a dictionary, with keys described below. \"name\": A display name for the torrent. It is purely advisory. \"piece length\": The number of bytes that each logical piece in the peer protocol refers to. I.e. it sets the granularity of piece, request, bitfield and have messages. It must be a power of two and at least 6KiB. \"meta version\": An integer value, set to 2 to indicate compatibility with the current revision of this specification. Version 1 is not assigned to avoid confusion with BEP3. Future revisions will only increment this issue to indicate an incompatible change has been made, for example that hash algorithms were changed due to newly discovered vulnerabilities. Lementations must check this field first and indicate that a torrent is of a newer version than they can handle before performing other idations which may result in more general messages about invalid files. Files are mapped into this piece address space so that each non-empty \"file tree\": A tree of dictionaries where dictionary keys represent UTF-8 encoded path elements. Entries with zero-length keys describe the properties of the composed path at that point. 'UTF-8 encoded' context only means that if the native encoding is known at creation time it must be converted to UTF-8. Keys may contain invalid UTF-8 sequences or characters and names that are reserved on specific filesystems. Implementations must be prepared to sanitize them. On platforms path components exactly matching '.' and '..' must be sanitized since they could lead to directory traversal attacks and conflicting path descriptions. On platforms that require UTF-8 path components this sanitizing step must happen after normalizing overlong UTF-8 encodings. File is aligned to a piece boundary and occurs in same order as the file tree. The last piece of each file may be shorter than the specified piece length, resulting in an alignment gap. \"length\": Length of the file in bytes. Presence of this field indicates that the dictionary describes a file, not a directory. Which means it must not have any sibling entries. \"pieces root\": For non-empty files this is the the root hash of a merkle tree with a branching factor of 2, constructed from 16KiB blocks of the file. The last block may be shorter than 16KiB. The remaining leaf hashes beyond the end of the file required to construct upper layers of the merkle tree are set to zero. As of meta version 2 SHA2-256 is used as digest function for the merkle tree. The hash is stored in its binary form, not as human-readable string. \"piece layers\": A dictionary of strings. For each file in the file tree that is larger than the piece size it contains one string value. The keys are the merkle roots while the values consist of concatenated hashes of one layer within that merkle tree. The layer is chosen so that one hash covers piece length bytes. For example if the piece size is 16KiB then the leaf hashes are used. If a piece size of 128KiB is used then 3rd layer up from the leaf hashes is used. Layer hashes which exclusively cover data beyond the end of file, i.e. are only needed to balance the tree, are omitted. All hashes are stored in their binary format. A torrent is not valid if this field is absent, the contained hashes do not match the merkle roots or are not from the correct layer. Important The file tree root dictionary itself must not be a file, i.e. it must not contain a zero-length key with a dictionary containing a length key.","title":"Meta Version 2 Dictionary:"},{"location":"source/#bittorrent-v1","text":"","title":"Bittorrent V1"},{"location":"source/#v1-meta-dictionary","text":"announce: The URL of the tracker. info: This maps to a dictionary, with keys described below. name : maps to a UTF-8 encoded string which is the suggested name to save the file (or directory) as. It is purely advisory. piece length : maps to the number of bytes in each piece the file is split into. For the purposes of transfer, files are split into fixed-size pieces which are all the same length except for possibly the last one which may be truncated. piece length : is almost always a power of two, most commonly 2^18 = 256 K pieces : maps to a string whose length is a multiple of 20. It is to be subdivided into strings of length 20, each of which is the SHA1 hash of the piece at the corresponding index. length : In the single file case, maps to the length of the file in bytes. files : If present then the download represents a single file, otherwise it represents a set of files which go in a directory structure. For the purposes of the other keys, the multi-file case is treated as only having a single file by concatenating the files in the order they appear in the files list. The files list is the value files maps to, and is a list of dictionaries containing the following keys: path : A list of UTF-8 encoded strings corresponding to subdirectory names, the last of which is the actual file name length : Maps to the length of the file in bytes. length : Only present if the content is a single file. Maps to the length of the file in bytes. Note In the single file case, the name key is the name of a file, in the muliple file case, it's the name of a directory. Classes MetaFile \u2014 Base Class for all TorrentFile classes. TorrentFile \u2014 Class for creating Bittorrent meta files. TorrentFileV2 \u2014 Class for creating Bittorrent meta v2 files. TorrentFileHybrid \u2014 Construct the Hybrid torrent meta file with provided parameters. TorrentAssembler \u2014 Assembler class for Bittorrent version 2 and hybrid meta files.","title":"v1 meta-dictionary"},{"location":"source/#utils-module","text":"module torrentfile. utils Utility functions and classes used throughout package. Functions: get_piece_length: calculate ideal piece length for torrent file. sortfiles: traverse directory in sorted order yielding paths encountered. path_size: Sum the sizes of each file in path. get_file_list: Return list of all files contained in directory. path_stat: Get ideal piece length, total size, and file list for directory. path_piece_length: Get ideal piece length based on size of directory. Classes: MissingPathError: Custom exception raised when no path was provided to CLI. PieceLengthValueError: Custom exception raised when incorrect input value used for piece length field. Classes Memo \u2014 Memoize cache. MissingPathError \u2014 Path parameter is required to specify target content. PieceLengthValueError \u2014 Piece Length parameter must equal a perfect power of 2. ArgumentError \u2014 Exception for mismatched or mistyped CLI arguments. Functions get_file_list ( path ) (list) \u2014 Return a sorted list of file paths contained in directory. get_piece_length ( size ) (int) \u2014 Calculate the ideal piece length for bittorrent data. humanize_bytes ( amount ) (str) \u2014 Convert integer into human readable memory sized denomination. next_power_2 ( value ) (int) \u2014 Calculate the next perfect power of 2 equal to or greater than value. normalize_piece_length ( piece_length ) (int) \u2014 Verify input piece_length is valid and convert accordingly. path_piece_length ( path ) (int) \u2014 Calculate piece length for input path and contents. path_size ( path ) (int) \u2014 Return the total size of all files in path recursively. path_stat ( path ) (list) \u2014 Calculate directory statistics.","title":"Utils Module"},{"location":"source/#edit-module","text":"module torrentfile. edit Edit torrent module. Provides a facility by which certain properties of a torrent meta file can be edited by the user. The various command line arguments indicate which fields should be edited, and what the new value should be. Depending on what fields are chosen to edit, this command can trigger a new info hash which means the torrent will no longer be able to participate in the same swarm as the original unedited torrent.","title":"Edit Module"},{"location":"source/#keywords","text":"private comment source trackers web-seeds Functions edit_torrent ( metafile , args ) (dict) \u2014 Edit the properties and values in a torrent meta file. filter_empty ( args , meta , info ) \u2014 Remove dictionary keys with empty values.","title":"Keywords"},{"location":"source/#interactive-module","text":"module torrentfile. interactive Module contains the procedures used for Interactive Mode. Classes InteractiveEditor \u2014 Interactive dialog class for torrent editing. InteractiveCreator \u2014 Class namespace for interactive program options. Functions create_torrent ( ) \u2014 Create new torrent file interactively. edit_action ( ) \u2014 Edit the editable values of the torrent meta file. get_input ( *args ) (str) \u2014 Determine appropriate input function to call. recheck_torrent ( ) \u2014 Check torrent download completed percentage. select_action ( ) \u2014 Operate TorrentFile program interactively through terminal. showcenter ( txt ) \u2014 Print text to screen in the center position of the terminal. showtext ( txt ) \u2014 Print contents of txt to screen.","title":"Interactive Module"},{"location":"source/#cli-module","text":"module torrentfile. cli Command Line Interface for TorrentFile project. This module provides the primary command line argument parser for the torrentfile package. The main_script function is automatically invoked when called from command line, and parses accompanying arguments. Functions: main_script: process command line arguments and run program. activate_logger: turns on debug mode and logging facility. Classes Config \u2014 Class the controls the logging configuration and output settings. TorrentFileHelpFormatter \u2014 Formatting class for help tips provided by the CLI. Functions execute ( args ) (list) \u2014 Initialize Command Line Interface for torrentfile. execute ( args ) (list) \u2014 Initialize Command Line Interface for torrentfile. main ( ) \u2014 Initiate main function for CLI script.","title":"CLI Module"},{"location":"source/#recheck-module","text":"module torrentfile. recheck Module container Checker Class. The CheckerClass takes a torrentfile and tha path to it's contents. It will then iterate through every file and directory contained and compare their data to values contained within the torrent file. Completion percentages will be printed to screen for each file and at the end for the torrentfile as a whole. Classes Checker \u2014 Check a given file or directory to see if it matches a torrentfile. FeedChecker \u2014 Validates torrent content. HashChecker \u2014 Iterate through contents of meta data and verify with file contents.","title":"Recheck Module"},{"location":"source/#hasher-module","text":"module torrentfile. hasher Piece/File Hashers for Bittorrent meta file contents. Classes Hasher \u2014 Piece hasher for Bittorrent V1 files. HasherV2 \u2014 Calculate the root hash and piece layers for file contents. HasherHybrid \u2014 Calculate root and piece hashes for creating hybrid torrent file. FileHasher \u2014 Calculate root and piece hashes for creating hybrid torrent file. Functions merkle_root ( blocks ) (bytes) \u2014 Calculate the merkle root for a seq of sha256 hash digests.","title":"Hasher Module"},{"location":"torrent/","text":"Classes and procedures pertaining to the creation of torrent meta files. Classes \u00a4 TorrentFile construct .torrent file. TorrentFileV2 construct .torrent v2 files using provided data. MetaFile base class for all MetaFile classes. Constants \u00a4 BLOCK_SIZE : int size of leaf hashes for merkle tree. HASH_SIZE : int Length of a sha256 hash. Bittorrent V2 \u00a4 From Bittorrent.org Documentation pages. Implementation details for Bittorrent Protocol v2. Note All strings in a .torrent file that contain text must be UTF-8 encoded. Meta Version 2 Dictionary: \u00a4 \"announce\": The URL of the tracker. \"info\": This maps to a dictionary, with keys described below. \"name\": A display name for the torrent. It is purely advisory. \"piece length\": The number of bytes that each logical piece in the peer protocol refers to. I.e. it sets the granularity of piece, request, bitfield and have messages. It must be a power of two and at least 6KiB. \"meta version\": An integer value, set to 2 to indicate compatibility with the current revision of this specification. Version 1 is not assigned to avoid confusion with BEP3. Future revisions will only increment this issue to indicate an incompatible change has been made, for example that hash algorithms were changed due to newly discovered vulnerabilities. Lementations must check this field first and indicate that a torrent is of a newer version than they can handle before performing other idations which may result in more general messages about invalid files. Files are mapped into this piece address space so that each non-empty \"file tree\": A tree of dictionaries where dictionary keys represent UTF-8 encoded path elements. Entries with zero-length keys describe the properties of the composed path at that point. 'UTF-8 encoded' context only means that if the native encoding is known at creation time it must be converted to UTF-8. Keys may contain invalid UTF-8 sequences or characters and names that are reserved on specific filesystems. Implementations must be prepared to sanitize them. On platforms path components exactly matching '.' and '..' must be sanitized since they could lead to directory traversal attacks and conflicting path descriptions. On platforms that require UTF-8 path components this sanitizing step must happen after normalizing overlong UTF-8 encodings. File is aligned to a piece boundary and occurs in same order as the file tree. The last piece of each file may be shorter than the specified piece length, resulting in an alignment gap. \"length\": Length of the file in bytes. Presence of this field indicates that the dictionary describes a file, not a directory. Which means it must not have any sibling entries. \"pieces root\": For non-empty files this is the the root hash of a merkle tree with a branching factor of 2, constructed from 16KiB blocks of the file. The last block may be shorter than 16KiB. The remaining leaf hashes beyond the end of the file required to construct upper layers of the merkle tree are set to zero. As of meta version 2 SHA2-256 is used as digest function for the merkle tree. The hash is stored in its binary form, not as human-readable string. \"piece layers\": A dictionary of strings. For each file in the file tree that is larger than the piece size it contains one string value. The keys are the merkle roots while the values consist of concatenated hashes of one layer within that merkle tree. The layer is chosen so that one hash covers piece length bytes. For example if the piece size is 16KiB then the leaf hashes are used. If a piece size of 128KiB is used then 3rd layer up from the leaf hashes is used. Layer hashes which exclusively cover data beyond the end of file, i.e. are only needed to balance the tree, are omitted. All hashes are stored in their binary format. A torrent is not valid if this field is absent, the contained hashes do not match the merkle roots or are not from the correct layer. Important The file tree root dictionary itself must not be a file, i.e. it must not contain a zero-length key with a dictionary containing a length key. Bittorrent V1 \u00a4 v1 meta-dictionary \u00a4 announce: The URL of the tracker. info: This maps to a dictionary, with keys described below. name : maps to a UTF-8 encoded string which is the suggested name to save the file (or directory) as. It is purely advisory. piece length : maps to the number of bytes in each piece the file is split into. For the purposes of transfer, files are split into fixed-size pieces which are all the same length except for possibly the last one which may be truncated. piece length : is almost always a power of two, most commonly 2^18 = 256 K pieces : maps to a string whose length is a multiple of 20. It is to be subdivided into strings of length 20, each of which is the SHA1 hash of the piece at the corresponding index. length : In the single file case, maps to the length of the file in bytes. files : If present then the download represents a single file, otherwise it represents a set of files which go in a directory structure. For the purposes of the other keys, the multi-file case is treated as only having a single file by concatenating the files in the order they appear in the files list. The files list is the value files maps to, and is a list of dictionaries containing the following keys: path : A list of UTF-8 encoded strings corresponding to subdirectory names, the last of which is the actual file name length : Maps to the length of the file in bytes. length : Only present if the content is a single file. Maps to the length of the file in bytes. Note In the single file case, the name key is the name of a file, in the muliple file case, it's the name of a directory. MetaFile \u00a4 Base Class for all TorrentFile classes. Parameters \u00a4 str target path to torrent content. Default: None str One or more tracker URL's. Default: None str A comment. Default: None int Size of torrent pieces. Default: None bool For private trackers. Default: None str target path to write .torrent file. Default: None str Private tracker source. Default: None str level of progress bar displayed Default: \"1\" bool If True change default save location to current directory list one or more web addresses where torrent content can be found. list one or more web addressess where torrent content exists. str alias for 'path' arg. int indicates which Bittorrent protocol to use for hashing content Source code in torrentfile\\torrent.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 class MetaFile : \"\"\" Base Class for all TorrentFile classes. Parameters ---------- path : str target path to torrent content. Default: None announce : str One or more tracker URL's. Default: None comment : str A comment. Default: None piece_length : int Size of torrent pieces. Default: None private : bool For private trackers. Default: None outfile : str target path to write .torrent file. Default: None source : str Private tracker source. Default: None progress : str level of progress bar displayed Default: \"1\" cwd : bool If True change default save location to current directory httpseeds : list one or more web addresses where torrent content can be found. url_list : list one or more web addressess where torrent content exists. content : str alias for 'path' arg. meta_version : int indicates which Bittorrent protocol to use for hashing content \"\"\" hasher = None @classmethod def set_callback ( cls , func ): \"\"\" Assign a callback function for the Hashing class to call for each hash. Parameters ---------- func : function The callback function which accepts a single paramter. \"\"\" if \"hasher\" in vars ( cls ) and vars ( cls )[ \"hasher\" ]: cls . hasher . set_callback ( func ) def __init__ ( self , path = None , announce = None , comment = None , piece_length = None , private = False , outfile = None , source = None , progress = 1 , cwd = False , httpseeds = None , url_list = None , content = None , meta_version = None , ** _ , ): \"\"\" Construct MetaFile superclass and assign local attributes. \"\"\" self . private = private self . cwd = cwd self . outfile = outfile self . progress = int ( progress ) self . comment = comment self . source = source self . meta_version = meta_version if content : path = content if not path : if announce and len ( announce ) > 1 and os . path . exists ( announce [ - 1 ]): path = announce [ - 1 ] announce = announce [: - 1 ] elif url_list and os . path . exists ( url_list [ - 1 ]): path = url_list [ - 1 ] url_list = url_list [: - 1 ] elif httpseeds and os . path . exists ( httpseeds [ - 1 ]): path = httpseeds [ - 1 ] httpseeds = httpseeds [: - 1 ] else : raise utils . MissingPathError ( \"Path to content is required.\" ) # base path to torrent content. self . path = path logger . debug ( \"path parameter found %s \" , path ) # Format piece_length attribute. if piece_length : self . piece_length = utils . normalize_piece_length ( piece_length ) logger . debug ( \"piece length parameter found %s \" , piece_length ) else : self . piece_length = utils . path_piece_length ( self . path ) logger . debug ( \"piece length calculated %s \" , self . piece_length ) # Assign announce URL to empty string if none provided. if not announce : self . announce , self . announce_list = \"\" , [[ \"\" ]] # Most torrent clients have editting trackers as a feature. elif isinstance ( announce , str ): self . announce , self . announce_list = announce , [[ announce ]] elif isinstance ( announce , Sequence ): self . announce , self . announce_list = announce [ 0 ], [ announce ] self . meta = { \"announce\" : self . announce , \"announce-list\" : self . announce_list , \"created by\" : f \"TorrentFile:v { version } \" , \"creation date\" : int ( datetime . timestamp ( datetime . now ())), \"info\" : {}, } if comment : self . meta [ \"info\" ][ \"comment\" ] = comment logger . debug ( \"comment parameter found %s \" , comment ) if private : self . meta [ \"info\" ][ \"private\" ] = 1 logger . debug ( \"private parameter triggered\" ) if source : self . meta [ \"info\" ][ \"source\" ] = source logger . debug ( \"source parameter found %s \" , source ) if url_list : self . meta [ \"url-list\" ] = url_list logger . debug ( \"url list parameter found %s \" , str ( url_list )) if httpseeds : self . meta [ \"httpseeds\" ] = httpseeds logger . debug ( \"httpseeds parameter found %s \" , str ( httpseeds )) self . meta [ \"info\" ][ \"piece length\" ] = self . piece_length self . meta_version = meta_version parent , self . name = os . path . split ( self . path ) if not self . name : self . name = os . path . basename ( parent ) self . meta [ \"info\" ][ \"name\" ] = self . name def assemble ( self ): \"\"\" Overload in subclasses. Raises ------ Exception NotImplementedError \"\"\" raise NotImplementedError def sort_meta ( self ): \"\"\"Sort the info and meta dictionaries.\"\"\" logger . debug ( \"sorting dictionary keys\" ) meta = self . meta meta [ \"info\" ] = dict ( sorted ( list ( meta [ \"info\" ] . items ()))) meta = dict ( sorted ( list ( meta . items ()))) return meta def write ( self , outfile = None ) -> tuple : \"\"\" Write meta information to .torrent file. Final step in the torrent file creation process. After hashing and sorting every piece of content write the contents to file using the bencode encoding. Parameters ---------- outfile : str Destination path for .torrent file. default=None Returns ------- outfile : str Where the .torrent file was writen. meta : dict .torrent meta information. \"\"\" if outfile : self . outfile = outfile elif self . outfile : pass else : self . outfile = os . path . join ( os . getcwd (), self . name ) + \".torrent\" if str ( self . outfile )[ - 1 ] in \" \\\\ /\" : self . outfile = self . outfile + ( self . name + \".torrent\" ) self . meta = self . sort_meta () try : pyben . dump ( self . meta , self . outfile ) except PermissionError as excp : logger . error ( \"Permission Denied: Could not write to %s \" , self . outfile ) raise PermissionError from excp return self . outfile , self . meta __init__ ( path = None , announce = None , comment = None , piece_length = None , private = False , outfile = None , source = None , progress = 1 , cwd = False , httpseeds = None , url_list = None , content = None , meta_version = None , ** _ ) \u00a4 Construct MetaFile superclass and assign local attributes. Source code in torrentfile\\torrent.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 def __init__ ( self , path = None , announce = None , comment = None , piece_length = None , private = False , outfile = None , source = None , progress = 1 , cwd = False , httpseeds = None , url_list = None , content = None , meta_version = None , ** _ , ): \"\"\" Construct MetaFile superclass and assign local attributes. \"\"\" self . private = private self . cwd = cwd self . outfile = outfile self . progress = int ( progress ) self . comment = comment self . source = source self . meta_version = meta_version if content : path = content if not path : if announce and len ( announce ) > 1 and os . path . exists ( announce [ - 1 ]): path = announce [ - 1 ] announce = announce [: - 1 ] elif url_list and os . path . exists ( url_list [ - 1 ]): path = url_list [ - 1 ] url_list = url_list [: - 1 ] elif httpseeds and os . path . exists ( httpseeds [ - 1 ]): path = httpseeds [ - 1 ] httpseeds = httpseeds [: - 1 ] else : raise utils . MissingPathError ( \"Path to content is required.\" ) # base path to torrent content. self . path = path logger . debug ( \"path parameter found %s \" , path ) # Format piece_length attribute. if piece_length : self . piece_length = utils . normalize_piece_length ( piece_length ) logger . debug ( \"piece length parameter found %s \" , piece_length ) else : self . piece_length = utils . path_piece_length ( self . path ) logger . debug ( \"piece length calculated %s \" , self . piece_length ) # Assign announce URL to empty string if none provided. if not announce : self . announce , self . announce_list = \"\" , [[ \"\" ]] # Most torrent clients have editting trackers as a feature. elif isinstance ( announce , str ): self . announce , self . announce_list = announce , [[ announce ]] elif isinstance ( announce , Sequence ): self . announce , self . announce_list = announce [ 0 ], [ announce ] self . meta = { \"announce\" : self . announce , \"announce-list\" : self . announce_list , \"created by\" : f \"TorrentFile:v { version } \" , \"creation date\" : int ( datetime . timestamp ( datetime . now ())), \"info\" : {}, } if comment : self . meta [ \"info\" ][ \"comment\" ] = comment logger . debug ( \"comment parameter found %s \" , comment ) if private : self . meta [ \"info\" ][ \"private\" ] = 1 logger . debug ( \"private parameter triggered\" ) if source : self . meta [ \"info\" ][ \"source\" ] = source logger . debug ( \"source parameter found %s \" , source ) if url_list : self . meta [ \"url-list\" ] = url_list logger . debug ( \"url list parameter found %s \" , str ( url_list )) if httpseeds : self . meta [ \"httpseeds\" ] = httpseeds logger . debug ( \"httpseeds parameter found %s \" , str ( httpseeds )) self . meta [ \"info\" ][ \"piece length\" ] = self . piece_length self . meta_version = meta_version parent , self . name = os . path . split ( self . path ) if not self . name : self . name = os . path . basename ( parent ) self . meta [ \"info\" ][ \"name\" ] = self . name assemble () \u00a4 Overload in subclasses. Raises \u00a4 Exception NotImplementedError Source code in torrentfile\\torrent.py 350 351 352 353 354 355 356 357 358 359 def assemble ( self ): \"\"\" Overload in subclasses. Raises ------ Exception NotImplementedError \"\"\" raise NotImplementedError set_callback ( func ) classmethod \u00a4 Assign a callback function for the Hashing class to call for each hash. Parameters \u00a4 function The callback function which accepts a single paramter. Source code in torrentfile\\torrent.py 240 241 242 243 244 245 246 247 248 249 250 251 @classmethod def set_callback ( cls , func ): \"\"\" Assign a callback function for the Hashing class to call for each hash. Parameters ---------- func : function The callback function which accepts a single paramter. \"\"\" if \"hasher\" in vars ( cls ) and vars ( cls )[ \"hasher\" ]: cls . hasher . set_callback ( func ) sort_meta () \u00a4 Sort the info and meta dictionaries. Source code in torrentfile\\torrent.py 361 362 363 364 365 366 367 def sort_meta ( self ): \"\"\"Sort the info and meta dictionaries.\"\"\" logger . debug ( \"sorting dictionary keys\" ) meta = self . meta meta [ \"info\" ] = dict ( sorted ( list ( meta [ \"info\" ] . items ()))) meta = dict ( sorted ( list ( meta . items ()))) return meta write ( outfile = None ) \u00a4 Write meta information to .torrent file. Final step in the torrent file creation process. After hashing and sorting every piece of content write the contents to file using the bencode encoding. Parameters \u00a4 str Destination path for .torrent file. default=None Returns \u00a4 str Where the .torrent file was writen. dict .torrent meta information. Source code in torrentfile\\torrent.py 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 def write ( self , outfile = None ) -> tuple : \"\"\" Write meta information to .torrent file. Final step in the torrent file creation process. After hashing and sorting every piece of content write the contents to file using the bencode encoding. Parameters ---------- outfile : str Destination path for .torrent file. default=None Returns ------- outfile : str Where the .torrent file was writen. meta : dict .torrent meta information. \"\"\" if outfile : self . outfile = outfile elif self . outfile : pass else : self . outfile = os . path . join ( os . getcwd (), self . name ) + \".torrent\" if str ( self . outfile )[ - 1 ] in \" \\\\ /\" : self . outfile = self . outfile + ( self . name + \".torrent\" ) self . meta = self . sort_meta () try : pyben . dump ( self . meta , self . outfile ) except PermissionError as excp : logger . error ( \"Permission Denied: Could not write to %s \" , self . outfile ) raise PermissionError from excp return self . outfile , self . meta TorrentAssembler \u00a4 Bases: MetaFile Assembler class for Bittorrent version 2 and hybrid meta files. This differs from the TorrentFileV2 and TorrentFileHybrid, because it can be used as an iterator and works for both versions. Parameters \u00a4 **kwargs : dict Keyword arguments for torrent options. Source code in torrentfile\\torrent.py 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 class TorrentAssembler ( MetaFile ): \"\"\" Assembler class for Bittorrent version 2 and hybrid meta files. This differs from the TorrentFileV2 and TorrentFileHybrid, because it can be used as an iterator and works for both versions. Parameters ---------- **kwargs : dict Keyword arguments for torrent options. \"\"\" hasher = FileHasher def __init__ ( self , ** kwargs ): \"\"\" Create Bittorrent v1 v2 hybrid metafiles. \"\"\" super () . __init__ ( ** kwargs ) logger . debug ( \"Assembling bittorrent Hybrid file\" ) self . name = os . path . basename ( self . path ) self . hashes = [] self . piece_layers = {} self . pieces = bytearray () self . files = [] self . hybrid = self . meta_version == \"3\" self . total = len ( utils . get_file_list ( self . path )) self . assemble () def assemble ( self ): \"\"\" Assemble the parts of the torrentfile into meta dictionary. \"\"\" info = self . meta [ \"info\" ] info [ \"meta version\" ] = 2 if os . path . isfile ( self . path ): info [ \"file tree\" ] = { self . name : self . _traverse ( self . path )} info [ \"length\" ] = os . path . getsize ( self . path ) else : info [ \"file tree\" ] = self . _traverse ( self . path ) if self . hybrid : info [ \"files\" ] = self . files if self . hybrid : info [ \"pieces\" ] = self . pieces self . meta [ \"piece layers\" ] = self . piece_layers return info def _traverse ( self , path : str ) -> dict : \"\"\" Build meta dictionary while walking directory. Parameters ---------- path : str Path to target file. \"\"\" if os . path . isfile ( path ): file_size = os . path . getsize ( path ) if self . hybrid : self . files . append ( { \"length\" : file_size , \"path\" : os . path . relpath ( path , self . path ) . split ( os . sep ), } ) if file_size == 0 : return { \"\" : { \"length\" : file_size }} logger . debug ( \"Hashing %s \" , str ( path )) hasher = FileHasher ( path , self . piece_length , progress = True , hybrid = self . hybrid ) layers = bytearray () for result in hasher : if self . hybrid : layer_hash , piece = result self . pieces . extend ( piece ) else : layer_hash = result layers . extend ( layer_hash ) if file_size > self . piece_length : self . piece_layers [ hasher . root ] = layers if self . hybrid and hasher . padding_file : self . files . append ( hasher . padding_file ) return { \"\" : { \"length\" : file_size , \"pieces root\" : hasher . root }} tree = {} if os . path . isdir ( path ): for name in sorted ( os . listdir ( path )): tree [ name ] = self . _traverse ( os . path . join ( path , name )) return tree __init__ ( ** kwargs ) \u00a4 Create Bittorrent v1 v2 hybrid metafiles. Source code in torrentfile\\torrent.py 661 662 663 664 665 666 667 668 669 670 671 672 673 674 def __init__ ( self , ** kwargs ): \"\"\" Create Bittorrent v1 v2 hybrid metafiles. \"\"\" super () . __init__ ( ** kwargs ) logger . debug ( \"Assembling bittorrent Hybrid file\" ) self . name = os . path . basename ( self . path ) self . hashes = [] self . piece_layers = {} self . pieces = bytearray () self . files = [] self . hybrid = self . meta_version == \"3\" self . total = len ( utils . get_file_list ( self . path )) self . assemble () _traverse ( path ) \u00a4 Build meta dictionary while walking directory. Parameters \u00a4 str Path to target file. Source code in torrentfile\\torrent.py 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 def _traverse ( self , path : str ) -> dict : \"\"\" Build meta dictionary while walking directory. Parameters ---------- path : str Path to target file. \"\"\" if os . path . isfile ( path ): file_size = os . path . getsize ( path ) if self . hybrid : self . files . append ( { \"length\" : file_size , \"path\" : os . path . relpath ( path , self . path ) . split ( os . sep ), } ) if file_size == 0 : return { \"\" : { \"length\" : file_size }} logger . debug ( \"Hashing %s \" , str ( path )) hasher = FileHasher ( path , self . piece_length , progress = True , hybrid = self . hybrid ) layers = bytearray () for result in hasher : if self . hybrid : layer_hash , piece = result self . pieces . extend ( piece ) else : layer_hash = result layers . extend ( layer_hash ) if file_size > self . piece_length : self . piece_layers [ hasher . root ] = layers if self . hybrid and hasher . padding_file : self . files . append ( hasher . padding_file ) return { \"\" : { \"length\" : file_size , \"pieces root\" : hasher . root }} tree = {} if os . path . isdir ( path ): for name in sorted ( os . listdir ( path )): tree [ name ] = self . _traverse ( os . path . join ( path , name )) return tree assemble () \u00a4 Assemble the parts of the torrentfile into meta dictionary. Source code in torrentfile\\torrent.py 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 def assemble ( self ): \"\"\" Assemble the parts of the torrentfile into meta dictionary. \"\"\" info = self . meta [ \"info\" ] info [ \"meta version\" ] = 2 if os . path . isfile ( self . path ): info [ \"file tree\" ] = { self . name : self . _traverse ( self . path )} info [ \"length\" ] = os . path . getsize ( self . path ) else : info [ \"file tree\" ] = self . _traverse ( self . path ) if self . hybrid : info [ \"files\" ] = self . files if self . hybrid : info [ \"pieces\" ] = self . pieces self . meta [ \"piece layers\" ] = self . piece_layers return info TorrentFile \u00a4 Bases: MetaFile , ProgMixin Class for creating Bittorrent meta files. Construct Torrentfile class instance object. Parameters \u00a4 **kwargs : dict Dictionary containing torrent file options. Source code in torrentfile\\torrent.py 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 class TorrentFile ( MetaFile , ProgMixin ): \"\"\" Class for creating Bittorrent meta files. Construct *Torrentfile* class instance object. Parameters ---------- **kwargs : dict Dictionary containing torrent file options. \"\"\" hasher = Hasher def __init__ ( self , ** kwargs ): \"\"\" Construct TorrentFile instance with given keyword args. Parameters ---------- **kwargs : dict dictionary of keyword args passed to superclass. \"\"\" super () . __init__ ( ** kwargs ) logger . debug ( \"Assembling bittorrent v1 torrent file\" ) self . assemble () def assemble ( self ): \"\"\" Assemble components of torrent metafile. Returns ------- dict metadata dictionary for torrent file \"\"\" info = self . meta [ \"info\" ] size , filelist = utils . filelist_total ( self . path ) if os . path . isfile ( self . path ): info [ \"length\" ] = size else : info [ \"files\" ] = [ { \"length\" : os . path . getsize ( path ), \"path\" : os . path . relpath ( path , self . path ) . split ( os . sep ), } for path in filelist ] pieces = bytearray () feeder = Hasher ( filelist , self . piece_length , self . progress ) for piece in feeder : pieces . extend ( piece ) info [ \"pieces\" ] = pieces __init__ ( ** kwargs ) \u00a4 Construct TorrentFile instance with given keyword args. Parameters \u00a4 **kwargs : dict dictionary of keyword args passed to superclass. Source code in torrentfile\\torrent.py 422 423 424 425 426 427 428 429 430 431 432 433 def __init__ ( self , ** kwargs ): \"\"\" Construct TorrentFile instance with given keyword args. Parameters ---------- **kwargs : dict dictionary of keyword args passed to superclass. \"\"\" super () . __init__ ( ** kwargs ) logger . debug ( \"Assembling bittorrent v1 torrent file\" ) self . assemble () assemble () \u00a4 Assemble components of torrent metafile. Returns \u00a4 dict metadata dictionary for torrent file Source code in torrentfile\\torrent.py 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 def assemble ( self ): \"\"\" Assemble components of torrent metafile. Returns ------- dict metadata dictionary for torrent file \"\"\" info = self . meta [ \"info\" ] size , filelist = utils . filelist_total ( self . path ) if os . path . isfile ( self . path ): info [ \"length\" ] = size else : info [ \"files\" ] = [ { \"length\" : os . path . getsize ( path ), \"path\" : os . path . relpath ( path , self . path ) . split ( os . sep ), } for path in filelist ] pieces = bytearray () feeder = Hasher ( filelist , self . piece_length , self . progress ) for piece in feeder : pieces . extend ( piece ) info [ \"pieces\" ] = pieces TorrentFileHybrid \u00a4 Bases: MetaFile , ProgMixin Construct the Hybrid torrent meta file with provided parameters. DEPRECATED Parameters \u00a4 **kwargs : dict Keyword arguments for torrent options. Source code in torrentfile\\torrent.py 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 class TorrentFileHybrid ( MetaFile , ProgMixin ): \"\"\" Construct the Hybrid torrent meta file with provided parameters. **DEPRECATED** Parameters ---------- **kwargs : dict Keyword arguments for torrent options. \"\"\" hasher = HasherHybrid def __init__ ( self , ** kwargs ): \"\"\" Create Bittorrent v1 v2 hybrid metafiles. \"\"\" super () . __init__ ( ** kwargs ) logger . debug ( \"Assembling bittorrent Hybrid file\" ) self . name = os . path . basename ( self . path ) self . hashes = [] self . piece_layers = {} self . pieces = [] self . files = [] self . total = len ( utils . get_file_list ( self . path )) self . assemble () def assemble ( self ): \"\"\" Assemble the parts of the torrentfile into meta dictionary. **DEPRECATED** \"\"\" info = self . meta [ \"info\" ] info [ \"meta version\" ] = 2 if os . path . isfile ( self . path ): info [ \"file tree\" ] = { self . name : self . _traverse ( self . path )} info [ \"length\" ] = os . path . getsize ( self . path ) else : info [ \"file tree\" ] = self . _traverse ( self . path ) info [ \"files\" ] = self . files info [ \"pieces\" ] = b \"\" . join ( self . pieces ) self . meta [ \"piece layers\" ] = self . piece_layers return info def _traverse ( self , path : str ) -> dict : \"\"\" Build meta dictionary while walking directory. **DEPRECATED** Parameters ---------- path : str Path to target file. \"\"\" if os . path . isfile ( path ): file_size = os . path . getsize ( path ) self . files . append ( { \"length\" : file_size , \"path\" : os . path . relpath ( path , self . path ) . split ( os . sep ), } ) if file_size == 0 : return { \"\" : { \"length\" : file_size }} logger . debug ( \"Hashing %s \" , str ( path )) file_hash = HasherHybrid ( path , self . piece_length , self . progress ) self . prog_update ( file_size ) if file_size > self . piece_length : self . piece_layers [ file_hash . root ] = file_hash . piece_layer self . hashes . append ( file_hash ) self . pieces . extend ( file_hash . pieces ) if file_hash . padding_file : self . files . append ( file_hash . padding_file ) return { \"\" : { \"length\" : file_size , \"pieces root\" : file_hash . root }} tree = {} if os . path . isdir ( path ): for name in sorted ( os . listdir ( path )): tree [ name ] = self . _traverse ( os . path . join ( path , name )) return tree __init__ ( ** kwargs ) \u00a4 Create Bittorrent v1 v2 hybrid metafiles. Source code in torrentfile\\torrent.py 565 566 567 568 569 570 571 572 573 574 575 576 577 def __init__ ( self , ** kwargs ): \"\"\" Create Bittorrent v1 v2 hybrid metafiles. \"\"\" super () . __init__ ( ** kwargs ) logger . debug ( \"Assembling bittorrent Hybrid file\" ) self . name = os . path . basename ( self . path ) self . hashes = [] self . piece_layers = {} self . pieces = [] self . files = [] self . total = len ( utils . get_file_list ( self . path )) self . assemble () _traverse ( path ) \u00a4 Build meta dictionary while walking directory. DEPRECATED Parameters \u00a4 str Path to target file. Source code in torrentfile\\torrent.py 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 def _traverse ( self , path : str ) -> dict : \"\"\" Build meta dictionary while walking directory. **DEPRECATED** Parameters ---------- path : str Path to target file. \"\"\" if os . path . isfile ( path ): file_size = os . path . getsize ( path ) self . files . append ( { \"length\" : file_size , \"path\" : os . path . relpath ( path , self . path ) . split ( os . sep ), } ) if file_size == 0 : return { \"\" : { \"length\" : file_size }} logger . debug ( \"Hashing %s \" , str ( path )) file_hash = HasherHybrid ( path , self . piece_length , self . progress ) self . prog_update ( file_size ) if file_size > self . piece_length : self . piece_layers [ file_hash . root ] = file_hash . piece_layer self . hashes . append ( file_hash ) self . pieces . extend ( file_hash . pieces ) if file_hash . padding_file : self . files . append ( file_hash . padding_file ) return { \"\" : { \"length\" : file_size , \"pieces root\" : file_hash . root }} tree = {} if os . path . isdir ( path ): for name in sorted ( os . listdir ( path )): tree [ name ] = self . _traverse ( os . path . join ( path , name )) return tree assemble () \u00a4 Assemble the parts of the torrentfile into meta dictionary. DEPRECATED Source code in torrentfile\\torrent.py 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 def assemble ( self ): \"\"\" Assemble the parts of the torrentfile into meta dictionary. **DEPRECATED** \"\"\" info = self . meta [ \"info\" ] info [ \"meta version\" ] = 2 if os . path . isfile ( self . path ): info [ \"file tree\" ] = { self . name : self . _traverse ( self . path )} info [ \"length\" ] = os . path . getsize ( self . path ) else : info [ \"file tree\" ] = self . _traverse ( self . path ) info [ \"files\" ] = self . files info [ \"pieces\" ] = b \"\" . join ( self . pieces ) self . meta [ \"piece layers\" ] = self . piece_layers return info TorrentFileV2 \u00a4 Bases: MetaFile , ProgMixin Class for creating Bittorrent meta v2 files. DEPRECATED Parameters \u00a4 **kwargs : dict Keyword arguments for torrent file options. Source code in torrentfile\\torrent.py 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 class TorrentFileV2 ( MetaFile , ProgMixin ): \"\"\" Class for creating Bittorrent meta v2 files. **DEPRECATED** Parameters ---------- **kwargs : dict Keyword arguments for torrent file options. \"\"\" hasher = HasherV2 def __init__ ( self , ** kwargs ): \"\"\" Construct `TorrentFileV2` Class instance from given parameters. **DEPRECATED** Parameters ---------- **kwargs : dict keywword arguments to pass to superclass. \"\"\" super () . __init__ ( ** kwargs ) logger . debug ( \"Assembling bittorrent v2 torrent file\" ) self . piece_layers = {} self . hashes = [] self . total = len ( utils . get_file_list ( self . path )) self . assemble () def assemble ( self ): \"\"\" Assemble then return the meta dictionary for encoding. **DEPRECATED** Returns ------- meta : dict Metainformation about the torrent. \"\"\" info = self . meta [ \"info\" ] if os . path . isfile ( self . path ): info [ \"file tree\" ] = { info [ \"name\" ]: self . _traverse ( self . path )} info [ \"length\" ] = os . path . getsize ( self . path ) self . prog_update ( info [ \"length\" ]) else : info [ \"file tree\" ] = self . _traverse ( self . path ) info [ \"meta version\" ] = 2 self . meta [ \"piece layers\" ] = self . piece_layers def _traverse ( self , path : str ) -> dict : \"\"\" Walk directory tree. **DEPRECATED** Parameters ---------- path : str Path to file or directory. \"\"\" if os . path . isfile ( path ): # Calculate Size and hashes for each file. size = os . path . getsize ( path ) if size == 0 : return { \"\" : { \"length\" : size }} logger . debug ( \"Hashing %s \" , str ( path )) fhash = HasherV2 ( path , self . piece_length , self . progress ) if size > self . piece_length : self . piece_layers [ fhash . root ] = fhash . piece_layer return { \"\" : { \"length\" : size , \"pieces root\" : fhash . root }} file_tree = {} if os . path . isdir ( path ): for name in sorted ( os . listdir ( path )): file_tree [ name ] = self . _traverse ( os . path . join ( path , name )) return file_tree __init__ ( ** kwargs ) \u00a4 Construct TorrentFileV2 Class instance from given parameters. DEPRECATED Parameters \u00a4 **kwargs : dict keywword arguments to pass to superclass. Source code in torrentfile\\torrent.py 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 def __init__ ( self , ** kwargs ): \"\"\" Construct `TorrentFileV2` Class instance from given parameters. **DEPRECATED** Parameters ---------- **kwargs : dict keywword arguments to pass to superclass. \"\"\" super () . __init__ ( ** kwargs ) logger . debug ( \"Assembling bittorrent v2 torrent file\" ) self . piece_layers = {} self . hashes = [] self . total = len ( utils . get_file_list ( self . path )) self . assemble () _traverse ( path ) \u00a4 Walk directory tree. DEPRECATED Parameters \u00a4 str Path to file or directory. Source code in torrentfile\\torrent.py 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 def _traverse ( self , path : str ) -> dict : \"\"\" Walk directory tree. **DEPRECATED** Parameters ---------- path : str Path to file or directory. \"\"\" if os . path . isfile ( path ): # Calculate Size and hashes for each file. size = os . path . getsize ( path ) if size == 0 : return { \"\" : { \"length\" : size }} logger . debug ( \"Hashing %s \" , str ( path )) fhash = HasherV2 ( path , self . piece_length , self . progress ) if size > self . piece_length : self . piece_layers [ fhash . root ] = fhash . piece_layer return { \"\" : { \"length\" : size , \"pieces root\" : fhash . root }} file_tree = {} if os . path . isdir ( path ): for name in sorted ( os . listdir ( path )): file_tree [ name ] = self . _traverse ( os . path . join ( path , name )) return file_tree assemble () \u00a4 Assemble then return the meta dictionary for encoding. DEPRECATED Returns \u00a4 dict Metainformation about the torrent. Source code in torrentfile\\torrent.py 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 def assemble ( self ): \"\"\" Assemble then return the meta dictionary for encoding. **DEPRECATED** Returns ------- meta : dict Metainformation about the torrent. \"\"\" info = self . meta [ \"info\" ] if os . path . isfile ( self . path ): info [ \"file tree\" ] = { info [ \"name\" ]: self . _traverse ( self . path )} info [ \"length\" ] = os . path . getsize ( self . path ) self . prog_update ( info [ \"length\" ]) else : info [ \"file tree\" ] = self . _traverse ( self . path ) info [ \"meta version\" ] = 2 self . meta [ \"piece layers\" ] = self . piece_layers","title":"torrent"},{"location":"torrent/#torrentfile.torrent--classes","text":"TorrentFile construct .torrent file. TorrentFileV2 construct .torrent v2 files using provided data. MetaFile base class for all MetaFile classes.","title":"Classes"},{"location":"torrent/#torrentfile.torrent--constants","text":"BLOCK_SIZE : int size of leaf hashes for merkle tree. HASH_SIZE : int Length of a sha256 hash.","title":"Constants"},{"location":"torrent/#torrentfile.torrent--bittorrent-v2","text":"From Bittorrent.org Documentation pages. Implementation details for Bittorrent Protocol v2. Note All strings in a .torrent file that contain text must be UTF-8 encoded.","title":"Bittorrent V2"},{"location":"torrent/#torrentfile.torrent--meta-version-2-dictionary","text":"\"announce\": The URL of the tracker. \"info\": This maps to a dictionary, with keys described below. \"name\": A display name for the torrent. It is purely advisory. \"piece length\": The number of bytes that each logical piece in the peer protocol refers to. I.e. it sets the granularity of piece, request, bitfield and have messages. It must be a power of two and at least 6KiB. \"meta version\": An integer value, set to 2 to indicate compatibility with the current revision of this specification. Version 1 is not assigned to avoid confusion with BEP3. Future revisions will only increment this issue to indicate an incompatible change has been made, for example that hash algorithms were changed due to newly discovered vulnerabilities. Lementations must check this field first and indicate that a torrent is of a newer version than they can handle before performing other idations which may result in more general messages about invalid files. Files are mapped into this piece address space so that each non-empty \"file tree\": A tree of dictionaries where dictionary keys represent UTF-8 encoded path elements. Entries with zero-length keys describe the properties of the composed path at that point. 'UTF-8 encoded' context only means that if the native encoding is known at creation time it must be converted to UTF-8. Keys may contain invalid UTF-8 sequences or characters and names that are reserved on specific filesystems. Implementations must be prepared to sanitize them. On platforms path components exactly matching '.' and '..' must be sanitized since they could lead to directory traversal attacks and conflicting path descriptions. On platforms that require UTF-8 path components this sanitizing step must happen after normalizing overlong UTF-8 encodings. File is aligned to a piece boundary and occurs in same order as the file tree. The last piece of each file may be shorter than the specified piece length, resulting in an alignment gap. \"length\": Length of the file in bytes. Presence of this field indicates that the dictionary describes a file, not a directory. Which means it must not have any sibling entries. \"pieces root\": For non-empty files this is the the root hash of a merkle tree with a branching factor of 2, constructed from 16KiB blocks of the file. The last block may be shorter than 16KiB. The remaining leaf hashes beyond the end of the file required to construct upper layers of the merkle tree are set to zero. As of meta version 2 SHA2-256 is used as digest function for the merkle tree. The hash is stored in its binary form, not as human-readable string. \"piece layers\": A dictionary of strings. For each file in the file tree that is larger than the piece size it contains one string value. The keys are the merkle roots while the values consist of concatenated hashes of one layer within that merkle tree. The layer is chosen so that one hash covers piece length bytes. For example if the piece size is 16KiB then the leaf hashes are used. If a piece size of 128KiB is used then 3rd layer up from the leaf hashes is used. Layer hashes which exclusively cover data beyond the end of file, i.e. are only needed to balance the tree, are omitted. All hashes are stored in their binary format. A torrent is not valid if this field is absent, the contained hashes do not match the merkle roots or are not from the correct layer. Important The file tree root dictionary itself must not be a file, i.e. it must not contain a zero-length key with a dictionary containing a length key.","title":"Meta Version 2 Dictionary:"},{"location":"torrent/#torrentfile.torrent--bittorrent-v1","text":"","title":"Bittorrent V1"},{"location":"torrent/#torrentfile.torrent--v1-meta-dictionary","text":"announce: The URL of the tracker. info: This maps to a dictionary, with keys described below. name : maps to a UTF-8 encoded string which is the suggested name to save the file (or directory) as. It is purely advisory. piece length : maps to the number of bytes in each piece the file is split into. For the purposes of transfer, files are split into fixed-size pieces which are all the same length except for possibly the last one which may be truncated. piece length : is almost always a power of two, most commonly 2^18 = 256 K pieces : maps to a string whose length is a multiple of 20. It is to be subdivided into strings of length 20, each of which is the SHA1 hash of the piece at the corresponding index. length : In the single file case, maps to the length of the file in bytes. files : If present then the download represents a single file, otherwise it represents a set of files which go in a directory structure. For the purposes of the other keys, the multi-file case is treated as only having a single file by concatenating the files in the order they appear in the files list. The files list is the value files maps to, and is a list of dictionaries containing the following keys: path : A list of UTF-8 encoded strings corresponding to subdirectory names, the last of which is the actual file name length : Maps to the length of the file in bytes. length : Only present if the content is a single file. Maps to the length of the file in bytes. Note In the single file case, the name key is the name of a file, in the muliple file case, it's the name of a directory.","title":"v1 meta-dictionary"},{"location":"torrent/#torrentfile.torrent.MetaFile","text":"Base Class for all TorrentFile classes.","title":"MetaFile"},{"location":"torrent/#torrentfile.torrent.MetaFile--parameters","text":"str target path to torrent content. Default: None str One or more tracker URL's. Default: None str A comment. Default: None int Size of torrent pieces. Default: None bool For private trackers. Default: None str target path to write .torrent file. Default: None str Private tracker source. Default: None str level of progress bar displayed Default: \"1\" bool If True change default save location to current directory list one or more web addresses where torrent content can be found. list one or more web addressess where torrent content exists. str alias for 'path' arg. int indicates which Bittorrent protocol to use for hashing content Source code in torrentfile\\torrent.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 class MetaFile : \"\"\" Base Class for all TorrentFile classes. Parameters ---------- path : str target path to torrent content. Default: None announce : str One or more tracker URL's. Default: None comment : str A comment. Default: None piece_length : int Size of torrent pieces. Default: None private : bool For private trackers. Default: None outfile : str target path to write .torrent file. Default: None source : str Private tracker source. Default: None progress : str level of progress bar displayed Default: \"1\" cwd : bool If True change default save location to current directory httpseeds : list one or more web addresses where torrent content can be found. url_list : list one or more web addressess where torrent content exists. content : str alias for 'path' arg. meta_version : int indicates which Bittorrent protocol to use for hashing content \"\"\" hasher = None @classmethod def set_callback ( cls , func ): \"\"\" Assign a callback function for the Hashing class to call for each hash. Parameters ---------- func : function The callback function which accepts a single paramter. \"\"\" if \"hasher\" in vars ( cls ) and vars ( cls )[ \"hasher\" ]: cls . hasher . set_callback ( func ) def __init__ ( self , path = None , announce = None , comment = None , piece_length = None , private = False , outfile = None , source = None , progress = 1 , cwd = False , httpseeds = None , url_list = None , content = None , meta_version = None , ** _ , ): \"\"\" Construct MetaFile superclass and assign local attributes. \"\"\" self . private = private self . cwd = cwd self . outfile = outfile self . progress = int ( progress ) self . comment = comment self . source = source self . meta_version = meta_version if content : path = content if not path : if announce and len ( announce ) > 1 and os . path . exists ( announce [ - 1 ]): path = announce [ - 1 ] announce = announce [: - 1 ] elif url_list and os . path . exists ( url_list [ - 1 ]): path = url_list [ - 1 ] url_list = url_list [: - 1 ] elif httpseeds and os . path . exists ( httpseeds [ - 1 ]): path = httpseeds [ - 1 ] httpseeds = httpseeds [: - 1 ] else : raise utils . MissingPathError ( \"Path to content is required.\" ) # base path to torrent content. self . path = path logger . debug ( \"path parameter found %s \" , path ) # Format piece_length attribute. if piece_length : self . piece_length = utils . normalize_piece_length ( piece_length ) logger . debug ( \"piece length parameter found %s \" , piece_length ) else : self . piece_length = utils . path_piece_length ( self . path ) logger . debug ( \"piece length calculated %s \" , self . piece_length ) # Assign announce URL to empty string if none provided. if not announce : self . announce , self . announce_list = \"\" , [[ \"\" ]] # Most torrent clients have editting trackers as a feature. elif isinstance ( announce , str ): self . announce , self . announce_list = announce , [[ announce ]] elif isinstance ( announce , Sequence ): self . announce , self . announce_list = announce [ 0 ], [ announce ] self . meta = { \"announce\" : self . announce , \"announce-list\" : self . announce_list , \"created by\" : f \"TorrentFile:v { version } \" , \"creation date\" : int ( datetime . timestamp ( datetime . now ())), \"info\" : {}, } if comment : self . meta [ \"info\" ][ \"comment\" ] = comment logger . debug ( \"comment parameter found %s \" , comment ) if private : self . meta [ \"info\" ][ \"private\" ] = 1 logger . debug ( \"private parameter triggered\" ) if source : self . meta [ \"info\" ][ \"source\" ] = source logger . debug ( \"source parameter found %s \" , source ) if url_list : self . meta [ \"url-list\" ] = url_list logger . debug ( \"url list parameter found %s \" , str ( url_list )) if httpseeds : self . meta [ \"httpseeds\" ] = httpseeds logger . debug ( \"httpseeds parameter found %s \" , str ( httpseeds )) self . meta [ \"info\" ][ \"piece length\" ] = self . piece_length self . meta_version = meta_version parent , self . name = os . path . split ( self . path ) if not self . name : self . name = os . path . basename ( parent ) self . meta [ \"info\" ][ \"name\" ] = self . name def assemble ( self ): \"\"\" Overload in subclasses. Raises ------ Exception NotImplementedError \"\"\" raise NotImplementedError def sort_meta ( self ): \"\"\"Sort the info and meta dictionaries.\"\"\" logger . debug ( \"sorting dictionary keys\" ) meta = self . meta meta [ \"info\" ] = dict ( sorted ( list ( meta [ \"info\" ] . items ()))) meta = dict ( sorted ( list ( meta . items ()))) return meta def write ( self , outfile = None ) -> tuple : \"\"\" Write meta information to .torrent file. Final step in the torrent file creation process. After hashing and sorting every piece of content write the contents to file using the bencode encoding. Parameters ---------- outfile : str Destination path for .torrent file. default=None Returns ------- outfile : str Where the .torrent file was writen. meta : dict .torrent meta information. \"\"\" if outfile : self . outfile = outfile elif self . outfile : pass else : self . outfile = os . path . join ( os . getcwd (), self . name ) + \".torrent\" if str ( self . outfile )[ - 1 ] in \" \\\\ /\" : self . outfile = self . outfile + ( self . name + \".torrent\" ) self . meta = self . sort_meta () try : pyben . dump ( self . meta , self . outfile ) except PermissionError as excp : logger . error ( \"Permission Denied: Could not write to %s \" , self . outfile ) raise PermissionError from excp return self . outfile , self . meta","title":"Parameters"},{"location":"torrent/#torrentfile.torrent.MetaFile.__init__","text":"Construct MetaFile superclass and assign local attributes. Source code in torrentfile\\torrent.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 def __init__ ( self , path = None , announce = None , comment = None , piece_length = None , private = False , outfile = None , source = None , progress = 1 , cwd = False , httpseeds = None , url_list = None , content = None , meta_version = None , ** _ , ): \"\"\" Construct MetaFile superclass and assign local attributes. \"\"\" self . private = private self . cwd = cwd self . outfile = outfile self . progress = int ( progress ) self . comment = comment self . source = source self . meta_version = meta_version if content : path = content if not path : if announce and len ( announce ) > 1 and os . path . exists ( announce [ - 1 ]): path = announce [ - 1 ] announce = announce [: - 1 ] elif url_list and os . path . exists ( url_list [ - 1 ]): path = url_list [ - 1 ] url_list = url_list [: - 1 ] elif httpseeds and os . path . exists ( httpseeds [ - 1 ]): path = httpseeds [ - 1 ] httpseeds = httpseeds [: - 1 ] else : raise utils . MissingPathError ( \"Path to content is required.\" ) # base path to torrent content. self . path = path logger . debug ( \"path parameter found %s \" , path ) # Format piece_length attribute. if piece_length : self . piece_length = utils . normalize_piece_length ( piece_length ) logger . debug ( \"piece length parameter found %s \" , piece_length ) else : self . piece_length = utils . path_piece_length ( self . path ) logger . debug ( \"piece length calculated %s \" , self . piece_length ) # Assign announce URL to empty string if none provided. if not announce : self . announce , self . announce_list = \"\" , [[ \"\" ]] # Most torrent clients have editting trackers as a feature. elif isinstance ( announce , str ): self . announce , self . announce_list = announce , [[ announce ]] elif isinstance ( announce , Sequence ): self . announce , self . announce_list = announce [ 0 ], [ announce ] self . meta = { \"announce\" : self . announce , \"announce-list\" : self . announce_list , \"created by\" : f \"TorrentFile:v { version } \" , \"creation date\" : int ( datetime . timestamp ( datetime . now ())), \"info\" : {}, } if comment : self . meta [ \"info\" ][ \"comment\" ] = comment logger . debug ( \"comment parameter found %s \" , comment ) if private : self . meta [ \"info\" ][ \"private\" ] = 1 logger . debug ( \"private parameter triggered\" ) if source : self . meta [ \"info\" ][ \"source\" ] = source logger . debug ( \"source parameter found %s \" , source ) if url_list : self . meta [ \"url-list\" ] = url_list logger . debug ( \"url list parameter found %s \" , str ( url_list )) if httpseeds : self . meta [ \"httpseeds\" ] = httpseeds logger . debug ( \"httpseeds parameter found %s \" , str ( httpseeds )) self . meta [ \"info\" ][ \"piece length\" ] = self . piece_length self . meta_version = meta_version parent , self . name = os . path . split ( self . path ) if not self . name : self . name = os . path . basename ( parent ) self . meta [ \"info\" ][ \"name\" ] = self . name","title":"__init__()"},{"location":"torrent/#torrentfile.torrent.MetaFile.assemble","text":"Overload in subclasses.","title":"assemble()"},{"location":"torrent/#torrentfile.torrent.MetaFile.assemble--raises","text":"Exception NotImplementedError Source code in torrentfile\\torrent.py 350 351 352 353 354 355 356 357 358 359 def assemble ( self ): \"\"\" Overload in subclasses. Raises ------ Exception NotImplementedError \"\"\" raise NotImplementedError","title":"Raises"},{"location":"torrent/#torrentfile.torrent.MetaFile.set_callback","text":"Assign a callback function for the Hashing class to call for each hash.","title":"set_callback()"},{"location":"torrent/#torrentfile.torrent.MetaFile.set_callback--parameters","text":"function The callback function which accepts a single paramter. Source code in torrentfile\\torrent.py 240 241 242 243 244 245 246 247 248 249 250 251 @classmethod def set_callback ( cls , func ): \"\"\" Assign a callback function for the Hashing class to call for each hash. Parameters ---------- func : function The callback function which accepts a single paramter. \"\"\" if \"hasher\" in vars ( cls ) and vars ( cls )[ \"hasher\" ]: cls . hasher . set_callback ( func )","title":"Parameters"},{"location":"torrent/#torrentfile.torrent.MetaFile.sort_meta","text":"Sort the info and meta dictionaries. Source code in torrentfile\\torrent.py 361 362 363 364 365 366 367 def sort_meta ( self ): \"\"\"Sort the info and meta dictionaries.\"\"\" logger . debug ( \"sorting dictionary keys\" ) meta = self . meta meta [ \"info\" ] = dict ( sorted ( list ( meta [ \"info\" ] . items ()))) meta = dict ( sorted ( list ( meta . items ()))) return meta","title":"sort_meta()"},{"location":"torrent/#torrentfile.torrent.MetaFile.write","text":"Write meta information to .torrent file. Final step in the torrent file creation process. After hashing and sorting every piece of content write the contents to file using the bencode encoding.","title":"write()"},{"location":"torrent/#torrentfile.torrent.MetaFile.write--parameters","text":"str Destination path for .torrent file. default=None","title":"Parameters"},{"location":"torrent/#torrentfile.torrent.MetaFile.write--returns","text":"str Where the .torrent file was writen. dict .torrent meta information. Source code in torrentfile\\torrent.py 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 def write ( self , outfile = None ) -> tuple : \"\"\" Write meta information to .torrent file. Final step in the torrent file creation process. After hashing and sorting every piece of content write the contents to file using the bencode encoding. Parameters ---------- outfile : str Destination path for .torrent file. default=None Returns ------- outfile : str Where the .torrent file was writen. meta : dict .torrent meta information. \"\"\" if outfile : self . outfile = outfile elif self . outfile : pass else : self . outfile = os . path . join ( os . getcwd (), self . name ) + \".torrent\" if str ( self . outfile )[ - 1 ] in \" \\\\ /\" : self . outfile = self . outfile + ( self . name + \".torrent\" ) self . meta = self . sort_meta () try : pyben . dump ( self . meta , self . outfile ) except PermissionError as excp : logger . error ( \"Permission Denied: Could not write to %s \" , self . outfile ) raise PermissionError from excp return self . outfile , self . meta","title":"Returns"},{"location":"torrent/#torrentfile.torrent.TorrentAssembler","text":"Bases: MetaFile Assembler class for Bittorrent version 2 and hybrid meta files. This differs from the TorrentFileV2 and TorrentFileHybrid, because it can be used as an iterator and works for both versions.","title":"TorrentAssembler"},{"location":"torrent/#torrentfile.torrent.TorrentAssembler--parameters","text":"**kwargs : dict Keyword arguments for torrent options. Source code in torrentfile\\torrent.py 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 class TorrentAssembler ( MetaFile ): \"\"\" Assembler class for Bittorrent version 2 and hybrid meta files. This differs from the TorrentFileV2 and TorrentFileHybrid, because it can be used as an iterator and works for both versions. Parameters ---------- **kwargs : dict Keyword arguments for torrent options. \"\"\" hasher = FileHasher def __init__ ( self , ** kwargs ): \"\"\" Create Bittorrent v1 v2 hybrid metafiles. \"\"\" super () . __init__ ( ** kwargs ) logger . debug ( \"Assembling bittorrent Hybrid file\" ) self . name = os . path . basename ( self . path ) self . hashes = [] self . piece_layers = {} self . pieces = bytearray () self . files = [] self . hybrid = self . meta_version == \"3\" self . total = len ( utils . get_file_list ( self . path )) self . assemble () def assemble ( self ): \"\"\" Assemble the parts of the torrentfile into meta dictionary. \"\"\" info = self . meta [ \"info\" ] info [ \"meta version\" ] = 2 if os . path . isfile ( self . path ): info [ \"file tree\" ] = { self . name : self . _traverse ( self . path )} info [ \"length\" ] = os . path . getsize ( self . path ) else : info [ \"file tree\" ] = self . _traverse ( self . path ) if self . hybrid : info [ \"files\" ] = self . files if self . hybrid : info [ \"pieces\" ] = self . pieces self . meta [ \"piece layers\" ] = self . piece_layers return info def _traverse ( self , path : str ) -> dict : \"\"\" Build meta dictionary while walking directory. Parameters ---------- path : str Path to target file. \"\"\" if os . path . isfile ( path ): file_size = os . path . getsize ( path ) if self . hybrid : self . files . append ( { \"length\" : file_size , \"path\" : os . path . relpath ( path , self . path ) . split ( os . sep ), } ) if file_size == 0 : return { \"\" : { \"length\" : file_size }} logger . debug ( \"Hashing %s \" , str ( path )) hasher = FileHasher ( path , self . piece_length , progress = True , hybrid = self . hybrid ) layers = bytearray () for result in hasher : if self . hybrid : layer_hash , piece = result self . pieces . extend ( piece ) else : layer_hash = result layers . extend ( layer_hash ) if file_size > self . piece_length : self . piece_layers [ hasher . root ] = layers if self . hybrid and hasher . padding_file : self . files . append ( hasher . padding_file ) return { \"\" : { \"length\" : file_size , \"pieces root\" : hasher . root }} tree = {} if os . path . isdir ( path ): for name in sorted ( os . listdir ( path )): tree [ name ] = self . _traverse ( os . path . join ( path , name )) return tree","title":"Parameters"},{"location":"torrent/#torrentfile.torrent.TorrentAssembler.__init__","text":"Create Bittorrent v1 v2 hybrid metafiles. Source code in torrentfile\\torrent.py 661 662 663 664 665 666 667 668 669 670 671 672 673 674 def __init__ ( self , ** kwargs ): \"\"\" Create Bittorrent v1 v2 hybrid metafiles. \"\"\" super () . __init__ ( ** kwargs ) logger . debug ( \"Assembling bittorrent Hybrid file\" ) self . name = os . path . basename ( self . path ) self . hashes = [] self . piece_layers = {} self . pieces = bytearray () self . files = [] self . hybrid = self . meta_version == \"3\" self . total = len ( utils . get_file_list ( self . path )) self . assemble ()","title":"__init__()"},{"location":"torrent/#torrentfile.torrent.TorrentAssembler._traverse","text":"Build meta dictionary while walking directory.","title":"_traverse()"},{"location":"torrent/#torrentfile.torrent.TorrentAssembler._traverse--parameters","text":"str Path to target file. Source code in torrentfile\\torrent.py 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 def _traverse ( self , path : str ) -> dict : \"\"\" Build meta dictionary while walking directory. Parameters ---------- path : str Path to target file. \"\"\" if os . path . isfile ( path ): file_size = os . path . getsize ( path ) if self . hybrid : self . files . append ( { \"length\" : file_size , \"path\" : os . path . relpath ( path , self . path ) . split ( os . sep ), } ) if file_size == 0 : return { \"\" : { \"length\" : file_size }} logger . debug ( \"Hashing %s \" , str ( path )) hasher = FileHasher ( path , self . piece_length , progress = True , hybrid = self . hybrid ) layers = bytearray () for result in hasher : if self . hybrid : layer_hash , piece = result self . pieces . extend ( piece ) else : layer_hash = result layers . extend ( layer_hash ) if file_size > self . piece_length : self . piece_layers [ hasher . root ] = layers if self . hybrid and hasher . padding_file : self . files . append ( hasher . padding_file ) return { \"\" : { \"length\" : file_size , \"pieces root\" : hasher . root }} tree = {} if os . path . isdir ( path ): for name in sorted ( os . listdir ( path )): tree [ name ] = self . _traverse ( os . path . join ( path , name )) return tree","title":"Parameters"},{"location":"torrent/#torrentfile.torrent.TorrentAssembler.assemble","text":"Assemble the parts of the torrentfile into meta dictionary. Source code in torrentfile\\torrent.py 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 def assemble ( self ): \"\"\" Assemble the parts of the torrentfile into meta dictionary. \"\"\" info = self . meta [ \"info\" ] info [ \"meta version\" ] = 2 if os . path . isfile ( self . path ): info [ \"file tree\" ] = { self . name : self . _traverse ( self . path )} info [ \"length\" ] = os . path . getsize ( self . path ) else : info [ \"file tree\" ] = self . _traverse ( self . path ) if self . hybrid : info [ \"files\" ] = self . files if self . hybrid : info [ \"pieces\" ] = self . pieces self . meta [ \"piece layers\" ] = self . piece_layers return info","title":"assemble()"},{"location":"torrent/#torrentfile.torrent.TorrentFile","text":"Bases: MetaFile , ProgMixin Class for creating Bittorrent meta files. Construct Torrentfile class instance object.","title":"TorrentFile"},{"location":"torrent/#torrentfile.torrent.TorrentFile--parameters","text":"**kwargs : dict Dictionary containing torrent file options. Source code in torrentfile\\torrent.py 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 class TorrentFile ( MetaFile , ProgMixin ): \"\"\" Class for creating Bittorrent meta files. Construct *Torrentfile* class instance object. Parameters ---------- **kwargs : dict Dictionary containing torrent file options. \"\"\" hasher = Hasher def __init__ ( self , ** kwargs ): \"\"\" Construct TorrentFile instance with given keyword args. Parameters ---------- **kwargs : dict dictionary of keyword args passed to superclass. \"\"\" super () . __init__ ( ** kwargs ) logger . debug ( \"Assembling bittorrent v1 torrent file\" ) self . assemble () def assemble ( self ): \"\"\" Assemble components of torrent metafile. Returns ------- dict metadata dictionary for torrent file \"\"\" info = self . meta [ \"info\" ] size , filelist = utils . filelist_total ( self . path ) if os . path . isfile ( self . path ): info [ \"length\" ] = size else : info [ \"files\" ] = [ { \"length\" : os . path . getsize ( path ), \"path\" : os . path . relpath ( path , self . path ) . split ( os . sep ), } for path in filelist ] pieces = bytearray () feeder = Hasher ( filelist , self . piece_length , self . progress ) for piece in feeder : pieces . extend ( piece ) info [ \"pieces\" ] = pieces","title":"Parameters"},{"location":"torrent/#torrentfile.torrent.TorrentFile.__init__","text":"Construct TorrentFile instance with given keyword args.","title":"__init__()"},{"location":"torrent/#torrentfile.torrent.TorrentFile.__init__--parameters","text":"**kwargs : dict dictionary of keyword args passed to superclass. Source code in torrentfile\\torrent.py 422 423 424 425 426 427 428 429 430 431 432 433 def __init__ ( self , ** kwargs ): \"\"\" Construct TorrentFile instance with given keyword args. Parameters ---------- **kwargs : dict dictionary of keyword args passed to superclass. \"\"\" super () . __init__ ( ** kwargs ) logger . debug ( \"Assembling bittorrent v1 torrent file\" ) self . assemble ()","title":"Parameters"},{"location":"torrent/#torrentfile.torrent.TorrentFile.assemble","text":"Assemble components of torrent metafile.","title":"assemble()"},{"location":"torrent/#torrentfile.torrent.TorrentFile.assemble--returns","text":"dict metadata dictionary for torrent file Source code in torrentfile\\torrent.py 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 def assemble ( self ): \"\"\" Assemble components of torrent metafile. Returns ------- dict metadata dictionary for torrent file \"\"\" info = self . meta [ \"info\" ] size , filelist = utils . filelist_total ( self . path ) if os . path . isfile ( self . path ): info [ \"length\" ] = size else : info [ \"files\" ] = [ { \"length\" : os . path . getsize ( path ), \"path\" : os . path . relpath ( path , self . path ) . split ( os . sep ), } for path in filelist ] pieces = bytearray () feeder = Hasher ( filelist , self . piece_length , self . progress ) for piece in feeder : pieces . extend ( piece ) info [ \"pieces\" ] = pieces","title":"Returns"},{"location":"torrent/#torrentfile.torrent.TorrentFileHybrid","text":"Bases: MetaFile , ProgMixin Construct the Hybrid torrent meta file with provided parameters. DEPRECATED","title":"TorrentFileHybrid"},{"location":"torrent/#torrentfile.torrent.TorrentFileHybrid--parameters","text":"**kwargs : dict Keyword arguments for torrent options. Source code in torrentfile\\torrent.py 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 class TorrentFileHybrid ( MetaFile , ProgMixin ): \"\"\" Construct the Hybrid torrent meta file with provided parameters. **DEPRECATED** Parameters ---------- **kwargs : dict Keyword arguments for torrent options. \"\"\" hasher = HasherHybrid def __init__ ( self , ** kwargs ): \"\"\" Create Bittorrent v1 v2 hybrid metafiles. \"\"\" super () . __init__ ( ** kwargs ) logger . debug ( \"Assembling bittorrent Hybrid file\" ) self . name = os . path . basename ( self . path ) self . hashes = [] self . piece_layers = {} self . pieces = [] self . files = [] self . total = len ( utils . get_file_list ( self . path )) self . assemble () def assemble ( self ): \"\"\" Assemble the parts of the torrentfile into meta dictionary. **DEPRECATED** \"\"\" info = self . meta [ \"info\" ] info [ \"meta version\" ] = 2 if os . path . isfile ( self . path ): info [ \"file tree\" ] = { self . name : self . _traverse ( self . path )} info [ \"length\" ] = os . path . getsize ( self . path ) else : info [ \"file tree\" ] = self . _traverse ( self . path ) info [ \"files\" ] = self . files info [ \"pieces\" ] = b \"\" . join ( self . pieces ) self . meta [ \"piece layers\" ] = self . piece_layers return info def _traverse ( self , path : str ) -> dict : \"\"\" Build meta dictionary while walking directory. **DEPRECATED** Parameters ---------- path : str Path to target file. \"\"\" if os . path . isfile ( path ): file_size = os . path . getsize ( path ) self . files . append ( { \"length\" : file_size , \"path\" : os . path . relpath ( path , self . path ) . split ( os . sep ), } ) if file_size == 0 : return { \"\" : { \"length\" : file_size }} logger . debug ( \"Hashing %s \" , str ( path )) file_hash = HasherHybrid ( path , self . piece_length , self . progress ) self . prog_update ( file_size ) if file_size > self . piece_length : self . piece_layers [ file_hash . root ] = file_hash . piece_layer self . hashes . append ( file_hash ) self . pieces . extend ( file_hash . pieces ) if file_hash . padding_file : self . files . append ( file_hash . padding_file ) return { \"\" : { \"length\" : file_size , \"pieces root\" : file_hash . root }} tree = {} if os . path . isdir ( path ): for name in sorted ( os . listdir ( path )): tree [ name ] = self . _traverse ( os . path . join ( path , name )) return tree","title":"Parameters"},{"location":"torrent/#torrentfile.torrent.TorrentFileHybrid.__init__","text":"Create Bittorrent v1 v2 hybrid metafiles. Source code in torrentfile\\torrent.py 565 566 567 568 569 570 571 572 573 574 575 576 577 def __init__ ( self , ** kwargs ): \"\"\" Create Bittorrent v1 v2 hybrid metafiles. \"\"\" super () . __init__ ( ** kwargs ) logger . debug ( \"Assembling bittorrent Hybrid file\" ) self . name = os . path . basename ( self . path ) self . hashes = [] self . piece_layers = {} self . pieces = [] self . files = [] self . total = len ( utils . get_file_list ( self . path )) self . assemble ()","title":"__init__()"},{"location":"torrent/#torrentfile.torrent.TorrentFileHybrid._traverse","text":"Build meta dictionary while walking directory. DEPRECATED","title":"_traverse()"},{"location":"torrent/#torrentfile.torrent.TorrentFileHybrid._traverse--parameters","text":"str Path to target file. Source code in torrentfile\\torrent.py 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 def _traverse ( self , path : str ) -> dict : \"\"\" Build meta dictionary while walking directory. **DEPRECATED** Parameters ---------- path : str Path to target file. \"\"\" if os . path . isfile ( path ): file_size = os . path . getsize ( path ) self . files . append ( { \"length\" : file_size , \"path\" : os . path . relpath ( path , self . path ) . split ( os . sep ), } ) if file_size == 0 : return { \"\" : { \"length\" : file_size }} logger . debug ( \"Hashing %s \" , str ( path )) file_hash = HasherHybrid ( path , self . piece_length , self . progress ) self . prog_update ( file_size ) if file_size > self . piece_length : self . piece_layers [ file_hash . root ] = file_hash . piece_layer self . hashes . append ( file_hash ) self . pieces . extend ( file_hash . pieces ) if file_hash . padding_file : self . files . append ( file_hash . padding_file ) return { \"\" : { \"length\" : file_size , \"pieces root\" : file_hash . root }} tree = {} if os . path . isdir ( path ): for name in sorted ( os . listdir ( path )): tree [ name ] = self . _traverse ( os . path . join ( path , name )) return tree","title":"Parameters"},{"location":"torrent/#torrentfile.torrent.TorrentFileHybrid.assemble","text":"Assemble the parts of the torrentfile into meta dictionary. DEPRECATED Source code in torrentfile\\torrent.py 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 def assemble ( self ): \"\"\" Assemble the parts of the torrentfile into meta dictionary. **DEPRECATED** \"\"\" info = self . meta [ \"info\" ] info [ \"meta version\" ] = 2 if os . path . isfile ( self . path ): info [ \"file tree\" ] = { self . name : self . _traverse ( self . path )} info [ \"length\" ] = os . path . getsize ( self . path ) else : info [ \"file tree\" ] = self . _traverse ( self . path ) info [ \"files\" ] = self . files info [ \"pieces\" ] = b \"\" . join ( self . pieces ) self . meta [ \"piece layers\" ] = self . piece_layers return info","title":"assemble()"},{"location":"torrent/#torrentfile.torrent.TorrentFileV2","text":"Bases: MetaFile , ProgMixin Class for creating Bittorrent meta v2 files. DEPRECATED","title":"TorrentFileV2"},{"location":"torrent/#torrentfile.torrent.TorrentFileV2--parameters","text":"**kwargs : dict Keyword arguments for torrent file options. Source code in torrentfile\\torrent.py 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 class TorrentFileV2 ( MetaFile , ProgMixin ): \"\"\" Class for creating Bittorrent meta v2 files. **DEPRECATED** Parameters ---------- **kwargs : dict Keyword arguments for torrent file options. \"\"\" hasher = HasherV2 def __init__ ( self , ** kwargs ): \"\"\" Construct `TorrentFileV2` Class instance from given parameters. **DEPRECATED** Parameters ---------- **kwargs : dict keywword arguments to pass to superclass. \"\"\" super () . __init__ ( ** kwargs ) logger . debug ( \"Assembling bittorrent v2 torrent file\" ) self . piece_layers = {} self . hashes = [] self . total = len ( utils . get_file_list ( self . path )) self . assemble () def assemble ( self ): \"\"\" Assemble then return the meta dictionary for encoding. **DEPRECATED** Returns ------- meta : dict Metainformation about the torrent. \"\"\" info = self . meta [ \"info\" ] if os . path . isfile ( self . path ): info [ \"file tree\" ] = { info [ \"name\" ]: self . _traverse ( self . path )} info [ \"length\" ] = os . path . getsize ( self . path ) self . prog_update ( info [ \"length\" ]) else : info [ \"file tree\" ] = self . _traverse ( self . path ) info [ \"meta version\" ] = 2 self . meta [ \"piece layers\" ] = self . piece_layers def _traverse ( self , path : str ) -> dict : \"\"\" Walk directory tree. **DEPRECATED** Parameters ---------- path : str Path to file or directory. \"\"\" if os . path . isfile ( path ): # Calculate Size and hashes for each file. size = os . path . getsize ( path ) if size == 0 : return { \"\" : { \"length\" : size }} logger . debug ( \"Hashing %s \" , str ( path )) fhash = HasherV2 ( path , self . piece_length , self . progress ) if size > self . piece_length : self . piece_layers [ fhash . root ] = fhash . piece_layer return { \"\" : { \"length\" : size , \"pieces root\" : fhash . root }} file_tree = {} if os . path . isdir ( path ): for name in sorted ( os . listdir ( path )): file_tree [ name ] = self . _traverse ( os . path . join ( path , name )) return file_tree","title":"Parameters"},{"location":"torrent/#torrentfile.torrent.TorrentFileV2.__init__","text":"Construct TorrentFileV2 Class instance from given parameters. DEPRECATED","title":"__init__()"},{"location":"torrent/#torrentfile.torrent.TorrentFileV2.__init__--parameters","text":"**kwargs : dict keywword arguments to pass to superclass. Source code in torrentfile\\torrent.py 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 def __init__ ( self , ** kwargs ): \"\"\" Construct `TorrentFileV2` Class instance from given parameters. **DEPRECATED** Parameters ---------- **kwargs : dict keywword arguments to pass to superclass. \"\"\" super () . __init__ ( ** kwargs ) logger . debug ( \"Assembling bittorrent v2 torrent file\" ) self . piece_layers = {} self . hashes = [] self . total = len ( utils . get_file_list ( self . path )) self . assemble ()","title":"Parameters"},{"location":"torrent/#torrentfile.torrent.TorrentFileV2._traverse","text":"Walk directory tree. DEPRECATED","title":"_traverse()"},{"location":"torrent/#torrentfile.torrent.TorrentFileV2._traverse--parameters","text":"str Path to file or directory. Source code in torrentfile\\torrent.py 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 def _traverse ( self , path : str ) -> dict : \"\"\" Walk directory tree. **DEPRECATED** Parameters ---------- path : str Path to file or directory. \"\"\" if os . path . isfile ( path ): # Calculate Size and hashes for each file. size = os . path . getsize ( path ) if size == 0 : return { \"\" : { \"length\" : size }} logger . debug ( \"Hashing %s \" , str ( path )) fhash = HasherV2 ( path , self . piece_length , self . progress ) if size > self . piece_length : self . piece_layers [ fhash . root ] = fhash . piece_layer return { \"\" : { \"length\" : size , \"pieces root\" : fhash . root }} file_tree = {} if os . path . isdir ( path ): for name in sorted ( os . listdir ( path )): file_tree [ name ] = self . _traverse ( os . path . join ( path , name )) return file_tree","title":"Parameters"},{"location":"torrent/#torrentfile.torrent.TorrentFileV2.assemble","text":"Assemble then return the meta dictionary for encoding. DEPRECATED","title":"assemble()"},{"location":"torrent/#torrentfile.torrent.TorrentFileV2.assemble--returns","text":"dict Metainformation about the torrent. Source code in torrentfile\\torrent.py 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 def assemble ( self ): \"\"\" Assemble then return the meta dictionary for encoding. **DEPRECATED** Returns ------- meta : dict Metainformation about the torrent. \"\"\" info = self . meta [ \"info\" ] if os . path . isfile ( self . path ): info [ \"file tree\" ] = { info [ \"name\" ]: self . _traverse ( self . path )} info [ \"length\" ] = os . path . getsize ( self . path ) self . prog_update ( info [ \"length\" ]) else : info [ \"file tree\" ] = self . _traverse ( self . path ) info [ \"meta version\" ] = 2 self . meta [ \"piece layers\" ] = self . piece_layers","title":"Returns"},{"location":"utils/","text":"Utility functions and classes used throughout package. Functions get_piece_length: calculate ideal piece length for torrent file. sortfiles: traverse directory in sorted order yielding paths encountered. path_size: Sum the sizes of each file in path. get_file_list: Return list of all files contained in directory. path_stat: Get ideal piece length, total size, and file list for directory. path_piece_length: Get ideal piece length based on size of directory. Classes MissingPathError: Custom exception raised when no path was provided to CLI. PieceLengthValueError: Custom exception raised when incorrect input value used for piece length field. ArgumentError \u00a4 Bases: Exception Exception for mismatched or mistyped CLI arguments. Source code in torrentfile\\utils.py 123 124 125 126 class ArgumentError ( Exception ): \"\"\" Exception for mismatched or mistyped CLI arguments. \"\"\" Memo \u00a4 Memoize cache. Parameters \u00a4 Callable The results of this callable will be cached. Source code in torrentfile\\utils.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class Memo : \"\"\" Memoize cache. Parameters ---------- func : Callable The results of this callable will be cached. \"\"\" def __init__ ( self , func ): \"\"\" Construct for memoization. \"\"\" self . func = func self . counter = 0 self . cache = {} def __call__ ( self , path ): \"\"\" Invoke each time memo function is called. Parameters ---------- path : str The relative or absolute path being used as key in cache dict. Returns ------- Any : The results of calling the function with path. \"\"\" if path in self . cache and os . path . exists ( path ): self . counter += 1 return self . cache [ path ] result = self . func ( path ) self . cache [ path ] = result return result __call__ ( path ) \u00a4 Invoke each time memo function is called. Parameters \u00a4 str The relative or absolute path being used as key in cache dict. Returns \u00a4 Any The results of calling the function with path. Source code in torrentfile\\utils.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def __call__ ( self , path ): \"\"\" Invoke each time memo function is called. Parameters ---------- path : str The relative or absolute path being used as key in cache dict. Returns ------- Any : The results of calling the function with path. \"\"\" if path in self . cache and os . path . exists ( path ): self . counter += 1 return self . cache [ path ] result = self . func ( path ) self . cache [ path ] = result return result __init__ ( func ) \u00a4 Construct for memoization. Source code in torrentfile\\utils.py 51 52 53 54 55 56 57 def __init__ ( self , func ): \"\"\" Construct for memoization. \"\"\" self . func = func self . counter = 0 self . cache = {} MissingPathError \u00a4 Bases: Exception Path parameter is required to specify target content. Creating a .torrent file with no contents seems rather silly. Parameters \u00a4 str Message for user (optional). Source code in torrentfile\\utils.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class MissingPathError ( Exception ): \"\"\" Path parameter is required to specify target content. Creating a .torrent file with no contents seems rather silly. Parameters ---------- message : str Message for user (optional). \"\"\" def __init__ ( self , message : str = None ): \"\"\" Raise when creating a meta file without specifying target content. The `message` argument is a message to pass to Exception base class. \"\"\" self . message = f \"Path arguement is missing and required { str ( message ) } \" super () . __init__ ( message ) __init__ ( message = None ) \u00a4 Raise when creating a meta file without specifying target content. The message argument is a message to pass to Exception base class. Source code in torrentfile\\utils.py 93 94 95 96 97 98 99 100 def __init__ ( self , message : str = None ): \"\"\" Raise when creating a meta file without specifying target content. The `message` argument is a message to pass to Exception base class. \"\"\" self . message = f \"Path arguement is missing and required { str ( message ) } \" super () . __init__ ( message ) PieceLengthValueError \u00a4 Bases: Exception Piece Length parameter must equal a perfect power of 2. Parameters \u00a4 str Message for user (optional). Source code in torrentfile\\utils.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class PieceLengthValueError ( Exception ): \"\"\" Piece Length parameter must equal a perfect power of 2. Parameters ---------- message : str Message for user (optional). \"\"\" def __init__ ( self , message : str = None ): \"\"\" Raise when creating a meta file with incorrect piece length value. The `message` argument is a message to pass to Exception base class. \"\"\" self . message = f \"Incorrect value for piece length: { str ( message ) } \" super () . __init__ ( message ) __init__ ( message = None ) \u00a4 Raise when creating a meta file with incorrect piece length value. The message argument is a message to pass to Exception base class. Source code in torrentfile\\utils.py 113 114 115 116 117 118 119 120 def __init__ ( self , message : str = None ): \"\"\" Raise when creating a meta file with incorrect piece length value. The `message` argument is a message to pass to Exception base class. \"\"\" self . message = f \"Incorrect value for piece length: { str ( message ) } \" super () . __init__ ( message ) _filelist_total ( path ) \u00a4 Search directory tree for files. Parameters \u00a4 str Path to file or directory base Returns \u00a4 int Sum of all filesizes in filelist. list All file paths within directory tree. Source code in torrentfile\\utils.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def _filelist_total ( path : str ) -> tuple : \"\"\" Search directory tree for files. Parameters ---------- path : str Path to file or directory base Returns ------- int Sum of all filesizes in filelist. list All file paths within directory tree. \"\"\" if path . is_file (): file_size = os . path . getsize ( path ) return file_size , [ str ( path )] total = 0 filelist = [] if path . is_dir (): for item in path . iterdir (): size , paths = filelist_total ( item ) total += size filelist . extend ( paths ) return total , sorted ( filelist ) filelist_total ( pathstring ) \u00a4 Perform error checking and format conversion to os.PathLike. Parameters \u00a4 str An existing filesystem path. Returns \u00a4 os.PathLike Input path converted to bytes format. Raises \u00a4 MissingPathError File could not be found. Source code in torrentfile\\utils.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 @Memo def filelist_total ( pathstring : str ) -> os . PathLike : \"\"\" Perform error checking and format conversion to os.PathLike. Parameters ---------- pathstring : str An existing filesystem path. Returns ------- os.PathLike Input path converted to bytes format. Raises ------ MissingPathError File could not be found. \"\"\" if os . path . exists ( pathstring ): path = Path ( pathstring ) return _filelist_total ( path ) raise MissingPathError get_file_list ( path ) \u00a4 Return a sorted list of file paths contained in directory. Parameters \u00a4 str target file or directory. Returns \u00a4 list sorted list of file paths. Source code in torrentfile\\utils.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 def get_file_list ( path : str ) -> list : \"\"\" Return a sorted list of file paths contained in directory. Parameters ---------- path : str target file or directory. Returns ------- list sorted list of file paths. \"\"\" _ , filelist = filelist_total ( path ) return filelist get_piece_length ( size ) \u00a4 Calculate the ideal piece length for bittorrent data. Parameters \u00a4 int Total bits of all files incluided in .torrent file. Returns \u00a4 int Ideal piece length. Source code in torrentfile\\utils.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def get_piece_length ( size : int ) -> int : \"\"\" Calculate the ideal piece length for bittorrent data. Parameters ---------- size : int Total bits of all files incluided in .torrent file. Returns ------- int Ideal piece length. \"\"\" exp = 14 while size / ( 2 ** exp ) > 200 and exp < 25 : exp += 1 return 2 ** exp humanize_bytes ( amount ) \u00a4 Convert integer into human readable memory sized denomination. Parameters \u00a4 int total number of bytes. Returns \u00a4 str human readable representation of the given amount of bytes. Source code in torrentfile\\utils.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def humanize_bytes ( amount : int ) -> str : \"\"\" Convert integer into human readable memory sized denomination. Parameters ---------- amount : int total number of bytes. Returns ------- str human readable representation of the given amount of bytes. \"\"\" if amount < 1024 : return str ( amount ) if 1024 <= amount < 1_048_576 : return f \" { amount // 1024 } KiB\" if 1_048_576 <= amount < 1_073_741_824 : return f \" { amount // 1_048_576 } MiB\" return f \" { amount // 1073741824 } GiB\" next_power_2 ( value ) \u00a4 Calculate the next perfect power of 2 equal to or greater than value. Parameters \u00a4 int integer value that is less than some perfect power of 2. Returns \u00a4 int The next power of 2 greater than value, or value if already power of 2. Source code in torrentfile\\utils.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 def next_power_2 ( value : int ) -> int : \"\"\" Calculate the next perfect power of 2 equal to or greater than value. Parameters ---------- value : int integer value that is less than some perfect power of 2. Returns ------- int The next power of 2 greater than value, or value if already power of 2. \"\"\" if not value & ( value - 1 ) and value : return value start = 1 while start < value : start <<= 1 return start normalize_piece_length ( piece_length ) \u00a4 Verify input piece_length is valid and convert accordingly. Parameters \u00a4 int | str The piece length provided by user. Returns \u00a4 int normalized piece length. Raises \u00a4 PieceLengthValueError Piece length is improper value. Source code in torrentfile\\utils.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def normalize_piece_length ( piece_length : int ) -> int : \"\"\" Verify input piece_length is valid and convert accordingly. Parameters ---------- piece_length : int | str The piece length provided by user. Returns ------- int normalized piece length. Raises ------ PieceLengthValueError : Piece length is improper value. \"\"\" if isinstance ( piece_length , str ): if piece_length . isnumeric (): piece_length = int ( piece_length ) else : raise PieceLengthValueError ( piece_length ) if 13 < piece_length < 26 : return 2 ** piece_length if piece_length <= 13 : raise PieceLengthValueError ( piece_length ) log = int ( math . log2 ( piece_length )) if 2 ** log == piece_length : return piece_length raise PieceLengthValueError path_piece_length ( path ) \u00a4 Calculate piece length for input path and contents. Parameters \u00a4 str The absolute path to directory and contents. Returns \u00a4 int The size of pieces of torrent content. Source code in torrentfile\\utils.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 def path_piece_length ( path : str ) -> int : \"\"\" Calculate piece length for input path and contents. Parameters ---------- path : str The absolute path to directory and contents. Returns ------- int The size of pieces of torrent content. \"\"\" psize = path_size ( path ) return get_piece_length ( psize ) path_size ( path ) \u00a4 Return the total size of all files in path recursively. Parameters \u00a4 str path to target file or directory. Returns \u00a4 int total size of files. Source code in torrentfile\\utils.py 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 def path_size ( path : str ) -> int : \"\"\" Return the total size of all files in path recursively. Parameters ---------- path : str path to target file or directory. Returns ------- int total size of files. \"\"\" total_size , _ = filelist_total ( path ) return total_size path_stat ( path ) \u00a4 Calculate directory statistics. Parameters \u00a4 str The path to start calculating from. Returns \u00a4 list List of all files contained in Directory int Total sum of bytes from all contents of dir int The size of pieces of the torrent contents. Source code in torrentfile\\utils.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 def path_stat ( path : str ) -> tuple : \"\"\" Calculate directory statistics. Parameters ---------- path : str The path to start calculating from. Returns ------- list List of all files contained in Directory int Total sum of bytes from all contents of dir int The size of pieces of the torrent contents. \"\"\" total_size , filelist = filelist_total ( path ) piece_length = get_piece_length ( total_size ) return ( filelist , total_size , piece_length )","title":"utils"},{"location":"utils/#torrentfile.utils.ArgumentError","text":"Bases: Exception Exception for mismatched or mistyped CLI arguments. Source code in torrentfile\\utils.py 123 124 125 126 class ArgumentError ( Exception ): \"\"\" Exception for mismatched or mistyped CLI arguments. \"\"\"","title":"ArgumentError"},{"location":"utils/#torrentfile.utils.Memo","text":"Memoize cache.","title":"Memo"},{"location":"utils/#torrentfile.utils.Memo--parameters","text":"Callable The results of this callable will be cached. Source code in torrentfile\\utils.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class Memo : \"\"\" Memoize cache. Parameters ---------- func : Callable The results of this callable will be cached. \"\"\" def __init__ ( self , func ): \"\"\" Construct for memoization. \"\"\" self . func = func self . counter = 0 self . cache = {} def __call__ ( self , path ): \"\"\" Invoke each time memo function is called. Parameters ---------- path : str The relative or absolute path being used as key in cache dict. Returns ------- Any : The results of calling the function with path. \"\"\" if path in self . cache and os . path . exists ( path ): self . counter += 1 return self . cache [ path ] result = self . func ( path ) self . cache [ path ] = result return result","title":"Parameters"},{"location":"utils/#torrentfile.utils.Memo.__call__","text":"Invoke each time memo function is called.","title":"__call__()"},{"location":"utils/#torrentfile.utils.Memo.__call__--parameters","text":"str The relative or absolute path being used as key in cache dict.","title":"Parameters"},{"location":"utils/#torrentfile.utils.Memo.__call__--returns","text":"Any The results of calling the function with path. Source code in torrentfile\\utils.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def __call__ ( self , path ): \"\"\" Invoke each time memo function is called. Parameters ---------- path : str The relative or absolute path being used as key in cache dict. Returns ------- Any : The results of calling the function with path. \"\"\" if path in self . cache and os . path . exists ( path ): self . counter += 1 return self . cache [ path ] result = self . func ( path ) self . cache [ path ] = result return result","title":"Returns"},{"location":"utils/#torrentfile.utils.Memo.__init__","text":"Construct for memoization. Source code in torrentfile\\utils.py 51 52 53 54 55 56 57 def __init__ ( self , func ): \"\"\" Construct for memoization. \"\"\" self . func = func self . counter = 0 self . cache = {}","title":"__init__()"},{"location":"utils/#torrentfile.utils.MissingPathError","text":"Bases: Exception Path parameter is required to specify target content. Creating a .torrent file with no contents seems rather silly.","title":"MissingPathError"},{"location":"utils/#torrentfile.utils.MissingPathError--parameters","text":"str Message for user (optional). Source code in torrentfile\\utils.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class MissingPathError ( Exception ): \"\"\" Path parameter is required to specify target content. Creating a .torrent file with no contents seems rather silly. Parameters ---------- message : str Message for user (optional). \"\"\" def __init__ ( self , message : str = None ): \"\"\" Raise when creating a meta file without specifying target content. The `message` argument is a message to pass to Exception base class. \"\"\" self . message = f \"Path arguement is missing and required { str ( message ) } \" super () . __init__ ( message )","title":"Parameters"},{"location":"utils/#torrentfile.utils.MissingPathError.__init__","text":"Raise when creating a meta file without specifying target content. The message argument is a message to pass to Exception base class. Source code in torrentfile\\utils.py 93 94 95 96 97 98 99 100 def __init__ ( self , message : str = None ): \"\"\" Raise when creating a meta file without specifying target content. The `message` argument is a message to pass to Exception base class. \"\"\" self . message = f \"Path arguement is missing and required { str ( message ) } \" super () . __init__ ( message )","title":"__init__()"},{"location":"utils/#torrentfile.utils.PieceLengthValueError","text":"Bases: Exception Piece Length parameter must equal a perfect power of 2.","title":"PieceLengthValueError"},{"location":"utils/#torrentfile.utils.PieceLengthValueError--parameters","text":"str Message for user (optional). Source code in torrentfile\\utils.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class PieceLengthValueError ( Exception ): \"\"\" Piece Length parameter must equal a perfect power of 2. Parameters ---------- message : str Message for user (optional). \"\"\" def __init__ ( self , message : str = None ): \"\"\" Raise when creating a meta file with incorrect piece length value. The `message` argument is a message to pass to Exception base class. \"\"\" self . message = f \"Incorrect value for piece length: { str ( message ) } \" super () . __init__ ( message )","title":"Parameters"},{"location":"utils/#torrentfile.utils.PieceLengthValueError.__init__","text":"Raise when creating a meta file with incorrect piece length value. The message argument is a message to pass to Exception base class. Source code in torrentfile\\utils.py 113 114 115 116 117 118 119 120 def __init__ ( self , message : str = None ): \"\"\" Raise when creating a meta file with incorrect piece length value. The `message` argument is a message to pass to Exception base class. \"\"\" self . message = f \"Incorrect value for piece length: { str ( message ) } \" super () . __init__ ( message )","title":"__init__()"},{"location":"utils/#torrentfile.utils._filelist_total","text":"Search directory tree for files.","title":"_filelist_total()"},{"location":"utils/#torrentfile.utils._filelist_total--parameters","text":"str Path to file or directory base","title":"Parameters"},{"location":"utils/#torrentfile.utils._filelist_total--returns","text":"int Sum of all filesizes in filelist. list All file paths within directory tree. Source code in torrentfile\\utils.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def _filelist_total ( path : str ) -> tuple : \"\"\" Search directory tree for files. Parameters ---------- path : str Path to file or directory base Returns ------- int Sum of all filesizes in filelist. list All file paths within directory tree. \"\"\" if path . is_file (): file_size = os . path . getsize ( path ) return file_size , [ str ( path )] total = 0 filelist = [] if path . is_dir (): for item in path . iterdir (): size , paths = filelist_total ( item ) total += size filelist . extend ( paths ) return total , sorted ( filelist )","title":"Returns"},{"location":"utils/#torrentfile.utils.filelist_total","text":"Perform error checking and format conversion to os.PathLike.","title":"filelist_total()"},{"location":"utils/#torrentfile.utils.filelist_total--parameters","text":"str An existing filesystem path.","title":"Parameters"},{"location":"utils/#torrentfile.utils.filelist_total--returns","text":"os.PathLike Input path converted to bytes format.","title":"Returns"},{"location":"utils/#torrentfile.utils.filelist_total--raises","text":"MissingPathError File could not be found. Source code in torrentfile\\utils.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 @Memo def filelist_total ( pathstring : str ) -> os . PathLike : \"\"\" Perform error checking and format conversion to os.PathLike. Parameters ---------- pathstring : str An existing filesystem path. Returns ------- os.PathLike Input path converted to bytes format. Raises ------ MissingPathError File could not be found. \"\"\" if os . path . exists ( pathstring ): path = Path ( pathstring ) return _filelist_total ( path ) raise MissingPathError","title":"Raises"},{"location":"utils/#torrentfile.utils.get_file_list","text":"Return a sorted list of file paths contained in directory.","title":"get_file_list()"},{"location":"utils/#torrentfile.utils.get_file_list--parameters","text":"str target file or directory.","title":"Parameters"},{"location":"utils/#torrentfile.utils.get_file_list--returns","text":"list sorted list of file paths. Source code in torrentfile\\utils.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 def get_file_list ( path : str ) -> list : \"\"\" Return a sorted list of file paths contained in directory. Parameters ---------- path : str target file or directory. Returns ------- list sorted list of file paths. \"\"\" _ , filelist = filelist_total ( path ) return filelist","title":"Returns"},{"location":"utils/#torrentfile.utils.get_piece_length","text":"Calculate the ideal piece length for bittorrent data.","title":"get_piece_length()"},{"location":"utils/#torrentfile.utils.get_piece_length--parameters","text":"int Total bits of all files incluided in .torrent file.","title":"Parameters"},{"location":"utils/#torrentfile.utils.get_piece_length--returns","text":"int Ideal piece length. Source code in torrentfile\\utils.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def get_piece_length ( size : int ) -> int : \"\"\" Calculate the ideal piece length for bittorrent data. Parameters ---------- size : int Total bits of all files incluided in .torrent file. Returns ------- int Ideal piece length. \"\"\" exp = 14 while size / ( 2 ** exp ) > 200 and exp < 25 : exp += 1 return 2 ** exp","title":"Returns"},{"location":"utils/#torrentfile.utils.humanize_bytes","text":"Convert integer into human readable memory sized denomination.","title":"humanize_bytes()"},{"location":"utils/#torrentfile.utils.humanize_bytes--parameters","text":"int total number of bytes.","title":"Parameters"},{"location":"utils/#torrentfile.utils.humanize_bytes--returns","text":"str human readable representation of the given amount of bytes. Source code in torrentfile\\utils.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def humanize_bytes ( amount : int ) -> str : \"\"\" Convert integer into human readable memory sized denomination. Parameters ---------- amount : int total number of bytes. Returns ------- str human readable representation of the given amount of bytes. \"\"\" if amount < 1024 : return str ( amount ) if 1024 <= amount < 1_048_576 : return f \" { amount // 1024 } KiB\" if 1_048_576 <= amount < 1_073_741_824 : return f \" { amount // 1_048_576 } MiB\" return f \" { amount // 1073741824 } GiB\"","title":"Returns"},{"location":"utils/#torrentfile.utils.next_power_2","text":"Calculate the next perfect power of 2 equal to or greater than value.","title":"next_power_2()"},{"location":"utils/#torrentfile.utils.next_power_2--parameters","text":"int integer value that is less than some perfect power of 2.","title":"Parameters"},{"location":"utils/#torrentfile.utils.next_power_2--returns","text":"int The next power of 2 greater than value, or value if already power of 2. Source code in torrentfile\\utils.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 def next_power_2 ( value : int ) -> int : \"\"\" Calculate the next perfect power of 2 equal to or greater than value. Parameters ---------- value : int integer value that is less than some perfect power of 2. Returns ------- int The next power of 2 greater than value, or value if already power of 2. \"\"\" if not value & ( value - 1 ) and value : return value start = 1 while start < value : start <<= 1 return start","title":"Returns"},{"location":"utils/#torrentfile.utils.normalize_piece_length","text":"Verify input piece_length is valid and convert accordingly.","title":"normalize_piece_length()"},{"location":"utils/#torrentfile.utils.normalize_piece_length--parameters","text":"int | str The piece length provided by user.","title":"Parameters"},{"location":"utils/#torrentfile.utils.normalize_piece_length--returns","text":"int normalized piece length.","title":"Returns"},{"location":"utils/#torrentfile.utils.normalize_piece_length--raises","text":"PieceLengthValueError Piece length is improper value. Source code in torrentfile\\utils.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def normalize_piece_length ( piece_length : int ) -> int : \"\"\" Verify input piece_length is valid and convert accordingly. Parameters ---------- piece_length : int | str The piece length provided by user. Returns ------- int normalized piece length. Raises ------ PieceLengthValueError : Piece length is improper value. \"\"\" if isinstance ( piece_length , str ): if piece_length . isnumeric (): piece_length = int ( piece_length ) else : raise PieceLengthValueError ( piece_length ) if 13 < piece_length < 26 : return 2 ** piece_length if piece_length <= 13 : raise PieceLengthValueError ( piece_length ) log = int ( math . log2 ( piece_length )) if 2 ** log == piece_length : return piece_length raise PieceLengthValueError","title":"Raises"},{"location":"utils/#torrentfile.utils.path_piece_length","text":"Calculate piece length for input path and contents.","title":"path_piece_length()"},{"location":"utils/#torrentfile.utils.path_piece_length--parameters","text":"str The absolute path to directory and contents.","title":"Parameters"},{"location":"utils/#torrentfile.utils.path_piece_length--returns","text":"int The size of pieces of torrent content. Source code in torrentfile\\utils.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 def path_piece_length ( path : str ) -> int : \"\"\" Calculate piece length for input path and contents. Parameters ---------- path : str The absolute path to directory and contents. Returns ------- int The size of pieces of torrent content. \"\"\" psize = path_size ( path ) return get_piece_length ( psize )","title":"Returns"},{"location":"utils/#torrentfile.utils.path_size","text":"Return the total size of all files in path recursively.","title":"path_size()"},{"location":"utils/#torrentfile.utils.path_size--parameters","text":"str path to target file or directory.","title":"Parameters"},{"location":"utils/#torrentfile.utils.path_size--returns","text":"int total size of files. Source code in torrentfile\\utils.py 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 def path_size ( path : str ) -> int : \"\"\" Return the total size of all files in path recursively. Parameters ---------- path : str path to target file or directory. Returns ------- int total size of files. \"\"\" total_size , _ = filelist_total ( path ) return total_size","title":"Returns"},{"location":"utils/#torrentfile.utils.path_stat","text":"Calculate directory statistics.","title":"path_stat()"},{"location":"utils/#torrentfile.utils.path_stat--parameters","text":"str The path to start calculating from.","title":"Parameters"},{"location":"utils/#torrentfile.utils.path_stat--returns","text":"list List of all files contained in Directory int Total sum of bytes from all contents of dir int The size of pieces of the torrent contents. Source code in torrentfile\\utils.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 def path_stat ( path : str ) -> tuple : \"\"\" Calculate directory statistics. Parameters ---------- path : str The path to start calculating from. Returns ------- list List of all files contained in Directory int Total sum of bytes from all contents of dir int The size of pieces of the torrent contents. \"\"\" total_size , filelist = filelist_total ( path ) piece_length = get_piece_length ( total_size ) return ( filelist , total_size , piece_length )","title":"Returns"},{"location":"version/","text":"Holds the release version number.","title":"version"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage"}]}